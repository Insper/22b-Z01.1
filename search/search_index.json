{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo disciplina de Elementos de Sistemas! \u00b6 Curso: Engenharia Da Computa\u00e7\u00e3o - Terceiro semestre Disciplina: Elementos de Sistemas Insper - 2022-2. Prof. Renan Trevisoli / renantd@insper.edu.br Local: Laborat\u00f3rio de Inform\u00e1tica - 404 \u00a9 Todos os direitos reservados Criado por prof. Rafael Corsi / rafael.corsi@insper.edu.br Objetivos de aprendizagem \u00b6 Ao final da disciplina o estudante ser\u00e1 capaz de: Implementar um computador digital simples a partir de componentes eletr\u00f4nicos. Integrar as camadas de programa\u00e7\u00e3o e execu\u00e7\u00e3o de um computador simples. Trabalhar de forma colaborativa no desenvolvimento de um sistema computacional. Compreender a evolu\u00e7\u00e3o da inform\u00e1tica. Descrever como dados e instru\u00e7\u00f5es s\u00e3o armazenados e tratados em computadores. Motiva\u00e7\u00e3o \u00b6 Desenvolver um computador do ZERO! Avalia\u00e7\u00e3o \u00b6 A disciplina \u00e9 avaliada em duas frentes: avalia\u00e7\u00e3o individual e APS: Individual: ao longo do semestre o aluno deve acumular 50 pontos de Software e 50 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro avalia\u00e7\u00f5es (A1,A2,A3,A4) que ser\u00e3o aplicadas ao longo do semestre. APS: Compostas por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivos diferentes do curso. Infraestrutura \u00b6 O ferramental da disciplina foi desenvolvido para o sistema operacional Linux e necessita de uma s\u00e9rie de softwares e configurados. Voc\u00ea receber\u00e1 um SSD com tudo pronto. Bibliografia \u00b6 B\u00e1sica \u00b6 Livros NISAN, Noam; SCHOCKEN, Shimon., The Elements of Computing Systems, \u00aa ed., MIT Press, 2005 TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L., Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es, 11\u00aa ed., Pearson, 2011 PATTERSON, D.; HENNESSY, J. L., Organiza\u00e7\u00e3o e Projeto de Computadores: A Interface Hardware/Software., 4\u00aa ed., Campus, Artigos: Artigos KHAN, S. et. Al.. A high performance processor architecture for multimedia applications. Computer & Electrical Engineering. , v. 66 , p. 14-29 , 2018. ; Dispon\u00edvel em: https://www.sciencedirect.com/science/article/pii/S0045790616305894 . Acesso em: 04 ago 2019. Complementar \u00b6 Livros MOORE, Cristopher ; MERTENS, Stephan., The Nature of Computation, \u00aa ed., University Press, 2011 STALLINGS, W., Arquitetura e organiza\u00e7\u00e3o de computadores, 8\u00aa ed., Prentice Hall Brasil, 2010 LAING, Gordon., Digital Retro: The Evolution and Design of the Personal Computer, \u00aa ed., Sybex, 2004 NIELSEN, L., Computing: A Business History, \u00aa ed., New Street Communications LLC, 2012 FLOYD, T. L., Digital Fundamentals, 11\u00aa ed., Pearson, 2015","title":"Bem vindo disciplina de Elementos de Sistemas!"},{"location":"#bem-vindo-disciplina-de-elementos-de-sistemas","text":"Curso: Engenharia Da Computa\u00e7\u00e3o - Terceiro semestre Disciplina: Elementos de Sistemas Insper - 2022-2. Prof. Renan Trevisoli / renantd@insper.edu.br Local: Laborat\u00f3rio de Inform\u00e1tica - 404 \u00a9 Todos os direitos reservados Criado por prof. Rafael Corsi / rafael.corsi@insper.edu.br","title":"Bem vindo disciplina de Elementos de Sistemas!"},{"location":"#objetivos-de-aprendizagem","text":"Ao final da disciplina o estudante ser\u00e1 capaz de: Implementar um computador digital simples a partir de componentes eletr\u00f4nicos. Integrar as camadas de programa\u00e7\u00e3o e execu\u00e7\u00e3o de um computador simples. Trabalhar de forma colaborativa no desenvolvimento de um sistema computacional. Compreender a evolu\u00e7\u00e3o da inform\u00e1tica. Descrever como dados e instru\u00e7\u00f5es s\u00e3o armazenados e tratados em computadores.","title":"Objetivos de aprendizagem"},{"location":"#motivacao","text":"Desenvolver um computador do ZERO!","title":"Motiva\u00e7\u00e3o"},{"location":"#avaliacao","text":"A disciplina \u00e9 avaliada em duas frentes: avalia\u00e7\u00e3o individual e APS: Individual: ao longo do semestre o aluno deve acumular 50 pontos de Software e 50 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro avalia\u00e7\u00f5es (A1,A2,A3,A4) que ser\u00e3o aplicadas ao longo do semestre. APS: Compostas por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivos diferentes do curso.","title":"Avalia\u00e7\u00e3o"},{"location":"#infraestrutura","text":"O ferramental da disciplina foi desenvolvido para o sistema operacional Linux e necessita de uma s\u00e9rie de softwares e configurados. Voc\u00ea receber\u00e1 um SSD com tudo pronto.","title":"Infraestrutura"},{"location":"#bibliografia","text":"","title":"Bibliografia"},{"location":"#basica","text":"Livros NISAN, Noam; SCHOCKEN, Shimon., The Elements of Computing Systems, \u00aa ed., MIT Press, 2005 TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L., Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es, 11\u00aa ed., Pearson, 2011 PATTERSON, D.; HENNESSY, J. L., Organiza\u00e7\u00e3o e Projeto de Computadores: A Interface Hardware/Software., 4\u00aa ed., Campus, Artigos: Artigos KHAN, S. et. Al.. A high performance processor architecture for multimedia applications. Computer & Electrical Engineering. , v. 66 , p. 14-29 , 2018. ; Dispon\u00edvel em: https://www.sciencedirect.com/science/article/pii/S0045790616305894 . Acesso em: 04 ago 2019.","title":"B\u00e1sica"},{"location":"#complementar","text":"Livros MOORE, Cristopher ; MERTENS, Stephan., The Nature of Computation, \u00aa ed., University Press, 2011 STALLINGS, W., Arquitetura e organiza\u00e7\u00e3o de computadores, 8\u00aa ed., Prentice Hall Brasil, 2010 LAING, Gordon., Digital Retro: The Evolution and Design of the Personal Computer, \u00aa ed., Sybex, 2004 NIELSEN, L., Computing: A Business History, \u00aa ed., New Street Communications LLC, 2012 FLOYD, T. L., Digital Fundamentals, 11\u00aa ed., Pearson, 2015","title":"Complementar"},{"location":"A-Algebra-Transistores/","text":"A - \u00c1lgebra Booleana e Implementa\u00e7\u00e3o de Fun\u00e7\u00f5es L\u00f3gicas com Transistores \u00b6 Data da entrega Sexta - 02/09 Nesse projeto iremos utilizar a \u00e1lgebra booleana para obter as fun\u00e7\u00f5es l\u00f3gicas de um sistema as quais dever\u00e3o ser implementadas utilizando transistores. Esse projeto dever\u00e1 ser realizado em duplas ou trios e os arquivos devem ser enviados pelo GitHub Classroom. Queremos controlar o rob\u00f4 asprirador de p\u00f3 da figura a seguir: onde y1 e y2 s\u00e3o sinais de sa\u00edda de 2 bits cada para os motores da esquerda e direita e x1, x2 e x3 s\u00e3o sensores para detectar a colis\u00e3o do rob\u00f4. Os sinais de y1 e y2 descrevem os seguintes movimentos: \"00\" - motor desigado \"01\" - motor ligado diretamente (andando para frente) \"10\" - motor ligado reversamente (andando para tr\u00e1s) \"11\" - n\u00e3o deve ser utilizado O controle deve ser feito da seguinte forma: O motor esquerdo (y1) dever\u00e1 ser desligado e o motor direito (y2) ligado reversamente, permitindo que o rob\u00f4 rotacione em sentido hor\u00e1rio, sempre que uma colis\u00e3o for detectada em x1 ou (x1 e x3), mas n\u00e3o em x2. O motor esquerdo (y1) dever\u00e1 ser ligado reversamente e o motor direito (y2) desligado, permitindo que o rob\u00f4 rotacione em sentido anti-hor\u00e1rio, sempre que uma colis\u00e3o for detectada em x2 ou (x2 e x3), mas n\u00e3o em x1. Ambos os motores devem ser ligados reversamente se todos os sensores detectarem colis\u00e3o, ou (x1 e x2), ou apenas x3. Todos os motores devem ser ligados diretamente se nenhum sensor indicar colis\u00e3o. -> Caso alguma condi\u00e7\u00e3o l\u00f3gica esteja presente em mais de uma instru\u00e7\u00e3o, considerar a primeira condi\u00e7\u00e3o que ocorre! Rubricas \u00b6 Conceito Descritivo A+ Fun\u00e7\u00f5es l\u00f3gicas implementadas com transistores no protoboard Anexar video no reposit\u00f3rio da atividade B+ Fun\u00e7\u00f5es l\u00f3gicas implementadas com transistores no simulador falstad ou tinkercad Anexar video e/ou o arquivo texto da simula\u00e7\u00e3o no reposit\u00f3rio da atividade C+ Fun\u00e7\u00f5es l\u00f3gicas obtidas e simplificadas Anexar foto da resolu\u00e7\u00e3o D Fun\u00e7\u00f5es l\u00f3gicas obtidas mas n\u00e3o simplificadas I Fun\u00e7\u00f5es l\u00f3gicas n\u00e3o obtidas","title":"A - \u00c1lgebra Booleana e Implementa\u00e7\u00e3o de Fun\u00e7\u00f5es L\u00f3gicas com Transistores"},{"location":"A-Algebra-Transistores/#a-algebra-booleana-e-implementacao-de-funcoes-logicas-com-transistores","text":"Data da entrega Sexta - 02/09 Nesse projeto iremos utilizar a \u00e1lgebra booleana para obter as fun\u00e7\u00f5es l\u00f3gicas de um sistema as quais dever\u00e3o ser implementadas utilizando transistores. Esse projeto dever\u00e1 ser realizado em duplas ou trios e os arquivos devem ser enviados pelo GitHub Classroom. Queremos controlar o rob\u00f4 asprirador de p\u00f3 da figura a seguir: onde y1 e y2 s\u00e3o sinais de sa\u00edda de 2 bits cada para os motores da esquerda e direita e x1, x2 e x3 s\u00e3o sensores para detectar a colis\u00e3o do rob\u00f4. Os sinais de y1 e y2 descrevem os seguintes movimentos: \"00\" - motor desigado \"01\" - motor ligado diretamente (andando para frente) \"10\" - motor ligado reversamente (andando para tr\u00e1s) \"11\" - n\u00e3o deve ser utilizado O controle deve ser feito da seguinte forma: O motor esquerdo (y1) dever\u00e1 ser desligado e o motor direito (y2) ligado reversamente, permitindo que o rob\u00f4 rotacione em sentido hor\u00e1rio, sempre que uma colis\u00e3o for detectada em x1 ou (x1 e x3), mas n\u00e3o em x2. O motor esquerdo (y1) dever\u00e1 ser ligado reversamente e o motor direito (y2) desligado, permitindo que o rob\u00f4 rotacione em sentido anti-hor\u00e1rio, sempre que uma colis\u00e3o for detectada em x2 ou (x2 e x3), mas n\u00e3o em x1. Ambos os motores devem ser ligados reversamente se todos os sensores detectarem colis\u00e3o, ou (x1 e x2), ou apenas x3. Todos os motores devem ser ligados diretamente se nenhum sensor indicar colis\u00e3o. -> Caso alguma condi\u00e7\u00e3o l\u00f3gica esteja presente em mais de uma instru\u00e7\u00e3o, considerar a primeira condi\u00e7\u00e3o que ocorre!","title":"A - \u00c1lgebra Booleana e Implementa\u00e7\u00e3o de Fun\u00e7\u00f5es L\u00f3gicas com Transistores"},{"location":"A-Algebra-Transistores/#rubricas","text":"Conceito Descritivo A+ Fun\u00e7\u00f5es l\u00f3gicas implementadas com transistores no protoboard Anexar video no reposit\u00f3rio da atividade B+ Fun\u00e7\u00f5es l\u00f3gicas implementadas com transistores no simulador falstad ou tinkercad Anexar video e/ou o arquivo texto da simula\u00e7\u00e3o no reposit\u00f3rio da atividade C+ Fun\u00e7\u00f5es l\u00f3gicas obtidas e simplificadas Anexar foto da resolu\u00e7\u00e3o D Fun\u00e7\u00f5es l\u00f3gicas obtidas mas n\u00e3o simplificadas I Fun\u00e7\u00f5es l\u00f3gicas n\u00e3o obtidas","title":"Rubricas"},{"location":"A-Ambiente-Desenvolvimento-Projeto/","text":"A - Ambiente de desenvolvimento \u00b6 Nesse projeto iremos configurar grande parte do ambiente de desenvolvimento a ser utilizado por toda a disciplina, que \u00e9 composto basicamente pelas ferramentas: Reposit\u00f3rio github Teams Actions Esse projeto tamb\u00e9m tem como objetivo introduzir a din\u00e2mica de trabalho e avalia\u00e7\u00e3o que ser\u00e1 usada na disciplina, onde uma pessoa \u00e9 respons\u00e1vel pela gest\u00e3o do projeto e avalia\u00e7\u00e3o dos colegas e as demais por implementar o que \u00e9 pedido. Para executar esse projeto basta completar os laborat\u00f3rios: Lab 1: Configurando Github Lab 2: Github Rubricas \u00b6 Cada projeto da disciplina \u00e9 composto por duas notas: Grupo E Individual . A nota desse projeto espec\u00edfico \u00e9 bin\u00e1ria: A ou I . Grupo \u00b6 Para a entrega ser aceita: Ter o reposit\u00f3rio forkado Nome atualizado do fork github configurado com issues e project GRUPO.json atualizado corretamente INTEGRANTES.json atualizado Teste de arquivos .json passando Integrantes do grupo realizaram pull-request e os mesmos foram aceitos Ter criado um canal dentro no Teams da disciplina Individual \u00b6 Para a entrega individual ser aceita: Participar do reposit\u00f3rio do grupo Ter configurado INTEGRANTES.json Ter criado uma branch e realizado o pull-Request Ter entrado no canal da disciplina (teams) Ter entrado no canal do grupo (teams)","title":"A - Ambiente de desenvolvimento"},{"location":"A-Ambiente-Desenvolvimento-Projeto/#a-ambiente-de-desenvolvimento","text":"Nesse projeto iremos configurar grande parte do ambiente de desenvolvimento a ser utilizado por toda a disciplina, que \u00e9 composto basicamente pelas ferramentas: Reposit\u00f3rio github Teams Actions Esse projeto tamb\u00e9m tem como objetivo introduzir a din\u00e2mica de trabalho e avalia\u00e7\u00e3o que ser\u00e1 usada na disciplina, onde uma pessoa \u00e9 respons\u00e1vel pela gest\u00e3o do projeto e avalia\u00e7\u00e3o dos colegas e as demais por implementar o que \u00e9 pedido. Para executar esse projeto basta completar os laborat\u00f3rios: Lab 1: Configurando Github Lab 2: Github","title":"A - Ambiente de desenvolvimento"},{"location":"A-Ambiente-Desenvolvimento-Projeto/#rubricas","text":"Cada projeto da disciplina \u00e9 composto por duas notas: Grupo E Individual . A nota desse projeto espec\u00edfico \u00e9 bin\u00e1ria: A ou I .","title":"Rubricas"},{"location":"A-Ambiente-Desenvolvimento-Projeto/#grupo","text":"Para a entrega ser aceita: Ter o reposit\u00f3rio forkado Nome atualizado do fork github configurado com issues e project GRUPO.json atualizado corretamente INTEGRANTES.json atualizado Teste de arquivos .json passando Integrantes do grupo realizaram pull-request e os mesmos foram aceitos Ter criado um canal dentro no Teams da disciplina","title":"Grupo"},{"location":"A-Ambiente-Desenvolvimento-Projeto/#individual","text":"Para a entrega individual ser aceita: Participar do reposit\u00f3rio do grupo Ter configurado INTEGRANTES.json Ter criado uma branch e realizado o pull-Request Ter entrado no canal da disciplina (teams) Ter entrado no canal do grupo (teams)","title":"Individual"},{"location":"A-Ambiente-Lab-1/","text":"Lab 2: Configurando Github \u00b6 Devemos come\u00e7ar a preparar o terreno para os projetos em grupo que estar\u00e3o por vir, nessa etapa voc\u00eas devem montar um grupo de \u215a colegas e dar um nome a ele (os grupos s\u00e3o nomeados por letras, a primeira letra do nome do seu grupo ser\u00e1 fornecida pelo professor). O grupo ir\u00e1 trabalhar de forma colaborativa via a utiliza\u00e7\u00e3o do git/ github. \u00c9 imprescind\u00edvel que todos trabalhem dessa forma, pois ser\u00e1 a maneira que iremos avaliar individualmente voc\u00eas. Criando o grupo \u00b6 Grupo de at\u00e9 6 pessoas! Preencher a tabela a seguir: Tabela - Grupos GitHub \u00b6 O git ser\u00e1 uma das ferramentas mais importantes para o projeto. Utilizar o link fornecido no Blackboard para acessar a atividade no Github Classroom. Um reposit\u00f3rio com o nome \"aps-<projeto>-<nome do grupo>\" ser\u00e1 criado. Ferramentas github \u00b6 git GitHub Inc. is a web-based hosting service for version control using Git. It is mostly used for computer code. It offers all of the distributed version control and source code management functionality of Git as well as adding its own features. Wikipedia http://github.com Nessa disciplina iremos utilizar n\u00e3o s\u00f3 a ferramenta principal do github, que \u00e9 o servidor de reposit\u00f3rios git, mas todas as outras ferramentas j\u00e1 integradas na plataforma para gest\u00e3o e acompanhamento de projeto. Ferramentas github Github Project : Ferramenta do github para gerenciamento de projetos (estilo Kambam), cada reposit\u00f3rio pode ter N projetos, e o github automatiza o processo de todo/doing/done deixando de maneira visual as tarefas. github issues : Plataforma do github para cria\u00e7\u00e3o de tarefas/ reportar erros. As tarefas aqui criadas ser\u00e3o associadas a um projeto espec\u00edfico e a um grupo de pessoas espec\u00edficas. Branch : Ramo criado para implementar um feature/ corre\u00e7\u00e3o de bug que ser\u00e1 futuramente incorporado no master (merge) Main : Ramo principal do projeto, gerenciado pelo Scrum Master Pull-request : Maneira de um l\u00edder de projeto receber altera\u00e7\u00f5es a um projeto e ter controle do que ser\u00e1 aceito ou n\u00e3o. Na maioria dos casos o pull-request \u00e9 criado por um usu\u00e1rio e revisado por outro. Quem for fazer a eletiva de Desenvolvimento Aberto do Prof. Igor ver\u00e1 bem a fundo essa quest\u00e3o. Actions \u00b6 Ir\u00e1 executar de forma autom\u00e1tica alguns testes (criado por n\u00f3s) no projeto e em caso de alguma falha ir\u00e1 notificar no github. Como ele funciona ? Ele fica verificando o reposit\u00f3rio por altera\u00e7\u00f5es (voc\u00ea deve al\u00e9m de dar commit, dar push) e para cada novo commit ele faz o seguinte Inicializa uma nova m\u00e1quina virtual na nuvem (ubuntu, windows, mac) Instala todo a infra necess\u00e1ria do projeto (no caso do Z01.1 : python, java, Quartus, ...) Executa os scripts de teste localizados em cada projeto. Desliga e \"deleta\" a m\u00e1quina virtual rec\u00e9m criada. O arquivo de configura\u00e7\u00e3o est\u00e1 localizado na pasta: <repo>/.github/workflows/ . Nele que est\u00e3o feitas todas as defini\u00e7\u00f5es de execu\u00e7\u00e3o. Na pagina do seu reposit\u00f3rio em commits deve aparecer uma pequena bolinha em cada um dos commits novos que ser\u00e3o feitos no projeto, esse indicador ser\u00e1 atualizado pelo travis sendo: Amarelo: O teste est\u00e1 em execu\u00e7\u00e3o Verde: O teste passou Vermelho: O teste falhou Note Cada teste leva em torno de alguns minutos j\u00e1 que toda a infraestrutura \u00e9 instalada sempre do zero, n\u00e3o utilize o sistema de Integra\u00e7\u00e3o Cont\u00ednua para validar as suas novas implementa\u00e7\u00f5es, esse sistema deve ser utilizado para encontrar problemas mais amplos ou para o scrum master aceitar ou n\u00e3o um pull-request, j\u00e1 que o resultado do sucesso ou n\u00e3o dessa requisi\u00e7\u00e3o \u00e9 vis\u00edvel facilmente. Arquivo GRUPO.json de configura\u00e7\u00e3o \u00b6 Um por grupo Somente um do grupo deve realizar isso. O mediador desse projeto deve editar o arquivo json GRUPO.json que est\u00e1 localizado na raiz do projeto inserindo a letra do grupo (que foi atribu\u00edda em sala) e o nome rec\u00e9m criado do grupo (o nome do grupo deve ser uma Frase com a primeira palavra come\u00e7ando com a letra do Grupo). Exemplo um grupo com a letra M , GRUPO.json : { \"Nome-Grupo\" : \"Macarrao\" } Ap\u00f3s editar o arquivo deve-se: fazer um commit e um push para o reposit\u00f3rio. $ git commit -am \"update Grupo\" $ git push origin main","title":"Lab 2: Configurando Github"},{"location":"A-Ambiente-Lab-1/#lab-2-configurando-github","text":"Devemos come\u00e7ar a preparar o terreno para os projetos em grupo que estar\u00e3o por vir, nessa etapa voc\u00eas devem montar um grupo de \u215a colegas e dar um nome a ele (os grupos s\u00e3o nomeados por letras, a primeira letra do nome do seu grupo ser\u00e1 fornecida pelo professor). O grupo ir\u00e1 trabalhar de forma colaborativa via a utiliza\u00e7\u00e3o do git/ github. \u00c9 imprescind\u00edvel que todos trabalhem dessa forma, pois ser\u00e1 a maneira que iremos avaliar individualmente voc\u00eas.","title":"Lab 2: Configurando Github"},{"location":"A-Ambiente-Lab-1/#criando-o-grupo","text":"Grupo de at\u00e9 6 pessoas! Preencher a tabela a seguir: Tabela - Grupos","title":"Criando o grupo"},{"location":"A-Ambiente-Lab-1/#github","text":"O git ser\u00e1 uma das ferramentas mais importantes para o projeto. Utilizar o link fornecido no Blackboard para acessar a atividade no Github Classroom. Um reposit\u00f3rio com o nome \"aps-<projeto>-<nome do grupo>\" ser\u00e1 criado.","title":"GitHub"},{"location":"A-Ambiente-Lab-1/#ferramentas-github","text":"git GitHub Inc. is a web-based hosting service for version control using Git. It is mostly used for computer code. It offers all of the distributed version control and source code management functionality of Git as well as adding its own features. Wikipedia http://github.com Nessa disciplina iremos utilizar n\u00e3o s\u00f3 a ferramenta principal do github, que \u00e9 o servidor de reposit\u00f3rios git, mas todas as outras ferramentas j\u00e1 integradas na plataforma para gest\u00e3o e acompanhamento de projeto. Ferramentas github Github Project : Ferramenta do github para gerenciamento de projetos (estilo Kambam), cada reposit\u00f3rio pode ter N projetos, e o github automatiza o processo de todo/doing/done deixando de maneira visual as tarefas. github issues : Plataforma do github para cria\u00e7\u00e3o de tarefas/ reportar erros. As tarefas aqui criadas ser\u00e3o associadas a um projeto espec\u00edfico e a um grupo de pessoas espec\u00edficas. Branch : Ramo criado para implementar um feature/ corre\u00e7\u00e3o de bug que ser\u00e1 futuramente incorporado no master (merge) Main : Ramo principal do projeto, gerenciado pelo Scrum Master Pull-request : Maneira de um l\u00edder de projeto receber altera\u00e7\u00f5es a um projeto e ter controle do que ser\u00e1 aceito ou n\u00e3o. Na maioria dos casos o pull-request \u00e9 criado por um usu\u00e1rio e revisado por outro. Quem for fazer a eletiva de Desenvolvimento Aberto do Prof. Igor ver\u00e1 bem a fundo essa quest\u00e3o.","title":"Ferramentas github"},{"location":"A-Ambiente-Lab-1/#actions","text":"Ir\u00e1 executar de forma autom\u00e1tica alguns testes (criado por n\u00f3s) no projeto e em caso de alguma falha ir\u00e1 notificar no github. Como ele funciona ? Ele fica verificando o reposit\u00f3rio por altera\u00e7\u00f5es (voc\u00ea deve al\u00e9m de dar commit, dar push) e para cada novo commit ele faz o seguinte Inicializa uma nova m\u00e1quina virtual na nuvem (ubuntu, windows, mac) Instala todo a infra necess\u00e1ria do projeto (no caso do Z01.1 : python, java, Quartus, ...) Executa os scripts de teste localizados em cada projeto. Desliga e \"deleta\" a m\u00e1quina virtual rec\u00e9m criada. O arquivo de configura\u00e7\u00e3o est\u00e1 localizado na pasta: <repo>/.github/workflows/ . Nele que est\u00e3o feitas todas as defini\u00e7\u00f5es de execu\u00e7\u00e3o. Na pagina do seu reposit\u00f3rio em commits deve aparecer uma pequena bolinha em cada um dos commits novos que ser\u00e3o feitos no projeto, esse indicador ser\u00e1 atualizado pelo travis sendo: Amarelo: O teste est\u00e1 em execu\u00e7\u00e3o Verde: O teste passou Vermelho: O teste falhou Note Cada teste leva em torno de alguns minutos j\u00e1 que toda a infraestrutura \u00e9 instalada sempre do zero, n\u00e3o utilize o sistema de Integra\u00e7\u00e3o Cont\u00ednua para validar as suas novas implementa\u00e7\u00f5es, esse sistema deve ser utilizado para encontrar problemas mais amplos ou para o scrum master aceitar ou n\u00e3o um pull-request, j\u00e1 que o resultado do sucesso ou n\u00e3o dessa requisi\u00e7\u00e3o \u00e9 vis\u00edvel facilmente.","title":"Actions"},{"location":"A-Ambiente-Lab-1/#arquivo-grupojson-de-configuracao","text":"Um por grupo Somente um do grupo deve realizar isso. O mediador desse projeto deve editar o arquivo json GRUPO.json que est\u00e1 localizado na raiz do projeto inserindo a letra do grupo (que foi atribu\u00edda em sala) e o nome rec\u00e9m criado do grupo (o nome do grupo deve ser uma Frase com a primeira palavra come\u00e7ando com a letra do Grupo). Exemplo um grupo com a letra M , GRUPO.json : { \"Nome-Grupo\" : \"Macarrao\" } Ap\u00f3s editar o arquivo deve-se: fazer um commit e um push para o reposit\u00f3rio. $ git commit -am \"update Grupo\" $ git push origin main","title":"Arquivo GRUPO.json de configura\u00e7\u00e3o"},{"location":"A-Ambiente-Lab-2/","text":"Lab 3: Github \u00b6 Nesse laborat\u00f3rio iremos trabalhar com o uso do git de forma colaborativa. Aconselh\u00e1vel fazer no Linux, mas pode fazer no Windows (precisa ter git instalado). Clonando \u00b6 Individual Todos do grupo devem realizar de maneira individual! Vc\u00eas dever\u00e3o clonar o reposit\u00f3rio para o computador de voc\u00eas com o comando: $ git clone $URL_DO_FORK $URL_DO_FORK A URL do seu fork pode ser obtida pelo bot\u00e3o 'Clone or Download' do github Note que a url exibida \u00e9 do reposit\u00f3rio base da disciplina, voc\u00eas devem clonar o reposit\u00f3rio que foi criado no Lab 1 Linux O s\u00edmbolo $ indica que \u00e9 um comando para ser executado no terminal do Linux ( bash ), mas ele n\u00e3o deve fazer parte do comando. No caso anterior, o comando a ser colado deve ser: git clone URL_DO_FORK . Linux Para abrir o terminal: meta + t Progress Cheguei Aqui! Adicionando nomes ao INTEGRANTES.json \u00b6 Individual Deve ser realizado individual por todos do grupo. Tip Antes de come\u00e7ar, atualize seu reposit\u00f3rio com o remoto $ git pull origin main Nesse etapa cada integrante do grupo ir\u00e1 editar um arquivo no seu computador e realizar um pull-request para o reposit\u00f3rio do grupo. Para isso seguiremos as etapas a seguir: Gerar mudan\u00e7as no reposit\u00f3rio local Criando um branch com as mudan\u00e7as Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request INTEGRANTES.json \u00b6 Cada integrante do grupo deve editar o documento com na raiz do projeto com nome INTEGRANTES.json e adicionar a esse arquivo o seu nome, e-mail (Insper) e usu\u00e1rio github. Conforme o exemplo a seguir: { \"aluno-1\" : { \"nome\" : \"Rafael Corsi\" , \"email-insper\" : \"rafael.corsi@insper.edu.br\" , \"user-github\" : \"rafaelcorsi\" }, Warning Uma \u00fanica pessoa n\u00e3o deve editar o documento com todos os nomes. Cada um deve realizar individualmente em seu computador. Progress Cheguei Aqui! branch / commit \u00b6 A fim de realizarmos um pull-request ao mediador do projeto \u00e9 preciso salvarmos essas modifica\u00e7\u00f5es em um novo branch. O comando a seguir faz isso: $ # criando um novo branch $ git checkout -B $NOME git Substitua nos comandos o termo $NOME pelo seu nome. Agora vamos fazer um commit com o seu nome nesse novo branch: $ git add INTEGRANTES.json $ git commit -m \"Adicionado meu $NOME ao arquivo\" Ser\u00e1 necess\u00e1rio enviarmos esse branch ao servidor (github) antes de realizarmos o pull-request : $ # enviando o branch para o reposit\u00f3rio remoto $ git push origin $NOME git Esse comando diz para o git que \u00e9 para enviar o branch $NOME para o reposit\u00f3rio remoto origin . Aquele que aparece no comando $ git remote -v . Progress Cheguei Aqui! Realizando pull-request \u00b6 Uma vez enviando o branch para o servidor, podemos via a interface web do github realizar o pull-request . Abra a p\u00e1gina do github do seu grupo. Vamos agora gerar o pull-request na interface do github, de forma similar ao exemplo a seguir: git Se tiver instalado o software hub digite na linha de comando: $ hub browser . Warning Cuidado! Escolher o seu reposit\u00f3rio no momento de realizar o pullrequest. Tip Ao realizar o PR, o Actions ir\u00e1 verificar o seu arquivo com o mesmo teste que voc\u00ea executou anteriormente, esse ser\u00e1 o fluxo geral da disciplina, onde o mesmo teste \u00e9 realizado local na m\u00e1quina de cada aluno e remoto automaticamente pelo Actions. Progress Cheguei Aqui! Aceitando pull-request \u00b6 Apenas o mediador Voc\u00eas devem escolher um do grupo para assumir o papel do mediador! O mediador do projeto deve revisar os pull-requests (e corrigir eventuais erros de merge) e aceitar ou negar o pedido.","title":"Lab 3: Github"},{"location":"A-Ambiente-Lab-2/#lab-3-github","text":"Nesse laborat\u00f3rio iremos trabalhar com o uso do git de forma colaborativa. Aconselh\u00e1vel fazer no Linux, mas pode fazer no Windows (precisa ter git instalado).","title":"Lab 3: Github"},{"location":"A-Ambiente-Lab-2/#clonando","text":"Individual Todos do grupo devem realizar de maneira individual! Vc\u00eas dever\u00e3o clonar o reposit\u00f3rio para o computador de voc\u00eas com o comando: $ git clone $URL_DO_FORK $URL_DO_FORK A URL do seu fork pode ser obtida pelo bot\u00e3o 'Clone or Download' do github Note que a url exibida \u00e9 do reposit\u00f3rio base da disciplina, voc\u00eas devem clonar o reposit\u00f3rio que foi criado no Lab 1 Linux O s\u00edmbolo $ indica que \u00e9 um comando para ser executado no terminal do Linux ( bash ), mas ele n\u00e3o deve fazer parte do comando. No caso anterior, o comando a ser colado deve ser: git clone URL_DO_FORK . Linux Para abrir o terminal: meta + t Progress Cheguei Aqui!","title":"Clonando"},{"location":"A-Ambiente-Lab-2/#adicionando-nomes-ao-integrantesjson","text":"Individual Deve ser realizado individual por todos do grupo. Tip Antes de come\u00e7ar, atualize seu reposit\u00f3rio com o remoto $ git pull origin main Nesse etapa cada integrante do grupo ir\u00e1 editar um arquivo no seu computador e realizar um pull-request para o reposit\u00f3rio do grupo. Para isso seguiremos as etapas a seguir: Gerar mudan\u00e7as no reposit\u00f3rio local Criando um branch com as mudan\u00e7as Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request","title":"Adicionando nomes ao INTEGRANTES.json"},{"location":"A-Ambiente-Lab-2/#integrantesjson","text":"Cada integrante do grupo deve editar o documento com na raiz do projeto com nome INTEGRANTES.json e adicionar a esse arquivo o seu nome, e-mail (Insper) e usu\u00e1rio github. Conforme o exemplo a seguir: { \"aluno-1\" : { \"nome\" : \"Rafael Corsi\" , \"email-insper\" : \"rafael.corsi@insper.edu.br\" , \"user-github\" : \"rafaelcorsi\" }, Warning Uma \u00fanica pessoa n\u00e3o deve editar o documento com todos os nomes. Cada um deve realizar individualmente em seu computador. Progress Cheguei Aqui!","title":"INTEGRANTES.json"},{"location":"A-Ambiente-Lab-2/#branch-commit","text":"A fim de realizarmos um pull-request ao mediador do projeto \u00e9 preciso salvarmos essas modifica\u00e7\u00f5es em um novo branch. O comando a seguir faz isso: $ # criando um novo branch $ git checkout -B $NOME git Substitua nos comandos o termo $NOME pelo seu nome. Agora vamos fazer um commit com o seu nome nesse novo branch: $ git add INTEGRANTES.json $ git commit -m \"Adicionado meu $NOME ao arquivo\" Ser\u00e1 necess\u00e1rio enviarmos esse branch ao servidor (github) antes de realizarmos o pull-request : $ # enviando o branch para o reposit\u00f3rio remoto $ git push origin $NOME git Esse comando diz para o git que \u00e9 para enviar o branch $NOME para o reposit\u00f3rio remoto origin . Aquele que aparece no comando $ git remote -v . Progress Cheguei Aqui!","title":"branch / commit"},{"location":"A-Ambiente-Lab-2/#realizando-pull-request","text":"Uma vez enviando o branch para o servidor, podemos via a interface web do github realizar o pull-request . Abra a p\u00e1gina do github do seu grupo. Vamos agora gerar o pull-request na interface do github, de forma similar ao exemplo a seguir: git Se tiver instalado o software hub digite na linha de comando: $ hub browser . Warning Cuidado! Escolher o seu reposit\u00f3rio no momento de realizar o pullrequest. Tip Ao realizar o PR, o Actions ir\u00e1 verificar o seu arquivo com o mesmo teste que voc\u00ea executou anteriormente, esse ser\u00e1 o fluxo geral da disciplina, onde o mesmo teste \u00e9 realizado local na m\u00e1quina de cada aluno e remoto automaticamente pelo Actions. Progress Cheguei Aqui!","title":"Realizando pull-request"},{"location":"A-Ambiente-Lab-2/#aceitando-pull-request","text":"Apenas o mediador Voc\u00eas devem escolher um do grupo para assumir o papel do mediador! O mediador do projeto deve revisar os pull-requests (e corrigir eventuais erros de merge) e aceitar ou negar o pedido.","title":"Aceitando pull-request"},{"location":"A-Transistores-Lab-1-22/","text":"Lab 1: Transistores / CI \u00b6 Sugest\u00e3o de como trabalhar Realizar individualmente as simula\u00e7\u00f5es online Realizar em grupo a montagem no protoboard Esse laborat\u00f3rio tem como objetivo trabalhar com os conceitos b\u00e1sicos de portas l\u00f3gicas do tipo RTL realizadas a base de transistores discretos do tipo BJT e tamb\u00e9m trabalhar com componentes integrados (CI) da fam\u00edlia CMOS. Existem basicamente tr\u00eas n\u00edveis de simula\u00e7\u00e3o de componentes eletr\u00f4nicos: a primeira, puramente l\u00f3gica utiliza de portas l\u00f3gicas \"ideais\" ( https://simulator.io/board ). Um simulador mais preciso ir\u00e1 utilizar transistores para a implementa\u00e7\u00e3o dessas portas l\u00f3gicas por\u00e9m n\u00e3o leva em considera\u00e7\u00e3o todos os fatores f\u00edsicos-eletr\u00f4nicos dos componentes ( http://falstad.com/circuit/ ). J\u00e1 um simulador que leva em considera\u00e7\u00e3o as propriedades dos componentes \u00e9 chamado de SPICE e ir\u00e1 gerar uma simula\u00e7\u00e3o mais precisa em termos f\u00edsicos do circuito original ( http://circuitlab.com ). Progress Cheguei Aqui! Parte 1 - Circuito misterioso \u00b6 Vamos usar o simulador do site falstad para implementar um circuito feito com transistores que implementa uma equa\u00e7\u00e3o booleana. Abra o site: http://www.falstad.com/circuit/ Arquivo Importar Arquivo Texto Copiar e colar o texto a seguir $ 1 0.000005 10.20027730826997 52 5 50 5e-11 R 368 64 320 64 0 0 40 6 0 0 0.5 g 368 432 368 496 0 0 t 320 208 368 208 0 1 -5.999999987759469 -1.926578083306543 100 default w 368 160 368 192 0 t 320 256 368 256 0 1 -1.9265780914939181 -1.2199999820401186e-8 100 default w 368 224 368 240 0 w 368 272 368 288 0 w 368 368 368 384 0 r 320 208 240 208 0 2000 r 240 256 320 256 0 2000 L 240 208 208 208 0 0 false 5 0 L 240 256 208 256 0 0 false 5 0 r 368 288 368 368 0 2000 r 368 288 448 288 0 2000 t 448 288 496 288 0 1 -5.999999971546844 1.625315590685889e-8 100 default t 448 368 496 368 0 1 -5.9999999878 -6.362935157139823e-17 100 default w 448 368 320 368 0 r 320 368 224 368 0 2000 w 496 272 496 160 0 w 496 160 368 160 0 w 368 160 368 64 0 w 496 352 544 352 0 w 544 352 544 160 0 w 544 160 496 160 0 w 496 304 576 304 0 w 496 384 576 384 0 w 576 384 576 304 0 r 576 400 576 464 0 1000 w 368 432 368 384 0 g 576 464 576 512 0 0 M 576 384 640 384 0 2.5 L 224 368 208 368 0 0 false 5 0 w 576 400 576 384 0 Voc\u00eas devem obter o seguinte diagrama: Exercise Com o circuito carregado no site, encontre: Encontre a tabela verdade do circuito. Fa\u00e7a todas as combina\u00e7\u00f5es poss\u00edveis de entradas (H/L) e verifique o valor da sa\u00edda (H/L) A partir da tabela verdade encontre a equa\u00e7\u00e3o l\u00f3gica. Desenhar o diagrama da equa\u00e7\u00e3o (simplificado). Outro circuito misterioso \u00b6 Implementar o outro circuito feito com transistores que implementa uma equa\u00e7\u00e3o booleana no simulador do site falstad. Abra o site: http://www.falstad.com/circuit/ Arquivo Importar Arquivo Texto Copiar e colar o texto a seguir $ 1 0.000005 10.20027730826997 52 5 50 5e-11 R 368 64 320 64 0 0 40 5 0 0 0.5 L 240 208 208 208 0 0 false 3.6 0 L 240 256 208 256 0 0 false 3.6 0 w 368 192 368 64 0 g 368 528 368 576 0 0 M 576 336 640 336 0 2.5 L 240 304 208 304 0 0 false 5 0 f 240 208 368 208 33 1.5 0.02 w 464 192 464 64 0 w 368 64 464 64 0 f 336 480 368 480 32 1.5 0.02 w 464 224 464 272 0 w 416 272 464 272 0 w 368 224 368 240 0 w 368 240 416 240 0 w 416 240 416 272 0 w 368 384 368 336 0 w 368 336 416 336 0 w 416 304 416 336 0 w 416 336 464 336 0 w 464 336 464 384 0 w 464 336 576 336 0 w 368 416 368 464 0 w 368 496 368 528 0 w 464 416 464 528 0 w 464 528 368 528 0 w 240 304 240 352 0 w 240 352 400 352 0 w 400 352 400 400 0 f 400 400 464 400 32 1.5 0.02 w 336 480 272 480 0 w 272 480 272 256 0 w 272 256 240 256 0 w 272 256 272 144 0 w 272 144 416 144 0 w 416 144 416 208 0 f 416 208 464 208 33 1.5 0.02 f 320 288 416 288 33 1.5 0.02 f 336 400 368 400 32 1.5 0.02 w 336 400 288 400 0 w 288 400 288 224 0 w 288 224 240 224 0 w 240 224 240 208 0 w 320 288 320 304 0 w 320 304 240 304 0 Exercise Assim como no circuito anterior, encontre: Encontre a tabela verdade do circuito. Fa\u00e7a todas as combina\u00e7\u00f5es poss\u00edveis de entradas (H/L) e verifique o valor da sa\u00edda (H/L) A partir da tabela verdade encontre a equa\u00e7\u00e3o l\u00f3gica. Desenhar o diagrama da equa\u00e7\u00e3o (simplificado). Progress Cheguei Aqui! Parte 2 - RTL e CMOS \u00b6 Material \u00b6 Cada grupo receber\u00e1: 2 protoboards 2 baterias 9V Jumpers macho-macho 10 transistores NPN s9013 10 transistores PNP s9012 20 resistores de 330 2 CIs CD4007 10 LEDs coloridos (Vermelho e amarelo) Trabalhando \u00b6 O grupo deve se organizar e executar da melhor forma poss\u00edvel (com todos participando) os m\u00f3dulos a seguir, utilizando: Entradas: Utilizar como entrada do sistema (A,B,C,...) jumpers que estar\u00e3o hora conectados em GND (0) ou VCC (1) . Sa\u00eddas: A sa\u00edda final do sistema deve ser representada com um LED, sendo aceso indicando l\u00f3gica 1 e apagado l\u00f3gica 0 . Valida\u00e7\u00e3o: Uma tabela verdade do circuito deve ser apresentada e em aula demonstrado que o circuito representa a tabela. a - NOT \u00b6 Iremos implementar uma porta l\u00f3gica do tipo NOT usando transistores BJT. Warning Se voc\u00ea perceber que algum transistor est\u00e1 aquecendo, desconecte a bateria e verifique novamente a montagem. Isso \u00e9 um sinal que alguma coisa est\u00e1 errada. Tarefa Levante a tabela verdade do circuito rec\u00e9m montado, \u00e9 uma not ? Tip Utilize o datasheet do transistor para entender a montagem Mexa na chave para aplicar 0 ou 1 na entrada do circuito. Solu\u00e7\u00e3o https://www.tinkercad.com/things/5UK9w22fykq-fantastic-vihelmo-lahdi/editel?sharecode=Pf5ZAOJK09Skvm128BIzTAuarSX-nLYnMMrE2YQYe7U Progress Cheguei Aqui! Implemente agora uma porta l\u00f3gica do tipo NOT usando transistores MOS utilizando o CD4007. Progress Cheguei Aqui! b - OR \u00b6 Implemente uma porta l\u00f3gica do tipo OR usando transistores BJT. Essa porta ter\u00e1 duas entradas e uma sa\u00edda, cada entrada deve ser uma chave e a sa\u00edda um LED. Tip Utilize a p\u00e1gina a seguir para ter ideias de como implementar as portas l\u00f3gicas em RTL: http://hyperphysics.phy-astr.gsu.edu/hbase/Electronic/trangate.html#c2 Progress Cheguei Aqui! Circuitos Integrados - CI \u00b6 Circuitos integrados s\u00e3o componentes eletr\u00f4nicos que possuem internamente dezenas a milhares de transistores que implementam circuitos eletr\u00f4nicos, facilitando e possibilitando o desenvolvimento de projetos de hardware mais complexos. Existem v\u00e1rias 'fam\u00edlias' de CI que implementam portas l\u00f3gicas, iremos trabalhar com uma vers\u00e3o chamada de s\u00e9rie TTL 7400 . Exemplos de componentes dessa fam\u00edlias: 7400: Quatro portas NAND de duas entradas 7401: Quatro portas NAND de duas entradas com coletor aberto 7402: Quatro portas NOR de duas entradas 7403: Quatro portas NAND de duas entradas com coletor aberto 7404: Seis inversores (porta NOT) Para a lista completa acesse: https://pt.wikipedia.org/wiki/Lista_dos_circuitos_integrados_da_s%C3%A9rie_7400 Vamos continuar no TinkerCad . a - NOT \u00b6 Vamos usar o componente 7404 que possui 6 NOTs para fazer a mesma coisa que fizemos com os transistor discreto: 7404 Para mais informa\u00e7\u00f5es, acesse: https://pt.wikipedia.org/wiki/TTL_7404 Solu\u00e7\u00e3o https://www.tinkercad.com/things/kLr9TtHWZiL-dazzling-gogo/editel?sharecode=-_Z8VZQsUBWqvOQtc0codGcJn5mnrZr7-LkwdooNvjM Progress Cheguei Aqui! b - Equa\u00e7\u00e3o \u00b6 Implemente a equa\u00e7\u00e3o com CIs da fam\u00edlia 74xx utilizando apenas portas nand e nor . Q = (A xor B) or not(C) Tip Identifique os componentes Procure na lista qual o seu nome Analise os pinos desse componente Fa\u00e7a a liga\u00e7\u00e3o e teste por parte Progress Cheguei Aqui! Praticando no papel \u00b6 Quest\u00e3o extra\u00edda do EXAME NACIONAL DE DESEMPENHO DOS ESTUDANTES 2014 Um processo monitora tr\u00eas par\u00e2metros para controle de qualidade: A , B , C . Cada par\u00e2metro possui um valor na decis\u00e3o final da qualidade. A exist\u00eancia do par\u00e2metro A pesa 30% na decis\u00e3o final, enquanto os par\u00e2metros B e C pesam 30% e 40%, respectivamente. O grau de aprova\u00e7\u00e3o do processo \u00e9 dado pela soma dos percentuais desses tr\u00eas par\u00e2metros. O produto gerado pelo processo \u00e9 considerado aprovado, caso o grau de qualidade seja superior ou igual a 60%, e reprovado, se o grau de qualidade for inferior ou igual a 30%. Caso o grau de qualidade esteja entre 30% e 60%, a decis\u00e3o de aprova\u00e7\u00e3o ou reprova\u00e7\u00e3o \u00e9 indiferente. Por exemplo, se um produto apresentar os par\u00e2metros A e B , ter\u00e1 grau de qualidade de 30%+30% = 60%, levando \u00e0 sua aprova\u00e7\u00e3o. Com base na situa\u00e7\u00e3o descrita, projete um circuito l\u00f3gico com o menor n\u00famero poss\u00edvel de portas l\u00f3gicas, para determinar a aprova\u00e7\u00e3o ou n\u00e3o do produto de acordo com a presen\u00e7a de seus par\u00e2metros. As entradas do circuito ser\u00e3o os sinais A , B , C , e a sa\u00edda ser\u00e1 um sinal Z . Para atingir esse objetivo, fa\u00e7a o que se pede nos itens a seguir. Monte uma tabela verdade do sistema com a forma\u00e7\u00e3o A , B , C . (valor: 4,0 pontos) Desenhe o circuito final otimizado utilizando portas l\u00f3gicas. (valor: 6,0 pontos) (extra, n\u00e3o tinha no enade) Implemente a l\u00f3gica encontrada com CIs da fam\u00edlia 74xx","title":"Lab 1: Transistores / CI"},{"location":"A-Transistores-Lab-1-22/#lab-1-transistores-ci","text":"Sugest\u00e3o de como trabalhar Realizar individualmente as simula\u00e7\u00f5es online Realizar em grupo a montagem no protoboard Esse laborat\u00f3rio tem como objetivo trabalhar com os conceitos b\u00e1sicos de portas l\u00f3gicas do tipo RTL realizadas a base de transistores discretos do tipo BJT e tamb\u00e9m trabalhar com componentes integrados (CI) da fam\u00edlia CMOS. Existem basicamente tr\u00eas n\u00edveis de simula\u00e7\u00e3o de componentes eletr\u00f4nicos: a primeira, puramente l\u00f3gica utiliza de portas l\u00f3gicas \"ideais\" ( https://simulator.io/board ). Um simulador mais preciso ir\u00e1 utilizar transistores para a implementa\u00e7\u00e3o dessas portas l\u00f3gicas por\u00e9m n\u00e3o leva em considera\u00e7\u00e3o todos os fatores f\u00edsicos-eletr\u00f4nicos dos componentes ( http://falstad.com/circuit/ ). J\u00e1 um simulador que leva em considera\u00e7\u00e3o as propriedades dos componentes \u00e9 chamado de SPICE e ir\u00e1 gerar uma simula\u00e7\u00e3o mais precisa em termos f\u00edsicos do circuito original ( http://circuitlab.com ). Progress Cheguei Aqui!","title":"Lab 1: Transistores / CI"},{"location":"A-Transistores-Lab-1-22/#parte-1-circuito-misterioso","text":"Vamos usar o simulador do site falstad para implementar um circuito feito com transistores que implementa uma equa\u00e7\u00e3o booleana. Abra o site: http://www.falstad.com/circuit/ Arquivo Importar Arquivo Texto Copiar e colar o texto a seguir $ 1 0.000005 10.20027730826997 52 5 50 5e-11 R 368 64 320 64 0 0 40 6 0 0 0.5 g 368 432 368 496 0 0 t 320 208 368 208 0 1 -5.999999987759469 -1.926578083306543 100 default w 368 160 368 192 0 t 320 256 368 256 0 1 -1.9265780914939181 -1.2199999820401186e-8 100 default w 368 224 368 240 0 w 368 272 368 288 0 w 368 368 368 384 0 r 320 208 240 208 0 2000 r 240 256 320 256 0 2000 L 240 208 208 208 0 0 false 5 0 L 240 256 208 256 0 0 false 5 0 r 368 288 368 368 0 2000 r 368 288 448 288 0 2000 t 448 288 496 288 0 1 -5.999999971546844 1.625315590685889e-8 100 default t 448 368 496 368 0 1 -5.9999999878 -6.362935157139823e-17 100 default w 448 368 320 368 0 r 320 368 224 368 0 2000 w 496 272 496 160 0 w 496 160 368 160 0 w 368 160 368 64 0 w 496 352 544 352 0 w 544 352 544 160 0 w 544 160 496 160 0 w 496 304 576 304 0 w 496 384 576 384 0 w 576 384 576 304 0 r 576 400 576 464 0 1000 w 368 432 368 384 0 g 576 464 576 512 0 0 M 576 384 640 384 0 2.5 L 224 368 208 368 0 0 false 5 0 w 576 400 576 384 0 Voc\u00eas devem obter o seguinte diagrama: Exercise Com o circuito carregado no site, encontre: Encontre a tabela verdade do circuito. Fa\u00e7a todas as combina\u00e7\u00f5es poss\u00edveis de entradas (H/L) e verifique o valor da sa\u00edda (H/L) A partir da tabela verdade encontre a equa\u00e7\u00e3o l\u00f3gica. Desenhar o diagrama da equa\u00e7\u00e3o (simplificado).","title":"Parte 1 - Circuito misterioso"},{"location":"A-Transistores-Lab-1-22/#outro-circuito-misterioso","text":"Implementar o outro circuito feito com transistores que implementa uma equa\u00e7\u00e3o booleana no simulador do site falstad. Abra o site: http://www.falstad.com/circuit/ Arquivo Importar Arquivo Texto Copiar e colar o texto a seguir $ 1 0.000005 10.20027730826997 52 5 50 5e-11 R 368 64 320 64 0 0 40 5 0 0 0.5 L 240 208 208 208 0 0 false 3.6 0 L 240 256 208 256 0 0 false 3.6 0 w 368 192 368 64 0 g 368 528 368 576 0 0 M 576 336 640 336 0 2.5 L 240 304 208 304 0 0 false 5 0 f 240 208 368 208 33 1.5 0.02 w 464 192 464 64 0 w 368 64 464 64 0 f 336 480 368 480 32 1.5 0.02 w 464 224 464 272 0 w 416 272 464 272 0 w 368 224 368 240 0 w 368 240 416 240 0 w 416 240 416 272 0 w 368 384 368 336 0 w 368 336 416 336 0 w 416 304 416 336 0 w 416 336 464 336 0 w 464 336 464 384 0 w 464 336 576 336 0 w 368 416 368 464 0 w 368 496 368 528 0 w 464 416 464 528 0 w 464 528 368 528 0 w 240 304 240 352 0 w 240 352 400 352 0 w 400 352 400 400 0 f 400 400 464 400 32 1.5 0.02 w 336 480 272 480 0 w 272 480 272 256 0 w 272 256 240 256 0 w 272 256 272 144 0 w 272 144 416 144 0 w 416 144 416 208 0 f 416 208 464 208 33 1.5 0.02 f 320 288 416 288 33 1.5 0.02 f 336 400 368 400 32 1.5 0.02 w 336 400 288 400 0 w 288 400 288 224 0 w 288 224 240 224 0 w 240 224 240 208 0 w 320 288 320 304 0 w 320 304 240 304 0 Exercise Assim como no circuito anterior, encontre: Encontre a tabela verdade do circuito. Fa\u00e7a todas as combina\u00e7\u00f5es poss\u00edveis de entradas (H/L) e verifique o valor da sa\u00edda (H/L) A partir da tabela verdade encontre a equa\u00e7\u00e3o l\u00f3gica. Desenhar o diagrama da equa\u00e7\u00e3o (simplificado). Progress Cheguei Aqui!","title":"Outro circuito misterioso"},{"location":"A-Transistores-Lab-1-22/#parte-2-rtl-e-cmos","text":"","title":"Parte 2 - RTL e CMOS"},{"location":"A-Transistores-Lab-1-22/#material","text":"Cada grupo receber\u00e1: 2 protoboards 2 baterias 9V Jumpers macho-macho 10 transistores NPN s9013 10 transistores PNP s9012 20 resistores de 330 2 CIs CD4007 10 LEDs coloridos (Vermelho e amarelo)","title":"Material"},{"location":"A-Transistores-Lab-1-22/#trabalhando","text":"O grupo deve se organizar e executar da melhor forma poss\u00edvel (com todos participando) os m\u00f3dulos a seguir, utilizando: Entradas: Utilizar como entrada do sistema (A,B,C,...) jumpers que estar\u00e3o hora conectados em GND (0) ou VCC (1) . Sa\u00eddas: A sa\u00edda final do sistema deve ser representada com um LED, sendo aceso indicando l\u00f3gica 1 e apagado l\u00f3gica 0 . Valida\u00e7\u00e3o: Uma tabela verdade do circuito deve ser apresentada e em aula demonstrado que o circuito representa a tabela.","title":"Trabalhando"},{"location":"A-Transistores-Lab-1-22/#a-not","text":"Iremos implementar uma porta l\u00f3gica do tipo NOT usando transistores BJT. Warning Se voc\u00ea perceber que algum transistor est\u00e1 aquecendo, desconecte a bateria e verifique novamente a montagem. Isso \u00e9 um sinal que alguma coisa est\u00e1 errada. Tarefa Levante a tabela verdade do circuito rec\u00e9m montado, \u00e9 uma not ? Tip Utilize o datasheet do transistor para entender a montagem Mexa na chave para aplicar 0 ou 1 na entrada do circuito. Solu\u00e7\u00e3o https://www.tinkercad.com/things/5UK9w22fykq-fantastic-vihelmo-lahdi/editel?sharecode=Pf5ZAOJK09Skvm128BIzTAuarSX-nLYnMMrE2YQYe7U Progress Cheguei Aqui! Implemente agora uma porta l\u00f3gica do tipo NOT usando transistores MOS utilizando o CD4007. Progress Cheguei Aqui!","title":"a - NOT"},{"location":"A-Transistores-Lab-1-22/#b-or","text":"Implemente uma porta l\u00f3gica do tipo OR usando transistores BJT. Essa porta ter\u00e1 duas entradas e uma sa\u00edda, cada entrada deve ser uma chave e a sa\u00edda um LED. Tip Utilize a p\u00e1gina a seguir para ter ideias de como implementar as portas l\u00f3gicas em RTL: http://hyperphysics.phy-astr.gsu.edu/hbase/Electronic/trangate.html#c2 Progress Cheguei Aqui!","title":"b - OR"},{"location":"A-Transistores-Lab-1-22/#circuitos-integrados-ci","text":"Circuitos integrados s\u00e3o componentes eletr\u00f4nicos que possuem internamente dezenas a milhares de transistores que implementam circuitos eletr\u00f4nicos, facilitando e possibilitando o desenvolvimento de projetos de hardware mais complexos. Existem v\u00e1rias 'fam\u00edlias' de CI que implementam portas l\u00f3gicas, iremos trabalhar com uma vers\u00e3o chamada de s\u00e9rie TTL 7400 . Exemplos de componentes dessa fam\u00edlias: 7400: Quatro portas NAND de duas entradas 7401: Quatro portas NAND de duas entradas com coletor aberto 7402: Quatro portas NOR de duas entradas 7403: Quatro portas NAND de duas entradas com coletor aberto 7404: Seis inversores (porta NOT) Para a lista completa acesse: https://pt.wikipedia.org/wiki/Lista_dos_circuitos_integrados_da_s%C3%A9rie_7400 Vamos continuar no TinkerCad .","title":"Circuitos Integrados - CI"},{"location":"A-Transistores-Lab-1-22/#a-not_1","text":"Vamos usar o componente 7404 que possui 6 NOTs para fazer a mesma coisa que fizemos com os transistor discreto: 7404 Para mais informa\u00e7\u00f5es, acesse: https://pt.wikipedia.org/wiki/TTL_7404 Solu\u00e7\u00e3o https://www.tinkercad.com/things/kLr9TtHWZiL-dazzling-gogo/editel?sharecode=-_Z8VZQsUBWqvOQtc0codGcJn5mnrZr7-LkwdooNvjM Progress Cheguei Aqui!","title":"a - NOT"},{"location":"A-Transistores-Lab-1-22/#b-equacao","text":"Implemente a equa\u00e7\u00e3o com CIs da fam\u00edlia 74xx utilizando apenas portas nand e nor . Q = (A xor B) or not(C) Tip Identifique os componentes Procure na lista qual o seu nome Analise os pinos desse componente Fa\u00e7a a liga\u00e7\u00e3o e teste por parte Progress Cheguei Aqui!","title":"b - Equa\u00e7\u00e3o"},{"location":"A-Transistores-Lab-1-22/#praticando-no-papel","text":"Quest\u00e3o extra\u00edda do EXAME NACIONAL DE DESEMPENHO DOS ESTUDANTES 2014 Um processo monitora tr\u00eas par\u00e2metros para controle de qualidade: A , B , C . Cada par\u00e2metro possui um valor na decis\u00e3o final da qualidade. A exist\u00eancia do par\u00e2metro A pesa 30% na decis\u00e3o final, enquanto os par\u00e2metros B e C pesam 30% e 40%, respectivamente. O grau de aprova\u00e7\u00e3o do processo \u00e9 dado pela soma dos percentuais desses tr\u00eas par\u00e2metros. O produto gerado pelo processo \u00e9 considerado aprovado, caso o grau de qualidade seja superior ou igual a 60%, e reprovado, se o grau de qualidade for inferior ou igual a 30%. Caso o grau de qualidade esteja entre 30% e 60%, a decis\u00e3o de aprova\u00e7\u00e3o ou reprova\u00e7\u00e3o \u00e9 indiferente. Por exemplo, se um produto apresentar os par\u00e2metros A e B , ter\u00e1 grau de qualidade de 30%+30% = 60%, levando \u00e0 sua aprova\u00e7\u00e3o. Com base na situa\u00e7\u00e3o descrita, projete um circuito l\u00f3gico com o menor n\u00famero poss\u00edvel de portas l\u00f3gicas, para determinar a aprova\u00e7\u00e3o ou n\u00e3o do produto de acordo com a presen\u00e7a de seus par\u00e2metros. As entradas do circuito ser\u00e3o os sinais A , B , C , e a sa\u00edda ser\u00e1 um sinal Z . Para atingir esse objetivo, fa\u00e7a o que se pede nos itens a seguir. Monte uma tabela verdade do sistema com a forma\u00e7\u00e3o A , B , C . (valor: 4,0 pontos) Desenhe o circuito final otimizado utilizando portas l\u00f3gicas. (valor: 6,0 pontos) (extra, n\u00e3o tinha no enade) Implemente a l\u00f3gica encontrada com CIs da fam\u00edlia 74xx","title":"Praticando no papel"},{"location":"A-Transistores-Lab-1/","text":"Lab 3: Transistores / CI \u00b6 Sugest\u00e3o de como trabalhar Realizar individual Ficar online no canal do grupo para discutir e tirar d\u00favidas com os colegas/professores Esse laborat\u00f3rio tem como objetivo trabalhar com os conceitos b\u00e1sicos de portas l\u00f3gicas do tipo RTL realizadas a base de transistores discretos do tipo BJT e tamb\u00e9m trabalhar com componentes integrados (CI) da fam\u00edlia CMOS. Existem basicamente tr\u00eas n\u00edveis de simula\u00e7\u00e3o de componentes eletr\u00f4nicos: a primeira, puramente l\u00f3gica utiliza de portas l\u00f3gicas \"ideais\" ( https://simulator.io/board ). Um simulador mais preciso ir\u00e1 utilizar transistores para a implementa\u00e7\u00e3o dessas portas l\u00f3gicas por\u00e9m n\u00e3o leva em considera\u00e7\u00e3o todos os fatores f\u00edsicos-eletr\u00f4nicos dos componentes ( http://falstad.com/circuit/ ). J\u00e1 um simulador que leva em considera\u00e7\u00e3o as propriedades dos componentes \u00e9 chamado de SPICE e ir\u00e1 gerar uma simula\u00e7\u00e3o mais precisa em termos f\u00edsicos do circuito original ( http://circuitlab.com ). Cheguei Aqui! Parte 1 - Circuito misterioso \u00b6 Vamos usar o simulador do site falstad para implementar um circuito feito com transistores que implementa uma equa\u00e7\u00e3o booleana. Abra o site: http://www.falstad.com/circuit/ Arquivo Importar Arquivo Texto Copiar e colar o texto a seguir $ 1 0.000005 10.20027730826997 52 5 50 5e-11 R 368 64 320 64 0 0 40 6 0 0 0.5 g 368 432 368 496 0 0 t 320 208 368 208 0 1 -5.999999987759469 -1.926578083306543 100 default w 368 160 368 192 0 t 320 256 368 256 0 1 -1.9265780914939181 -1.2199999820401186e-8 100 default w 368 224 368 240 0 w 368 272 368 288 0 w 368 368 368 384 0 r 320 208 240 208 0 2000 r 240 256 320 256 0 2000 L 240 208 208 208 0 0 false 5 0 L 240 256 208 256 0 0 false 5 0 r 368 288 368 368 0 2000 r 368 288 448 288 0 2000 t 448 288 496 288 0 1 -5.999999971546844 1.625315590685889e-8 100 default t 448 368 496 368 0 1 -5.9999999878 -6.362935157139823e-17 100 default w 448 368 320 368 0 r 320 368 224 368 0 2000 w 496 272 496 160 0 w 496 160 368 160 0 w 368 160 368 64 0 w 496 352 544 352 0 w 544 352 544 160 0 w 544 160 496 160 0 w 496 304 576 304 0 w 496 384 576 384 0 w 576 384 576 304 0 r 576 400 576 464 0 1000 w 368 432 368 384 0 g 576 464 576 512 0 0 M 576 384 640 384 0 2.5 L 224 368 208 368 0 0 false 5 0 w 576 400 576 384 0 Voc\u00eas devem obter o seguinte diagrama: Com o circuito carreado no site, encontre: Tarefa Encontre a tabela verdade do circuito. Fa\u00e7a todas as combina\u00e7\u00f5es poss\u00edveis de entradas (H/L) e verifique o valor da sa\u00edda (H/L) A partir da tabela verdade encontre a equa\u00e7\u00e3o l\u00f3gica. Desenhar o diagrama da equa\u00e7\u00e3o (simplificado). Outro circuito misterioso \u00b6 Implementar o outro circuito feito com transistores que implementa uma equa\u00e7\u00e3o booleana no simulador do site falstad. Abra o site: http://www.falstad.com/circuit/ Arquivo Importar Arquivo Texto Copiar e colar o texto a seguir $ 1 0.000005 10.20027730826997 52 5 50 5e-11 R 368 64 320 64 0 0 40 5 0 0 0.5 L 240 208 208 208 0 0 false 3.6 0 L 240 256 208 256 0 0 false 3.6 0 w 368 192 368 64 0 g 368 528 368 576 0 0 M 576 336 640 336 0 2.5 L 240 304 208 304 0 0 false 5 0 f 240 208 368 208 33 1.5 0.02 w 464 192 464 64 0 w 368 64 464 64 0 f 336 480 368 480 32 1.5 0.02 w 464 224 464 272 0 w 416 272 464 272 0 w 368 224 368 240 0 w 368 240 416 240 0 w 416 240 416 272 0 w 368 384 368 336 0 w 368 336 416 336 0 w 416 304 416 336 0 w 416 336 464 336 0 w 464 336 464 384 0 w 464 336 576 336 0 w 368 416 368 464 0 w 368 496 368 528 0 w 464 416 464 528 0 w 464 528 368 528 0 w 240 304 240 352 0 w 240 352 400 352 0 w 400 352 400 400 0 f 400 400 464 400 32 1.5 0.02 w 336 480 272 480 0 w 272 480 272 256 0 w 272 256 240 256 0 w 272 256 272 144 0 w 272 144 416 144 0 w 416 144 416 208 0 f 416 208 464 208 33 1.5 0.02 f 320 288 416 288 33 1.5 0.02 f 336 400 368 400 32 1.5 0.02 w 336 400 288 400 0 w 288 400 288 224 0 w 288 224 240 224 0 w 240 224 240 208 0 w 320 288 320 304 0 w 320 304 240 304 0 Assim como no circuito anterior, encontre: Tarefa Encontre a tabela verdade do circuito. Fa\u00e7a todas as combina\u00e7\u00f5es poss\u00edveis de entradas (H/L) e verifique o valor da sa\u00edda (H/L) A partir da tabela verdade encontre a equa\u00e7\u00e3o l\u00f3gica. Desenhar o diagrama da equa\u00e7\u00e3o (simplificado). Cheguei Aqui! Parte 2 - RTL \u00b6 Modo online Esta atividade seria realizada no laborat\u00f3rio com hardware real, quando come\u00e7armos ter encontros presenciais podemos realizar o experimento de forma real. Iremos implementar portas l\u00f3gicas e equa\u00e7\u00f5es booleanas com transistores BJT. Para isso vamos utilizar o TinkerCad , que ir\u00e1 permitir realizarmos uma montagem similar a que seria feito no laborat\u00f3rio. a - NOT \u00b6 Iremos implementar uma porta l\u00f3gica do tipo NOT usando transistores BJT. Para isso voc\u00eas dever\u00e3o: Entrar no site TinkerCad Logar (com google) e criar conta pessoal Circuis Criar novo Circuito Fazer a implementa\u00e7\u00e3o a seguir Tarefa Levante a tabela verdade do circuito rec\u00e9m montado, \u00e9 uma not ? Tip Utilize o datasheet do transistor para entender a montagem Mexa na chave para aplicar 0 ou 1 na entrada do circuito. Solu\u00e7\u00e3o https://www.tinkercad.com/things/bnWLvsuRvp6-neat-lappi-snicket/editel?sharecode=QlWtWTyxH18eCaVwphNPVTpzdXW9IlssdNUmgLUOtAU Cheguei Aqui! b - OR \u00b6 Implemente uma porta l\u00f3gica do tipo OR usando transistores BJT. Essa porta ter\u00e1 duas entradas e uma sa\u00edda, cada entrada deve ser uma chave e a sa\u00edda um LED. Tip Utilize a p\u00e1gina a seguir para ter ideias de como implementar as portas l\u00f3gicas em RTL: http://hyperphysics.phy-astr.gsu.edu/hbase/Electronic/trangate.html#c2 Cheguei Aqui! c - Equa\u00e7\u00e3o \u00b6 Implemente a equa\u00e7\u00e3o l\u00f3gica a seguir em um circuito do tipo RTL. Q = A.(A.(A+B)+A.C) Tarefa Implemente a equa\u00e7\u00e3o no TinkerCad Para validar valide com tabela verdade do circuito As duas tabelas precisam ser id\u00eanticas! Tip Da para simplificar? Antes de montar, fa\u00e7a o diagrama de blocos! Cheguei Aqui! Circuitos Integrados - CI \u00b6 Circuitos integrados s\u00e3o componentes eletr\u00f4nicos que possuem internamente dezenas a milhares de transistores que implementam circuitos eletr\u00f4nicos, facilitando e possibilitando o desenvolvimento de projetos de hardware mais complexos. Existem v\u00e1rias 'fam\u00edlias' de CI que implementam portas l\u00f3gicas, iremos trabalhar com uma vers\u00e3o chamada de s\u00e9rie TTL 7400 . Exemplos de componentes dessa fam\u00edlias: 7400: Quatro portas NAND de duas entradas 7401: Quatro portas NAND de duas entradas com coletor aberto 7402: Quatro portas NOR de duas entradas 7403: Quatro portas NAND de duas entradas com coletor aberto 7404: Seis inversores (porta NOT) Para a lista completa acesse: https://pt.wikipedia.org/wiki/Lista_dos_circuitos_integrados_da_s%C3%A9rie_7400 Vamos continuar no TinkerCad . a - NOT \u00b6 Vamos usar o componente 7404 que possui 6 NOTs para fazer a mesma coisa que fizemos com os transistor discreto: 7404 Para mais informa\u00e7\u00f5es, acesse: https://pt.wikipedia.org/wiki/TTL_7404 Solu\u00e7\u00e3o https://www.tinkercad.com/things/5didIR3U6qY-sizzling-jaban-jarv/editel?tenant=circuits?sharecode=2N6uVn_CZekje82phPIUcZu_24lOLu1_oeEenH-htT8 Cheguei Aqui! b - Equa\u00e7\u00e3o \u00b6 Implemente a equa\u00e7\u00e3o que foi realizada com transistores s\u00f3 que agora com CIs da fam\u00edlia 74xx. Q = (A xor B) or not(C) Tip Identifique os componentes Procure na lista qual o seu nome Analise os pinos desse componente Fa\u00e7a a liga\u00e7\u00e3o e teste por parte Cheguei Aqui! Praticando no papel \u00b6 Quest\u00e3o extraida do EXAME NACIONAL DE DESEMPENHO DOS ESTUDANTES 2014 Um processo monitora tr\u00eas par\u00e2metros para controle de qualidade: A , B , C . Cada par\u00e2metro possui um valor na decis\u00e3o final da qualidade. A exist\u00eancia do par\u00e2metro A pesa 30% na decis\u00e3o final, enquanto os par\u00e2metros B e C pesam 30% e 40%, respectivamente. O grau de aprova\u00e7\u00e3o do processo \u00e9 dado pela soma dos percentuais desses tr\u00eas par\u00e2metros. O produto gerado pelo processo \u00e9 considerado aprovado, caso o grau de qualidade seja superior ou igual a 60%, e reprovado, se o grau de qualidade for inferior ou igual a 30%. Caso o grau de qualidade esteja entre 30% e 60%, a decis\u00e3o de aprova\u00e7\u00e3o ou reprova\u00e7\u00e3o \u00e9 indiferente. Por exemplo, se um produto apresentar os par\u00e2metros A e B , ter\u00e1 grau de qualidade de 30%+30% = 60%, levando \u00e0 sua aprova\u00e7\u00e3o. Com base na situa\u00e7\u00e3o descrita, projete um circuito l\u00f3gico com o menor n\u00famero poss\u00edvel de portas l\u00f3gicas, para determinar a aprova\u00e7\u00e3o ou n\u00e3o do produto de acordo com a presen\u00e7a de seus par\u00e2metros. As entradas do circuito ser\u00e3o os sinais A , B , C , e a sa\u00edda ser\u00e1 um sinal Z . Para atingir esse objetivo, fa\u00e7a o que se pede nos itens a seguir. Monte uma tabela verdade do sistema com a forma\u00e7\u00e3o A , B , C . (valor: 4,0 pontos) Desenhe o circuito final otimizado utilizando portas l\u00f3gicas. (valor: 6,0 pontos) (extra, n\u00e3o tinha no enade) Implemente a l\u00f3gica encontrada com CIs da fam\u00edlia 74xx Cheguei Aqui!","title":"Lab 3: Transistores / CI"},{"location":"A-Transistores-Lab-1/#lab-3-transistores-ci","text":"Sugest\u00e3o de como trabalhar Realizar individual Ficar online no canal do grupo para discutir e tirar d\u00favidas com os colegas/professores Esse laborat\u00f3rio tem como objetivo trabalhar com os conceitos b\u00e1sicos de portas l\u00f3gicas do tipo RTL realizadas a base de transistores discretos do tipo BJT e tamb\u00e9m trabalhar com componentes integrados (CI) da fam\u00edlia CMOS. Existem basicamente tr\u00eas n\u00edveis de simula\u00e7\u00e3o de componentes eletr\u00f4nicos: a primeira, puramente l\u00f3gica utiliza de portas l\u00f3gicas \"ideais\" ( https://simulator.io/board ). Um simulador mais preciso ir\u00e1 utilizar transistores para a implementa\u00e7\u00e3o dessas portas l\u00f3gicas por\u00e9m n\u00e3o leva em considera\u00e7\u00e3o todos os fatores f\u00edsicos-eletr\u00f4nicos dos componentes ( http://falstad.com/circuit/ ). J\u00e1 um simulador que leva em considera\u00e7\u00e3o as propriedades dos componentes \u00e9 chamado de SPICE e ir\u00e1 gerar uma simula\u00e7\u00e3o mais precisa em termos f\u00edsicos do circuito original ( http://circuitlab.com ). Cheguei Aqui!","title":"Lab 3: Transistores / CI"},{"location":"A-Transistores-Lab-1/#parte-1-circuito-misterioso","text":"Vamos usar o simulador do site falstad para implementar um circuito feito com transistores que implementa uma equa\u00e7\u00e3o booleana. Abra o site: http://www.falstad.com/circuit/ Arquivo Importar Arquivo Texto Copiar e colar o texto a seguir $ 1 0.000005 10.20027730826997 52 5 50 5e-11 R 368 64 320 64 0 0 40 6 0 0 0.5 g 368 432 368 496 0 0 t 320 208 368 208 0 1 -5.999999987759469 -1.926578083306543 100 default w 368 160 368 192 0 t 320 256 368 256 0 1 -1.9265780914939181 -1.2199999820401186e-8 100 default w 368 224 368 240 0 w 368 272 368 288 0 w 368 368 368 384 0 r 320 208 240 208 0 2000 r 240 256 320 256 0 2000 L 240 208 208 208 0 0 false 5 0 L 240 256 208 256 0 0 false 5 0 r 368 288 368 368 0 2000 r 368 288 448 288 0 2000 t 448 288 496 288 0 1 -5.999999971546844 1.625315590685889e-8 100 default t 448 368 496 368 0 1 -5.9999999878 -6.362935157139823e-17 100 default w 448 368 320 368 0 r 320 368 224 368 0 2000 w 496 272 496 160 0 w 496 160 368 160 0 w 368 160 368 64 0 w 496 352 544 352 0 w 544 352 544 160 0 w 544 160 496 160 0 w 496 304 576 304 0 w 496 384 576 384 0 w 576 384 576 304 0 r 576 400 576 464 0 1000 w 368 432 368 384 0 g 576 464 576 512 0 0 M 576 384 640 384 0 2.5 L 224 368 208 368 0 0 false 5 0 w 576 400 576 384 0 Voc\u00eas devem obter o seguinte diagrama: Com o circuito carreado no site, encontre: Tarefa Encontre a tabela verdade do circuito. Fa\u00e7a todas as combina\u00e7\u00f5es poss\u00edveis de entradas (H/L) e verifique o valor da sa\u00edda (H/L) A partir da tabela verdade encontre a equa\u00e7\u00e3o l\u00f3gica. Desenhar o diagrama da equa\u00e7\u00e3o (simplificado).","title":"Parte 1 - Circuito misterioso"},{"location":"A-Transistores-Lab-1/#outro-circuito-misterioso","text":"Implementar o outro circuito feito com transistores que implementa uma equa\u00e7\u00e3o booleana no simulador do site falstad. Abra o site: http://www.falstad.com/circuit/ Arquivo Importar Arquivo Texto Copiar e colar o texto a seguir $ 1 0.000005 10.20027730826997 52 5 50 5e-11 R 368 64 320 64 0 0 40 5 0 0 0.5 L 240 208 208 208 0 0 false 3.6 0 L 240 256 208 256 0 0 false 3.6 0 w 368 192 368 64 0 g 368 528 368 576 0 0 M 576 336 640 336 0 2.5 L 240 304 208 304 0 0 false 5 0 f 240 208 368 208 33 1.5 0.02 w 464 192 464 64 0 w 368 64 464 64 0 f 336 480 368 480 32 1.5 0.02 w 464 224 464 272 0 w 416 272 464 272 0 w 368 224 368 240 0 w 368 240 416 240 0 w 416 240 416 272 0 w 368 384 368 336 0 w 368 336 416 336 0 w 416 304 416 336 0 w 416 336 464 336 0 w 464 336 464 384 0 w 464 336 576 336 0 w 368 416 368 464 0 w 368 496 368 528 0 w 464 416 464 528 0 w 464 528 368 528 0 w 240 304 240 352 0 w 240 352 400 352 0 w 400 352 400 400 0 f 400 400 464 400 32 1.5 0.02 w 336 480 272 480 0 w 272 480 272 256 0 w 272 256 240 256 0 w 272 256 272 144 0 w 272 144 416 144 0 w 416 144 416 208 0 f 416 208 464 208 33 1.5 0.02 f 320 288 416 288 33 1.5 0.02 f 336 400 368 400 32 1.5 0.02 w 336 400 288 400 0 w 288 400 288 224 0 w 288 224 240 224 0 w 240 224 240 208 0 w 320 288 320 304 0 w 320 304 240 304 0 Assim como no circuito anterior, encontre: Tarefa Encontre a tabela verdade do circuito. Fa\u00e7a todas as combina\u00e7\u00f5es poss\u00edveis de entradas (H/L) e verifique o valor da sa\u00edda (H/L) A partir da tabela verdade encontre a equa\u00e7\u00e3o l\u00f3gica. Desenhar o diagrama da equa\u00e7\u00e3o (simplificado). Cheguei Aqui!","title":"Outro circuito misterioso"},{"location":"A-Transistores-Lab-1/#parte-2-rtl","text":"Modo online Esta atividade seria realizada no laborat\u00f3rio com hardware real, quando come\u00e7armos ter encontros presenciais podemos realizar o experimento de forma real. Iremos implementar portas l\u00f3gicas e equa\u00e7\u00f5es booleanas com transistores BJT. Para isso vamos utilizar o TinkerCad , que ir\u00e1 permitir realizarmos uma montagem similar a que seria feito no laborat\u00f3rio.","title":"Parte 2 - RTL"},{"location":"A-Transistores-Lab-1/#a-not","text":"Iremos implementar uma porta l\u00f3gica do tipo NOT usando transistores BJT. Para isso voc\u00eas dever\u00e3o: Entrar no site TinkerCad Logar (com google) e criar conta pessoal Circuis Criar novo Circuito Fazer a implementa\u00e7\u00e3o a seguir Tarefa Levante a tabela verdade do circuito rec\u00e9m montado, \u00e9 uma not ? Tip Utilize o datasheet do transistor para entender a montagem Mexa na chave para aplicar 0 ou 1 na entrada do circuito. Solu\u00e7\u00e3o https://www.tinkercad.com/things/bnWLvsuRvp6-neat-lappi-snicket/editel?sharecode=QlWtWTyxH18eCaVwphNPVTpzdXW9IlssdNUmgLUOtAU Cheguei Aqui!","title":"a - NOT"},{"location":"A-Transistores-Lab-1/#b-or","text":"Implemente uma porta l\u00f3gica do tipo OR usando transistores BJT. Essa porta ter\u00e1 duas entradas e uma sa\u00edda, cada entrada deve ser uma chave e a sa\u00edda um LED. Tip Utilize a p\u00e1gina a seguir para ter ideias de como implementar as portas l\u00f3gicas em RTL: http://hyperphysics.phy-astr.gsu.edu/hbase/Electronic/trangate.html#c2 Cheguei Aqui!","title":"b - OR"},{"location":"A-Transistores-Lab-1/#c-equacao","text":"Implemente a equa\u00e7\u00e3o l\u00f3gica a seguir em um circuito do tipo RTL. Q = A.(A.(A+B)+A.C) Tarefa Implemente a equa\u00e7\u00e3o no TinkerCad Para validar valide com tabela verdade do circuito As duas tabelas precisam ser id\u00eanticas! Tip Da para simplificar? Antes de montar, fa\u00e7a o diagrama de blocos! Cheguei Aqui!","title":"c - Equa\u00e7\u00e3o"},{"location":"A-Transistores-Lab-1/#circuitos-integrados-ci","text":"Circuitos integrados s\u00e3o componentes eletr\u00f4nicos que possuem internamente dezenas a milhares de transistores que implementam circuitos eletr\u00f4nicos, facilitando e possibilitando o desenvolvimento de projetos de hardware mais complexos. Existem v\u00e1rias 'fam\u00edlias' de CI que implementam portas l\u00f3gicas, iremos trabalhar com uma vers\u00e3o chamada de s\u00e9rie TTL 7400 . Exemplos de componentes dessa fam\u00edlias: 7400: Quatro portas NAND de duas entradas 7401: Quatro portas NAND de duas entradas com coletor aberto 7402: Quatro portas NOR de duas entradas 7403: Quatro portas NAND de duas entradas com coletor aberto 7404: Seis inversores (porta NOT) Para a lista completa acesse: https://pt.wikipedia.org/wiki/Lista_dos_circuitos_integrados_da_s%C3%A9rie_7400 Vamos continuar no TinkerCad .","title":"Circuitos Integrados - CI"},{"location":"A-Transistores-Lab-1/#a-not_1","text":"Vamos usar o componente 7404 que possui 6 NOTs para fazer a mesma coisa que fizemos com os transistor discreto: 7404 Para mais informa\u00e7\u00f5es, acesse: https://pt.wikipedia.org/wiki/TTL_7404 Solu\u00e7\u00e3o https://www.tinkercad.com/things/5didIR3U6qY-sizzling-jaban-jarv/editel?tenant=circuits?sharecode=2N6uVn_CZekje82phPIUcZu_24lOLu1_oeEenH-htT8 Cheguei Aqui!","title":"a - NOT"},{"location":"A-Transistores-Lab-1/#b-equacao","text":"Implemente a equa\u00e7\u00e3o que foi realizada com transistores s\u00f3 que agora com CIs da fam\u00edlia 74xx. Q = (A xor B) or not(C) Tip Identifique os componentes Procure na lista qual o seu nome Analise os pinos desse componente Fa\u00e7a a liga\u00e7\u00e3o e teste por parte Cheguei Aqui!","title":"b - Equa\u00e7\u00e3o"},{"location":"A-Transistores-Lab-1/#praticando-no-papel","text":"Quest\u00e3o extraida do EXAME NACIONAL DE DESEMPENHO DOS ESTUDANTES 2014 Um processo monitora tr\u00eas par\u00e2metros para controle de qualidade: A , B , C . Cada par\u00e2metro possui um valor na decis\u00e3o final da qualidade. A exist\u00eancia do par\u00e2metro A pesa 30% na decis\u00e3o final, enquanto os par\u00e2metros B e C pesam 30% e 40%, respectivamente. O grau de aprova\u00e7\u00e3o do processo \u00e9 dado pela soma dos percentuais desses tr\u00eas par\u00e2metros. O produto gerado pelo processo \u00e9 considerado aprovado, caso o grau de qualidade seja superior ou igual a 60%, e reprovado, se o grau de qualidade for inferior ou igual a 30%. Caso o grau de qualidade esteja entre 30% e 60%, a decis\u00e3o de aprova\u00e7\u00e3o ou reprova\u00e7\u00e3o \u00e9 indiferente. Por exemplo, se um produto apresentar os par\u00e2metros A e B , ter\u00e1 grau de qualidade de 30%+30% = 60%, levando \u00e0 sua aprova\u00e7\u00e3o. Com base na situa\u00e7\u00e3o descrita, projete um circuito l\u00f3gico com o menor n\u00famero poss\u00edvel de portas l\u00f3gicas, para determinar a aprova\u00e7\u00e3o ou n\u00e3o do produto de acordo com a presen\u00e7a de seus par\u00e2metros. As entradas do circuito ser\u00e3o os sinais A , B , C , e a sa\u00edda ser\u00e1 um sinal Z . Para atingir esse objetivo, fa\u00e7a o que se pede nos itens a seguir. Monte uma tabela verdade do sistema com a forma\u00e7\u00e3o A , B , C . (valor: 4,0 pontos) Desenhe o circuito final otimizado utilizando portas l\u00f3gicas. (valor: 6,0 pontos) (extra, n\u00e3o tinha no enade) Implemente a l\u00f3gica encontrada com CIs da fam\u00edlia 74xx Cheguei Aqui!","title":"Praticando no papel"},{"location":"Atendimento/","text":"Atendimento \u00b6 2020-2 Material atualizado. Os atendimentos de aula (individual ou de grupo) ser\u00e3o resolvidos no canal do seu grupo, em atendimento as d\u00favidas ser\u00e3o tiradas no canal #Geral . Tip Para acompanhar a evolu\u00e7\u00e3o da lista, siga a tabela a seguir: https://docs.google.com/spreadsheets/d/1T8uqZYfmtfd_NQX9Kwq2wueDL1AvrPS7wIMqwFo9GUU/edit?usp=sharing Warning Toda a d\u00favida deve ser registrada nesse forms Loading\u2026","title":"Atendimento"},{"location":"Atendimento/#atendimento","text":"2020-2 Material atualizado. Os atendimentos de aula (individual ou de grupo) ser\u00e3o resolvidos no canal do seu grupo, em atendimento as d\u00favidas ser\u00e3o tiradas no canal #Geral . Tip Para acompanhar a evolu\u00e7\u00e3o da lista, siga a tabela a seguir: https://docs.google.com/spreadsheets/d/1T8uqZYfmtfd_NQX9Kwq2wueDL1AvrPS7wIMqwFo9GUU/edit?usp=sharing Warning Toda a d\u00favida deve ser registrada nesse forms Loading\u2026","title":"Atendimento"},{"location":"Avaliacoes/","text":"Avalia\u00e7\u00f5es \u00b6 Informa\u00e7\u00f5es sobre as avalia\u00e7\u00f5es (e simulados) da disciplina: AV1 - sexta 12/3 \u00b6 Avalia\u00e7\u00e3o ser\u00e1 realizado no blackboard, com proctorio e sem consulta. Aulas: 1, 2, 3 e 4 Conte\u00fados: Organiza\u00e7\u00e3o de Computadores (vis\u00e3o geral) \u00c1lgebra booleana Portas l\u00f3gicas Tabela Verdade Soma dos produtos / Produto das somas Simplifica\u00e7\u00e3o via equa\u00e7\u00e3o alg\u00e9brica Simplifica\u00e7\u00e3o via mapa de Karnaught Equa\u00e7\u00e3o via circuito Circuito via equa\u00e7\u00e3o Transistores Portas l\u00f3gicas: not, and, or Dados digitais Bin\u00e1rio, Hexadecimal ASCII, BCD Convers\u00e3o bin -- hex -- dec","title":"Avalia\u00e7\u00f5es"},{"location":"Avaliacoes/#avaliacoes","text":"Informa\u00e7\u00f5es sobre as avalia\u00e7\u00f5es (e simulados) da disciplina:","title":"Avalia\u00e7\u00f5es"},{"location":"Avaliacoes/#av1-sexta-123","text":"Avalia\u00e7\u00e3o ser\u00e1 realizado no blackboard, com proctorio e sem consulta. Aulas: 1, 2, 3 e 4 Conte\u00fados: Organiza\u00e7\u00e3o de Computadores (vis\u00e3o geral) \u00c1lgebra booleana Portas l\u00f3gicas Tabela Verdade Soma dos produtos / Produto das somas Simplifica\u00e7\u00e3o via equa\u00e7\u00e3o alg\u00e9brica Simplifica\u00e7\u00e3o via mapa de Karnaught Equa\u00e7\u00e3o via circuito Circuito via equa\u00e7\u00e3o Transistores Portas l\u00f3gicas: not, and, or Dados digitais Bin\u00e1rio, Hexadecimal ASCII, BCD Convers\u00e3o bin -- hex -- dec","title":"AV1 - sexta 12/3"},{"location":"Criando-VM-com-HD-Externo-boot%C3%A1vel-no-VirtualBox-%28Mac-OS%29/","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Mac OS Mojave (mas com o devido cuidado funciona no Windows e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive ou instalador montado (mostrando como unidade), se sim, ejete eles no Finder. Conecte o HD Externo de tipo A (MBR) no Mac OS, neste momento dever\u00e1 aparecer uma mensagem dizendo que o Mac OS n\u00e3o \u00e9 capaz de ler o disco, aten\u00e7\u00e3o, voc\u00ea deve clicar no bot\u00e3o 'Ignorar' Agora, abra o Disk Utility (Utilit\u00e1rio de Disco), ele pode ser encontrado pelo Spotlight ou pelo Launchpad, conforme imagem. Clique no bot\u00e3o Visualizar e selecione Mostrar todos os dispositivos . Agora no menu lateral, voc\u00ea deve ser capaz de ver o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Selecione o HD Externo no Disk Utility e nas informa\u00e7\u00f5es exibidas procure por Dispositivo: diskN , sendo que haver\u00e1 um n\u00famero no lugar do N, no caso da foto \u00e9 disk2 . Verifique qual o n\u00famero em seu Mac OS. Agora, abra um Terminal. E execute o seguinte comando, substituindo o diskN pelo disco corresponde visto anteriormente (deve-se manter o /dev/ inicial). Ele ir\u00e1 solicitar a sua senha do Mac OS, por favor digite. sudo VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk /dev/diskN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Mac OS. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Em seguida, no terminal novamente, digite o comando sudo /Applications/VirtualBox.app/Contents/MacOS/VirtualBox Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert , de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para /Users/SEU_USUARIO/VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Criando VM com HD Externo boot\u00e1vel no VirtualBox (Mac OS)"},{"location":"Exercicio-Algebra-Booleana-1/","text":"\u00c1lgebra Booleana - 1 \u00b6 Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Exercise Indique o nome dos elementos l\u00f3gicos a seguir: Answer and, nand, or, nor, xor, not Tabela verdade \u00b6 Exercise A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 0 0 1 1 1 0 1 1 1 0 Answer xor Exercise A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 1 0 1 1 1 0 1 1 1 0 Answer nand Pergunta Aplicando a lei da Distributividade na express\u00e3o \\(A(B+\\bar{C}+D)\\) se tem: \\(A . B + A . C + A . D\\) \\(A . B . C . D\\) \\(A + B + C + D\\) \\(A B + A\\bar{C} + A . D\\) Answer \\(A B + A\\bar{C} + A . D\\) Pergunta Aplicando o teorema de DeMorgan na express\u00e3o \\(\\overline{ABC}\\) , obt\u00e9m: \\(\\bar{A}+\\bar{B}+\\bar{C}\\) \\(\\overline{A+B+C}\\) \\(A + \\bar{B} + C \\bar{C}\\) \\(A . (B+C)\\) Answer \\(\\bar{A}+\\bar{B}+\\bar{C}\\) Pergunta Qual simplifica\u00e7\u00e3o est\u00e1 incorreta: \\(\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y}\\) \\(x ( \\bar{x} + y ) = x . \\bar{x} + x . y = 0 + x . y = x . y\\) \\(x . y + x ( y + z ) = x . y + x . y + z = x . y + z\\) \\(\\bar{x} . \\bar{y} . z + \\bar{x} . y . z + x . \\bar{y} = \\bar{x} . z (\\bar{y} + y) + x . \\bar{y} = \\bar{x} . z + x . \\bar{y}\\) Answer \\(\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y}\\) e \\(x . y + x ( y + z ) = x . y + x . y + z = x . y + z\\) Pergunta Qual forma can\u00f4nica est\u00e1 correta? A B Q 0 0 1 0 1 0 1 0 0 1 1 1 \\(Q = A \\bar{B} + A \\bar{B}\\) \\(Q = A+B * \\bar{A} \\bar{B}\\) \\(Q = A . B\\) \\(Q = \\bar{A} . \\bar{B} + A . B\\) Answer \\(Q = \\bar{A} . \\bar{B} + A . B\\) Exercise Dado a seguinte tabela verdade (entradas A, B e C, e a sa\u00edda Q): A B C Q 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 Crie uma f\u00f3rmula em \u00e1lgebra booleana que represente a tabela via SoP e PoS. SoP: Soma dos Produtos / PoS: Produto das Somas Simplifique SoP (interprete o resultado!) Desenhe um circuito usando os s\u00edmbolos da \u00e1lgebra booleana. Exercise Quantas sa\u00eddas com 1 existem na tabela verdade que resulta na seguinte f\u00f3rmula de soma de produtos: \\(A \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B C\\) Answer 4 Exercise Qual \u00e9 a express\u00e3o em \u00e1lgebra booleana do seguinte circuito: Answer \\(G = (A+B) C D E\\) Exercise Gere a Tabela Verdade das equa\u00e7\u00f5es a seguir: \\(A . B + \\overline{B + A}\\) \\(A \\oplus B\\) \\((A \\, and \\, B) \\, or \\, C\\) Exercise Converta a seguinte express\u00e3o em Soma de Produtos para Produto de Somas: \\(A . B . C + A \\bar{B} \\bar{C} + A . \\bar{B} C + A . B . \\bar{C} + \\bar{A} . \\bar{B} . C\\) Fa\u00e7a a tabela verdade Encontre o PoS Exercise Determine os valores de A, B, C e D que fazem a f\u00f3rmula a seguir ser igual a zero (Z = 0). \\(Z = \\bar{A} + B + \\bar{C} + D\\) Answer \"1010\" Pergunta Qual das seguintes propriedades da \u00e1lgebra booleana \u00e9 falsa: \\(A . (\\bar{A} + B)= A . B\\) \\(A + (\\bar{A} . B) = A\\) \\(A + \\bar{A} = 1\\) \\(A . A = A\\) Answer \\(A + (\\bar{A} . B) = A\\) Exercise Simplifique a seguinte express\u00e3o: \\(\\bar{A} \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B \\bar{C}\\) Answer \\(\\bar{C} + \\bar{A} B C\\) Exercise Encontre as equa\u00e7\u00f5es para os mapas de Karnaugh a seguir: Exercise Crie o mapa de Karnaugh e encontre a equa\u00e7\u00e3o da tabela verdade a seguir. A B C OUT 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 0 Exercise Crie o mapa de Karnaugh da tabela verdade de quatro entradas. A B C D OUT 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 1 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1 Exercise Crie o mapa de Karnaugh para a express\u00e3o a seguir e simplifique: \\(ABC\\bar{D} + \\bar{A}\\bar{B}CD + A \\bar{B}\\bar{C}D + \\bar{A} + \\bar{B} + \\bar{C} + \\bar{D}\\) Exercise A seguinte express\u00e3o foi resultado da forma can\u00f4nica do produto de somas de uma tabela verdade para a produ\u00e7\u00e3o de um circuito l\u00f3gico. O objetivo \u00e9 simplificar a \u00e1lgebra booleana dessa l\u00f3gica para o menor n\u00famero poss\u00edvel de portas, por\u00e9m visivelmente quem fez essa f\u00f3rmula n\u00e3o percebeu que se tivesse feito a soma de produtos j\u00e1 partiria com um n\u00famero menor de termos. Converta essa f\u00f3rmula para a soma de produtos e minimize-a. \\((A+B+C)(A+B+\\bar{C})(A+\\bar{B}+C)(\\bar{A}+B+C)(\\bar{A}+\\bar{B}+C)\\) dica: Equa\u00e7\u00e3o -> tabela verdade -> soma dos produtos Acabou? Os exerc\u00edcios n\u00e3o param por aqui, tem a parte 2!","title":"\u00c1lgebra Booleana - 1"},{"location":"Exercicio-Algebra-Booleana-1/#algebra-booleana-1","text":"Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Exercise Indique o nome dos elementos l\u00f3gicos a seguir: Answer and, nand, or, nor, xor, not","title":"\u00c1lgebra Booleana - 1"},{"location":"Exercicio-Algebra-Booleana-1/#tabela-verdade","text":"Exercise A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 0 0 1 1 1 0 1 1 1 0 Answer xor Exercise A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 1 0 1 1 1 0 1 1 1 0 Answer nand Pergunta Aplicando a lei da Distributividade na express\u00e3o \\(A(B+\\bar{C}+D)\\) se tem: \\(A . B + A . C + A . D\\) \\(A . B . C . D\\) \\(A + B + C + D\\) \\(A B + A\\bar{C} + A . D\\) Answer \\(A B + A\\bar{C} + A . D\\) Pergunta Aplicando o teorema de DeMorgan na express\u00e3o \\(\\overline{ABC}\\) , obt\u00e9m: \\(\\bar{A}+\\bar{B}+\\bar{C}\\) \\(\\overline{A+B+C}\\) \\(A + \\bar{B} + C \\bar{C}\\) \\(A . (B+C)\\) Answer \\(\\bar{A}+\\bar{B}+\\bar{C}\\) Pergunta Qual simplifica\u00e7\u00e3o est\u00e1 incorreta: \\(\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y}\\) \\(x ( \\bar{x} + y ) = x . \\bar{x} + x . y = 0 + x . y = x . y\\) \\(x . y + x ( y + z ) = x . y + x . y + z = x . y + z\\) \\(\\bar{x} . \\bar{y} . z + \\bar{x} . y . z + x . \\bar{y} = \\bar{x} . z (\\bar{y} + y) + x . \\bar{y} = \\bar{x} . z + x . \\bar{y}\\) Answer \\(\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y}\\) e \\(x . y + x ( y + z ) = x . y + x . y + z = x . y + z\\) Pergunta Qual forma can\u00f4nica est\u00e1 correta? A B Q 0 0 1 0 1 0 1 0 0 1 1 1 \\(Q = A \\bar{B} + A \\bar{B}\\) \\(Q = A+B * \\bar{A} \\bar{B}\\) \\(Q = A . B\\) \\(Q = \\bar{A} . \\bar{B} + A . B\\) Answer \\(Q = \\bar{A} . \\bar{B} + A . B\\) Exercise Dado a seguinte tabela verdade (entradas A, B e C, e a sa\u00edda Q): A B C Q 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 Crie uma f\u00f3rmula em \u00e1lgebra booleana que represente a tabela via SoP e PoS. SoP: Soma dos Produtos / PoS: Produto das Somas Simplifique SoP (interprete o resultado!) Desenhe um circuito usando os s\u00edmbolos da \u00e1lgebra booleana. Exercise Quantas sa\u00eddas com 1 existem na tabela verdade que resulta na seguinte f\u00f3rmula de soma de produtos: \\(A \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B C\\) Answer 4 Exercise Qual \u00e9 a express\u00e3o em \u00e1lgebra booleana do seguinte circuito: Answer \\(G = (A+B) C D E\\) Exercise Gere a Tabela Verdade das equa\u00e7\u00f5es a seguir: \\(A . B + \\overline{B + A}\\) \\(A \\oplus B\\) \\((A \\, and \\, B) \\, or \\, C\\) Exercise Converta a seguinte express\u00e3o em Soma de Produtos para Produto de Somas: \\(A . B . C + A \\bar{B} \\bar{C} + A . \\bar{B} C + A . B . \\bar{C} + \\bar{A} . \\bar{B} . C\\) Fa\u00e7a a tabela verdade Encontre o PoS Exercise Determine os valores de A, B, C e D que fazem a f\u00f3rmula a seguir ser igual a zero (Z = 0). \\(Z = \\bar{A} + B + \\bar{C} + D\\) Answer \"1010\" Pergunta Qual das seguintes propriedades da \u00e1lgebra booleana \u00e9 falsa: \\(A . (\\bar{A} + B)= A . B\\) \\(A + (\\bar{A} . B) = A\\) \\(A + \\bar{A} = 1\\) \\(A . A = A\\) Answer \\(A + (\\bar{A} . B) = A\\) Exercise Simplifique a seguinte express\u00e3o: \\(\\bar{A} \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B \\bar{C}\\) Answer \\(\\bar{C} + \\bar{A} B C\\) Exercise Encontre as equa\u00e7\u00f5es para os mapas de Karnaugh a seguir: Exercise Crie o mapa de Karnaugh e encontre a equa\u00e7\u00e3o da tabela verdade a seguir. A B C OUT 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 0 Exercise Crie o mapa de Karnaugh da tabela verdade de quatro entradas. A B C D OUT 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 1 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1 Exercise Crie o mapa de Karnaugh para a express\u00e3o a seguir e simplifique: \\(ABC\\bar{D} + \\bar{A}\\bar{B}CD + A \\bar{B}\\bar{C}D + \\bar{A} + \\bar{B} + \\bar{C} + \\bar{D}\\) Exercise A seguinte express\u00e3o foi resultado da forma can\u00f4nica do produto de somas de uma tabela verdade para a produ\u00e7\u00e3o de um circuito l\u00f3gico. O objetivo \u00e9 simplificar a \u00e1lgebra booleana dessa l\u00f3gica para o menor n\u00famero poss\u00edvel de portas, por\u00e9m visivelmente quem fez essa f\u00f3rmula n\u00e3o percebeu que se tivesse feito a soma de produtos j\u00e1 partiria com um n\u00famero menor de termos. Converta essa f\u00f3rmula para a soma de produtos e minimize-a. \\((A+B+C)(A+B+\\bar{C})(A+\\bar{B}+C)(\\bar{A}+B+C)(\\bar{A}+\\bar{B}+C)\\) dica: Equa\u00e7\u00e3o -> tabela verdade -> soma dos produtos Acabou? Os exerc\u00edcios n\u00e3o param por aqui, tem a parte 2!","title":"Tabela verdade"},{"location":"Exercicio-Algebra-Booleana-2/","text":"\u00c1lgebra Booleana - 2 \u00b6 Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Exercise Dado o circuito a seguir: Simplifique-o Desenhe o circuito simplificado Exercise Encontre a equa\u00e7\u00e3o dos mapas de K. a seguir: (TOCCCI - pg. 178) X representa: Tanto faz, pode assumir 1 ou 0 . Voc\u00ea deve decidir o que for melhor para a simplifica\u00e7\u00e3o. Exercise Detector de moedas Um detector de moedas em uma m\u00e1quina de venda aceita quarters, dimes e nickels e ativa o sinal correspondente (Q,D,N) apenas com a moeda correta. \u00c9 fisicamente imposs\u00edvel m\u00faltiplas moedas estarem presentes ao mesmo tempo. Um circuito digital utiliza os sinais Q,D e N como entradas e produz um n\u00famero bin\u00e1rio representando o valor da moeda, como mostrado no circuito a seguir. Desenvolva um circuito (diagrama l\u00f3gico) que resolva o problema (dica: use um MUX) Moeda Valor Quarter 25 Dime 10 Nickel 5 Exercise Impressora A fig. a seguir mostra quatro chaves que fazem parte do circuito de controle em uma m\u00e1quina copiadora. As chaves est\u00e3o posicionadas ao longo da trajet\u00f3ria do papel dentro da m\u00e1quina. Cada chave est\u00e1 no estado normal aberta e, quando o papel passa sobre a chave, ela \u00e9 fechada. \u00c9 imposs\u00edvel o fechamento simult\u00e2neo das chaves SW1 e SW4. Projete um circuito l\u00f3gico que gere em sa\u00edda em n\u00edvel ALTO sempre que duas ou mais chaves estiverem fechadas ao mesmo tempo. Utilize o mapa de Karnaught. (TOCCI - pg. 179) Exercise SevenSeg Encontre as equa\u00e7\u00f5es que regem os segmentos 0 e 6 de um display de 7 segmento. Warning A l\u00f3gica de acender um display \u00e9 invertida (por ser do tipo anodo comum), para acender um segmento \u00e9 necess\u00e1rio colocar 0 na linha e para apagar 1 .","title":"\u00c1lgebra Booleana - 2"},{"location":"Exercicio-Algebra-Booleana-2/#algebra-booleana-2","text":"Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Exercise Dado o circuito a seguir: Simplifique-o Desenhe o circuito simplificado Exercise Encontre a equa\u00e7\u00e3o dos mapas de K. a seguir: (TOCCCI - pg. 178) X representa: Tanto faz, pode assumir 1 ou 0 . Voc\u00ea deve decidir o que for melhor para a simplifica\u00e7\u00e3o. Exercise Detector de moedas Um detector de moedas em uma m\u00e1quina de venda aceita quarters, dimes e nickels e ativa o sinal correspondente (Q,D,N) apenas com a moeda correta. \u00c9 fisicamente imposs\u00edvel m\u00faltiplas moedas estarem presentes ao mesmo tempo. Um circuito digital utiliza os sinais Q,D e N como entradas e produz um n\u00famero bin\u00e1rio representando o valor da moeda, como mostrado no circuito a seguir. Desenvolva um circuito (diagrama l\u00f3gico) que resolva o problema (dica: use um MUX) Moeda Valor Quarter 25 Dime 10 Nickel 5 Exercise Impressora A fig. a seguir mostra quatro chaves que fazem parte do circuito de controle em uma m\u00e1quina copiadora. As chaves est\u00e3o posicionadas ao longo da trajet\u00f3ria do papel dentro da m\u00e1quina. Cada chave est\u00e1 no estado normal aberta e, quando o papel passa sobre a chave, ela \u00e9 fechada. \u00c9 imposs\u00edvel o fechamento simult\u00e2neo das chaves SW1 e SW4. Projete um circuito l\u00f3gico que gere em sa\u00edda em n\u00edvel ALTO sempre que duas ou mais chaves estiverem fechadas ao mesmo tempo. Utilize o mapa de Karnaught. (TOCCI - pg. 179) Exercise SevenSeg Encontre as equa\u00e7\u00f5es que regem os segmentos 0 e 6 de um display de 7 segmento. Warning A l\u00f3gica de acender um display \u00e9 invertida (por ser do tipo anodo comum), para acender um segmento \u00e9 necess\u00e1rio colocar 0 na linha e para apagar 1 .","title":"\u00c1lgebra Booleana - 2"},{"location":"Exercicio-CPU-1/","text":"Exercicio CPU - 1 \u00b6 Info Os problemas aqui descritos s\u00e3o os mesmo do final do LAB-15 . CPU \u00b6 Proponha uma modifica\u00e7\u00e3o na CPU do nosso Z01.1 que: Adiciona mais um registrador ( %S ) (onde \u00e9 melhor?) Voc\u00ea teria que modificar a linguagem de m\u00e1quina do nosso HW. Proponha uma solu\u00e7\u00e3o. Possibilita %D endere\u00e7ar a mem\u00f3ria movw %A, (%D) Possibilite fazer carregamento efetivo em %D leaw $5, %D Para cada modifica\u00e7\u00e3o fa\u00e7a o desenho da nova CPU. Extras \u00b6 nop \u00b6 Como o controlUnit controla a CPU para realizar a opera\u00e7\u00e3o de NOP? movw %D, %A e jg %D ao mesmo tempo \u00b6 Nossa CPU suportaria executar simultaneamente a instru\u00e7\u00e3o movw %D, %A e ao mesmo tempo a instru\u00e7\u00e3o jg %D ? loadPC \u00b6 Quais sinais o influenciam?","title":"Exercicio CPU - 1"},{"location":"Exercicio-CPU-1/#exercicio-cpu-1","text":"Info Os problemas aqui descritos s\u00e3o os mesmo do final do LAB-15 .","title":"Exercicio CPU - 1"},{"location":"Exercicio-CPU-1/#cpu","text":"Proponha uma modifica\u00e7\u00e3o na CPU do nosso Z01.1 que: Adiciona mais um registrador ( %S ) (onde \u00e9 melhor?) Voc\u00ea teria que modificar a linguagem de m\u00e1quina do nosso HW. Proponha uma solu\u00e7\u00e3o. Possibilita %D endere\u00e7ar a mem\u00f3ria movw %A, (%D) Possibilite fazer carregamento efetivo em %D leaw $5, %D Para cada modifica\u00e7\u00e3o fa\u00e7a o desenho da nova CPU.","title":"CPU"},{"location":"Exercicio-CPU-1/#extras","text":"","title":"Extras"},{"location":"Exercicio-CPU-1/#nop","text":"Como o controlUnit controla a CPU para realizar a opera\u00e7\u00e3o de NOP?","title":"nop"},{"location":"Exercicio-CPU-1/#movw-d-a-e-jg-d-ao-mesmo-tempo","text":"Nossa CPU suportaria executar simultaneamente a instru\u00e7\u00e3o movw %D, %A e ao mesmo tempo a instru\u00e7\u00e3o jg %D ?","title":"movw %D, %A e jg %D ao mesmo tempo"},{"location":"Exercicio-CPU-1/#loadpc","text":"Quais sinais o influenciam?","title":"loadPC"},{"location":"Exercicio-CPU-2/","text":"Exerc\u00edcio CPU - 2 \u00b6 falha 1 \u00b6 Note Para resolver o exerc\u00edcio a seguir voc\u00eas devem verificar a instru\u00e7\u00e3o que est\u00e1 sendo executada na CPU e o que ela deveria estar fazendo no hardawre. Voc\u00eas estavam desenvolvendo o projeto F quando o teste de integra\u00e7\u00e3o ./testeAssemblyMyCpu.py falhou no nasm descrito a seguir. Um colega do grupo enviou o waveform a seguir para voc\u00ea encontrar o problema (voc\u00ea deve falar o que est\u00e1 falhando). Tip clique na imagem para ampliar esse waveform \u00e9 dos sinais da CPU.vhd Essa simula\u00e7\u00e3o executa o programa a seguir: leaw $ 0 , % A movw ( % A ), % D leaw $ 1 , % A movw ( % A ), % A addw % A , % D , ( % A ) Que possui a RAM iniciada com os seguintes valores: Address Dado 0 0000000000000010 1 0000000001000010 3 0000000000000000 Resolu\u00e7\u00e3o Your browser does not support the video tag. Se o v\u00eddeo n\u00e3o abrir acesse pelo link e fa\u00e7a o download: http://54.162.111.146/shared/ele/erro-loadA.mp4 Engenharia reversa \u00b6 Voc\u00ea foi chamado para fazer engenharia reversa em um programa executando no HW do Z01, na captura de dados a equipe respons\u00e1vel n\u00e3o conseguiu capturar o sinal da Instru\u00e7\u00e3o, e n\u00e3o sabem quais comandos est\u00e3o sendo executados no computador. Encontre os tr\u00eas comandos em nasm que est\u00e3o sendo executados no hardware nesse momento: Tip clique na imagem para ampliar esse waveform \u00e9 dos sinais da CPU.vhd Resolu\u00e7\u00e3o Your browser does not support the video tag. Se o v\u00eddeo n\u00e3o abrir acesse pelo link e fa\u00e7a o download: http://54.162.111.146/shared/ele/eng-rev.mp4","title":"Exerc\u00edcio CPU - 2"},{"location":"Exercicio-CPU-2/#exercicio-cpu-2","text":"","title":"Exerc\u00edcio CPU - 2"},{"location":"Exercicio-CPU-2/#falha-1","text":"Note Para resolver o exerc\u00edcio a seguir voc\u00eas devem verificar a instru\u00e7\u00e3o que est\u00e1 sendo executada na CPU e o que ela deveria estar fazendo no hardawre. Voc\u00eas estavam desenvolvendo o projeto F quando o teste de integra\u00e7\u00e3o ./testeAssemblyMyCpu.py falhou no nasm descrito a seguir. Um colega do grupo enviou o waveform a seguir para voc\u00ea encontrar o problema (voc\u00ea deve falar o que est\u00e1 falhando). Tip clique na imagem para ampliar esse waveform \u00e9 dos sinais da CPU.vhd Essa simula\u00e7\u00e3o executa o programa a seguir: leaw $ 0 , % A movw ( % A ), % D leaw $ 1 , % A movw ( % A ), % A addw % A , % D , ( % A ) Que possui a RAM iniciada com os seguintes valores: Address Dado 0 0000000000000010 1 0000000001000010 3 0000000000000000 Resolu\u00e7\u00e3o Your browser does not support the video tag. Se o v\u00eddeo n\u00e3o abrir acesse pelo link e fa\u00e7a o download: http://54.162.111.146/shared/ele/erro-loadA.mp4","title":"falha 1"},{"location":"Exercicio-CPU-2/#engenharia-reversa","text":"Voc\u00ea foi chamado para fazer engenharia reversa em um programa executando no HW do Z01, na captura de dados a equipe respons\u00e1vel n\u00e3o conseguiu capturar o sinal da Instru\u00e7\u00e3o, e n\u00e3o sabem quais comandos est\u00e3o sendo executados no computador. Encontre os tr\u00eas comandos em nasm que est\u00e3o sendo executados no hardware nesse momento: Tip clique na imagem para ampliar esse waveform \u00e9 dos sinais da CPU.vhd Resolu\u00e7\u00e3o Your browser does not support the video tag. Se o v\u00eddeo n\u00e3o abrir acesse pelo link e fa\u00e7a o download: http://54.162.111.146/shared/ele/eng-rev.mp4","title":"Engenharia reversa"},{"location":"Exercicio-Dados-1/","text":"Dados Digitais - 1 \u00b6 Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Conte\u00fado: N\u00fameros bin\u00e1rios; Hexadecimal; Octal; Convers\u00e3o entre as diferentes bases; BCD; ASCII; https://docs.google.com/spreadsheets/d/1rN_zQqYaVI8PjAhKqEBCmY-_06I0X9dD0RddcI-miJs/edit?usp=sharing","title":"Dados Digitais - 1"},{"location":"Exercicio-Dados-1/#dados-digitais-1","text":"Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Conte\u00fado: N\u00fameros bin\u00e1rios; Hexadecimal; Octal; Convers\u00e3o entre as diferentes bases; BCD; ASCII; https://docs.google.com/spreadsheets/d/1rN_zQqYaVI8PjAhKqEBCmY-_06I0X9dD0RddcI-miJs/edit?usp=sharing","title":"Dados Digitais - 1"},{"location":"Exercicio-Dados-2/","text":"Dados Digitais - 2 \u00b6 Vers\u00e3o para impress\u00e3o. Mem\u00f3ria 1 \u00b6 Mem\u00f3ria 2 \u00b6 Voc\u00ea est\u00e1 debugando uma comunica\u00e7\u00e3o serial entre dois equipamentos e foi capaz de capturar a seguinte sequ\u00eancia de dados: Qual foi a mensagem enviada? Voc\u00ea sabe que a mensagem enviada est\u00e1 codificada em ASCII. 7 Segmentos \u00b6 O display de sete segmentos \u00e9 um componente muito utilizado em sistemas eletr\u00f4nicos, com ele conseguimos exibir valor d\u00edgitos num\u00e9ricos: Fonte: https://www.sunfounder.com/media/wysiwyg/swatches/super-kit-v2-for-Arduino/10_7_seg_display/ Por exemplo, para exibir o valor 7 \u00e9 necess\u00e1rio acionar os segmentos: a , b , c : Utilize o site: http://www.uize.com/examples/seven-segment-display.html para brincar um pouco. Os segmentos normalmente formam um vetor do tipo g , f , e , d , c , b , a . O Valor 7 seria codificado em: 0b0000111 -> 0x07 . Voc\u00ea est\u00e1 fazendo um projeto que possui um display de 7 segmentos, mas infelizmente ele est\u00e1 queimado (pois \u00e9, essas coisas acontecem), voc\u00ea foi incumbido de descobrir quais valores estavam sendo enviados para ele. Para isso voc\u00ea plugou um analisador de sinais nas trilhas que iam para o display, e foi capaz de obter a seguinte forma de onda: Voc\u00ea deve descobrir quais s\u00e3o os tr\u00eas valores (faixas) que estariam sendo exibidos no display! Octal \u00b6 Voc\u00ea quer modificar as permiss\u00f5es de um arquivo no seu Linux para: Usu\u00e1rio: Leitura/Escrita e execu\u00e7\u00e3o Grupo: Escrita e Leitura Outros: Leitura Preencha o comando a seguir, com os valores corretos (em octal) para isso: $ chmod ________ FILE.py Tip Consulte a teoria.","title":"Dados Digitais - 2"},{"location":"Exercicio-Dados-2/#dados-digitais-2","text":"Vers\u00e3o para impress\u00e3o.","title":"Dados Digitais - 2"},{"location":"Exercicio-Dados-2/#memoria-1","text":"","title":"Mem\u00f3ria 1"},{"location":"Exercicio-Dados-2/#memoria-2","text":"Voc\u00ea est\u00e1 debugando uma comunica\u00e7\u00e3o serial entre dois equipamentos e foi capaz de capturar a seguinte sequ\u00eancia de dados: Qual foi a mensagem enviada? Voc\u00ea sabe que a mensagem enviada est\u00e1 codificada em ASCII.","title":"Mem\u00f3ria 2"},{"location":"Exercicio-Dados-2/#7-segmentos","text":"O display de sete segmentos \u00e9 um componente muito utilizado em sistemas eletr\u00f4nicos, com ele conseguimos exibir valor d\u00edgitos num\u00e9ricos: Fonte: https://www.sunfounder.com/media/wysiwyg/swatches/super-kit-v2-for-Arduino/10_7_seg_display/ Por exemplo, para exibir o valor 7 \u00e9 necess\u00e1rio acionar os segmentos: a , b , c : Utilize o site: http://www.uize.com/examples/seven-segment-display.html para brincar um pouco. Os segmentos normalmente formam um vetor do tipo g , f , e , d , c , b , a . O Valor 7 seria codificado em: 0b0000111 -> 0x07 . Voc\u00ea est\u00e1 fazendo um projeto que possui um display de 7 segmentos, mas infelizmente ele est\u00e1 queimado (pois \u00e9, essas coisas acontecem), voc\u00ea foi incumbido de descobrir quais valores estavam sendo enviados para ele. Para isso voc\u00ea plugou um analisador de sinais nas trilhas que iam para o display, e foi capaz de obter a seguinte forma de onda: Voc\u00ea deve descobrir quais s\u00e3o os tr\u00eas valores (faixas) que estariam sendo exibidos no display!","title":"7 Segmentos"},{"location":"Exercicio-Dados-2/#octal","text":"Voc\u00ea quer modificar as permiss\u00f5es de um arquivo no seu Linux para: Usu\u00e1rio: Leitura/Escrita e execu\u00e7\u00e3o Grupo: Escrita e Leitura Outros: Leitura Preencha o comando a seguir, com os valores corretos (em octal) para isso: $ chmod ________ FILE.py Tip Consulte a teoria.","title":"Octal"},{"location":"Exercicio-Logica-Sequencial-1/","text":"L\u00f3gica Sequencial - 1 \u00b6 https://docs.google.com/forms/d/e/1FAIpQLSdGuoLR1Re3aok6I6adChgaDuMg0-dJaA7FF2gK5MLIGReg3g/viewform?usp=sf_link Loading\u2026","title":"L\u00f3gica Sequencial - 1"},{"location":"Exercicio-Logica-Sequencial-1/#logica-sequencial-1","text":"https://docs.google.com/forms/d/e/1FAIpQLSdGuoLR1Re3aok6I6adChgaDuMg0-dJaA7FF2gK5MLIGReg3g/viewform?usp=sf_link Loading\u2026","title":"L\u00f3gica Sequencial - 1"},{"location":"Exercicio-Logica-Sequencial-2/","text":"\u00c1lgebra Booleana - 1 \u00b6 Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Indique o nome dos elementos l\u00f3gicos a seguir: \u00b6 Tabela verdade \u00b6 A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 0 0 1 1 1 0 1 1 1 0 A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 1 0 1 1 1 0 1 1 1 0 \\newpage Aplicando a lei da Distributividade na express\u00e3o \\(A(B+\\bar{C}+D)\\) se tem: \u00b6 \\(A . B + A . C + A . D\\) \\(A . B . C . D\\) \\(A + B + C + D\\) \\(A B + A\\bar{C} + A . D\\) Aplicando o teorema de DeMorgan na express\u00e3o \\(\\overline{ABC}\\) , obtem: \u00b6 \\(\\bar{A}+\\bar{B}+\\bar{C}\\) \\(\\overline{A+B+C}\\) \\(A + \\bar{B} + C \\bar{C}\\) \\(A . (B+C)\\) Qual simplifica\u00e7\u00e3o est\u00e1 incorreta: \u00b6 \\(\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y}\\) \\(x ( \\bar{x} + y ) = x . \\bar{x} + x . y = 0 + x . y = x . y\\) \\(x . y + x ( y + z ) = x . y + x . y + z = x . y + z\\) \\(\\bar{x} . \\bar{y} . z + \\bar{x} . y . z + x . \\bar{y} = \\bar{x} . z (\\bar{y} + y) + x . \\bar{y} = \\bar{x} . z + x . \\bar{y}\\) Qual forma can\u00f4nica est\u00e1 correta? \u00b6 A B Q 0 0 1 0 1 0 1 0 0 1 1 1 \\(Q = A \\bar{B} + A \\bar{B}\\) \\(Q = A+B * \\bar{A} \\bar{B}\\) \\(Q = A . B\\) \\(Q = \\bar{A} . \\bar{B} + A . B\\) Dado a seguinte tabela verdade (entradas A, B e C, e a sa\u00edda Q): \u00b6 A B C Q 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 Crie uma f\u00f3rmula em \u00e1lgebra booleana que represente a tabela via SoP e PoS. Simplifique SoP (interprete o resultado!) Desenhe um circuito usando os \u00edcones da \u00e1lgebra booleana. Quantas sa\u00eddas com 1 existem na tabela verdade que resulta na seguinte f\u00f3rmula de soma de produtos: \u00b6 \\(A \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B C\\) Qual das seguintes op\u00e7\u00f5es \u00e9 uma caracter\u00edstica importante da forma can\u00f4nica de soma de produtos? \u00b6 Os circuitos l\u00f3gicos s\u00e3o reduzidos a nada mais do que simples portas AND e OR. Os tempos de atraso s\u00e3o muito reduzidas em rela\u00e7\u00e3o a outras formas. Nenhum sinal deve passar por mais de dois portas l\u00f3gicas, n\u00e3o incluindo inversores. O n\u00famero m\u00e1ximo de portas que qualquer sinal deve passar \u00e9 reduzido por um factor de dois. Qual \u00e9 a express\u00e3o em \u00e1lgebra booleana do seguinte circuito: \u00b6 Gere a Tabela Verdade das equa\u00e7\u00f5es a seguir: \u00b6 \\(A . B + \\overline{B + A}\\) \\(A \\oplus B\\) \\((A and B) or C\\) Converta a seguinte express\u00e3o em Soma de Produtos para Produto de Somas: \u00b6 \\(A . B . C + A \\bar{B} \\bar{C} + A . \\bar{B} C + A . B . \\bar{C} + \\bar{A} . \\bar{B} . C\\) Fa\u00e7a a tabela verdade Encontre o PoS Determine os valores de A, B, C e D que fazem a f\u00f3rmula a seguir ser igual a zero (Z = 0). \u00b6 \\(Z = \\bar{A} + B + \\bar{C} + D\\) Qual das seguintes propriedades da \u00e1lgebra booleana \u00e9 falsa: \u00b6 \\(A . (\\bar{A} + B)= A . B\\) \\(A + (A . B) = A\\) \\(A + \\bar{A} = 1\\) \\(A . A = A\\) Simplifique a seguinte express\u00e3o: \u00b6 \\(\\bar{A} \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B \\bar{C}\\) Encontre as equa\u00e7\u00f5es para os mapas de Karnaugh a seguir: \u00b6 \\newpage Crie o mapa de Karnaugh e encontre a equa\u00e7\u00e3o da tabela verdade a seguir. \u00b6 A B C OUT 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 0 Crie o mapa de Karnaugh da tabela verdade de quatro entradas. \u00b6 A B C D OUT 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 1 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1 Crie o mapa de Karnaugh para a express\u00e3o a seguir e simplifique: \u00b6 \\(ABC\\bar{D} + \\bar{A}\\bar{B}CD + A \\bar{B}\\bar{C}D + \\bar{A} + \\bar{B} + \\bar{C} + \\bar{D}\\) A seguinte express\u00e3o foi resultado da forma can\u00f4nica do produto de somas de uma tabela verdade para a produ\u00e7\u00e3o de um circuito l\u00f3gico. O objetivo \u00e9 simplificar a \u00e1lgebra booleana dessa l\u00f3gica para o menor n\u00famero poss\u00edvel de portas, por\u00e9m visivelmente quem fez essa f\u00f3rmula n\u00e3o percebeu que se tivesse feito a soma de produtos j\u00e1 partiria com um n\u00famero menor de termos. Converta essa f\u00f3rmula para a soma de produtos e minimize ela. \u00b6 _ _ _ _ _ (A+B+C) * (A+B+C) * (A+B+C) * (A+B+C) * (A+B+C) Acabou? Os exerc\u00edcios n\u00e3o param por aqui, tem a parte 2!","title":"\u00c1lgebra Booleana - 1"},{"location":"Exercicio-Logica-Sequencial-2/#algebra-booleana-1","text":"Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o","title":"\u00c1lgebra Booleana - 1"},{"location":"Exercicio-Logica-Sequencial-2/#indique-o-nome-dos-elementos-logicos-a-seguir","text":"","title":"Indique o nome dos elementos l\u00f3gicos a seguir:"},{"location":"Exercicio-Logica-Sequencial-2/#tabela-verdade","text":"A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 0 0 1 1 1 0 1 1 1 0 A tabela verdade a seguir representa qual porta l\u00f3gica? A B OUT 0 0 1 0 1 1 1 0 1 1 1 0 \\newpage","title":"Tabela verdade"},{"location":"Exercicio-Logica-Sequencial-2/#aplicando-a-lei-da-distributividade-na-expressao-abbarcd-se-tem","text":"\\(A . B + A . C + A . D\\) \\(A . B . C . D\\) \\(A + B + C + D\\) \\(A B + A\\bar{C} + A . D\\)","title":"Aplicando a lei da Distributividade na express\u00e3o \\(A(B+\\bar{C}+D)\\)\u00a0se tem:"},{"location":"Exercicio-Logica-Sequencial-2/#aplicando-o-teorema-de-demorgan-na-expressao-overlineabc-obtem","text":"\\(\\bar{A}+\\bar{B}+\\bar{C}\\) \\(\\overline{A+B+C}\\) \\(A + \\bar{B} + C \\bar{C}\\) \\(A . (B+C)\\)","title":"Aplicando o teorema de DeMorgan na express\u00e3o\u00a0\\(\\overline{ABC}\\), obtem:"},{"location":"Exercicio-Logica-Sequencial-2/#qual-simplificacao-esta-incorreta","text":"\\(\\overline{(\\bar{x}+\\bar{y})} = \\bar{\\bar{x}}*\\bar{y} = x * \\bar{y}\\) \\(x ( \\bar{x} + y ) = x . \\bar{x} + x . y = 0 + x . y = x . y\\) \\(x . y + x ( y + z ) = x . y + x . y + z = x . y + z\\) \\(\\bar{x} . \\bar{y} . z + \\bar{x} . y . z + x . \\bar{y} = \\bar{x} . z (\\bar{y} + y) + x . \\bar{y} = \\bar{x} . z + x . \\bar{y}\\)","title":"Qual simplifica\u00e7\u00e3o est\u00e1 incorreta:"},{"location":"Exercicio-Logica-Sequencial-2/#qual-forma-canonica-esta-correta","text":"A B Q 0 0 1 0 1 0 1 0 0 1 1 1 \\(Q = A \\bar{B} + A \\bar{B}\\) \\(Q = A+B * \\bar{A} \\bar{B}\\) \\(Q = A . B\\) \\(Q = \\bar{A} . \\bar{B} + A . B\\)","title":"Qual forma can\u00f4nica est\u00e1 correta?"},{"location":"Exercicio-Logica-Sequencial-2/#dado-a-seguinte-tabela-verdade-entradas-a-b-e-c-e-a-saida-q","text":"A B C Q 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 Crie uma f\u00f3rmula em \u00e1lgebra booleana que represente a tabela via SoP e PoS. Simplifique SoP (interprete o resultado!) Desenhe um circuito usando os \u00edcones da \u00e1lgebra booleana.","title":"Dado a seguinte tabela verdade (entradas A, B e C, e a sa\u00edda Q):"},{"location":"Exercicio-Logica-Sequencial-2/#quantas-saidas-com-1-existem-na-tabela-verdade-que-resulta-na-seguinte-formula-de-soma-de-produtos","text":"\\(A \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B C\\)","title":"Quantas sa\u00eddas com 1 existem na tabela verdade que resulta na seguinte f\u00f3rmula de soma de produtos:"},{"location":"Exercicio-Logica-Sequencial-2/#qual-das-seguintes-opcoes-e-uma-caracteristica-importante-da-forma-canonica-de-soma-de-produtos","text":"Os circuitos l\u00f3gicos s\u00e3o reduzidos a nada mais do que simples portas AND e OR. Os tempos de atraso s\u00e3o muito reduzidas em rela\u00e7\u00e3o a outras formas. Nenhum sinal deve passar por mais de dois portas l\u00f3gicas, n\u00e3o incluindo inversores. O n\u00famero m\u00e1ximo de portas que qualquer sinal deve passar \u00e9 reduzido por um factor de dois.","title":"Qual das seguintes op\u00e7\u00f5es \u00e9 uma caracter\u00edstica importante da forma can\u00f4nica de soma de produtos?"},{"location":"Exercicio-Logica-Sequencial-2/#qual-e-a-expressao-em-algebra-booleana-do-seguinte-circuito","text":"","title":"Qual \u00e9 a express\u00e3o em \u00e1lgebra booleana do seguinte circuito:"},{"location":"Exercicio-Logica-Sequencial-2/#gere-a-tabela-verdade-das-equacoes-a-seguir","text":"\\(A . B + \\overline{B + A}\\) \\(A \\oplus B\\) \\((A and B) or C\\)","title":"Gere a Tabela Verdade das equa\u00e7\u00f5es a seguir:"},{"location":"Exercicio-Logica-Sequencial-2/#converta-a-seguinte-expressao-em-soma-de-produtos-para-produto-de-somas","text":"\\(A . B . C + A \\bar{B} \\bar{C} + A . \\bar{B} C + A . B . \\bar{C} + \\bar{A} . \\bar{B} . C\\) Fa\u00e7a a tabela verdade Encontre o PoS","title":"Converta a seguinte express\u00e3o em Soma de Produtos para Produto de Somas:"},{"location":"Exercicio-Logica-Sequencial-2/#determine-os-valores-de-a-b-c-e-d-que-fazem-a-formula-a-seguir-ser-igual-a-zero-z-0","text":"\\(Z = \\bar{A} + B + \\bar{C} + D\\)","title":"Determine os valores de A, B, C e D que fazem a f\u00f3rmula a seguir ser igual a zero (Z = 0)."},{"location":"Exercicio-Logica-Sequencial-2/#qual-das-seguintes-propriedades-da-algebra-booleana-e-falsa","text":"\\(A . (\\bar{A} + B)= A . B\\) \\(A + (A . B) = A\\) \\(A + \\bar{A} = 1\\) \\(A . A = A\\)","title":"Qual das seguintes propriedades da \u00e1lgebra booleana \u00e9 falsa:"},{"location":"Exercicio-Logica-Sequencial-2/#simplifique-a-seguinte-expressao","text":"\\(\\bar{A} \\bar{B} \\bar{C} + \\bar{A} B C + \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + A B \\bar{C}\\)","title":"Simplifique a seguinte express\u00e3o:"},{"location":"Exercicio-Logica-Sequencial-2/#encontre-as-equacoes-para-os-mapas-de-karnaugh-a-seguir","text":"\\newpage","title":"Encontre as equa\u00e7\u00f5es para os mapas de Karnaugh a seguir:"},{"location":"Exercicio-Logica-Sequencial-2/#crie-o-mapa-de-karnaugh-e-encontre-a-equacao-da-tabela-verdade-a-seguir","text":"A B C OUT 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 0","title":"Crie o mapa de Karnaugh e encontre a equa\u00e7\u00e3o da tabela verdade a seguir."},{"location":"Exercicio-Logica-Sequencial-2/#crie-o-mapa-de-karnaugh-da-tabela-verdade-de-quatro-entradas","text":"A B C D OUT 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 1 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1","title":"Crie o mapa de Karnaugh da tabela verdade de quatro entradas."},{"location":"Exercicio-Logica-Sequencial-2/#crie-o-mapa-de-karnaugh-para-a-expressao-a-seguir-e-simplifique","text":"\\(ABC\\bar{D} + \\bar{A}\\bar{B}CD + A \\bar{B}\\bar{C}D + \\bar{A} + \\bar{B} + \\bar{C} + \\bar{D}\\)","title":"Crie o mapa de Karnaugh para a express\u00e3o a seguir e simplifique:"},{"location":"Exercicio-Logica-Sequencial-2/#a-seguinte-expressao-foi-resultado-da-forma-canonica-do-produto-de-somas-de-uma-tabela-verdade-para-a-producao-de-um-circuito-logico-o-objetivo-e-simplificar-a-algebra-booleana-dessa-logica-para-o-menor-numero-possivel-de-portas-porem-visivelmente-quem-fez-essa-formula-nao-percebeu-que-se-tivesse-feito-a-soma-de-produtos-ja-partiria-com-um-numero-menor-de-termos-converta-essa-formula-para-a-soma-de-produtos-e-minimize-ela","text":"_ _ _ _ _ (A+B+C) * (A+B+C) * (A+B+C) * (A+B+C) * (A+B+C) Acabou? Os exerc\u00edcios n\u00e3o param por aqui, tem a parte 2!","title":"A seguinte express\u00e3o foi resultado da forma can\u00f4nica do produto de somas de uma tabela verdade para a produ\u00e7\u00e3o de um circuito l\u00f3gico. O objetivo \u00e9 simplificar a \u00e1lgebra booleana dessa l\u00f3gica para o menor n\u00famero poss\u00edvel de portas, por\u00e9m visivelmente quem fez essa f\u00f3rmula n\u00e3o percebeu que se tivesse feito a soma de produtos j\u00e1 partiria com um n\u00famero menor de termos. Converta essa f\u00f3rmula para a soma de produtos e minimize ela."},{"location":"Exercicio-Sincrono-1/","text":"\u00c1lgebra Booleana - 1 \u00b6 Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o Flip-Flop \u00b6 Um flip-flop tipo D possui entradas: clock , D , clear , preset e as sa\u00eddas Q e \\(\\bar{Q}\\) , explique quais s\u00e3o os papeis de cada uma das portas desse componente: Explique o papel das portas: clock : D : Clear : Preset : Q : not(Q) : Preencha a tabela verdade a seguir:","title":"\u00c1lgebra Booleana - 1"},{"location":"Exercicio-Sincrono-1/#algebra-booleana-1","text":"Vers\u00e3o para impress\u00e3o. Resolu\u00e7\u00e3o","title":"\u00c1lgebra Booleana - 1"},{"location":"Exercicio-Sincrono-1/#flip-flop","text":"Um flip-flop tipo D possui entradas: clock , D , clear , preset e as sa\u00eddas Q e \\(\\bar{Q}\\) , explique quais s\u00e3o os papeis de cada uma das portas desse componente: Explique o papel das portas: clock : D : Clear : Preset : Q : not(Q) : Preencha a tabela verdade a seguir:","title":"Flip-Flop"},{"location":"Historia-linux/","text":"Linus \u00b6 Desenvolvido em 1991 por Linux Torvalds na Finl\u00e2ndia quando terminava sua gradua\u00e7\u00e3o em ci\u00eancia da computa\u00e7\u00e3o, e n\u00e3o satisfeito com o os sistemas operacionais da \u00e9poca que eram PAGOS (MAC, UNIX, ...) ou puramente acad\u00eamico (Minix) https://en.wikipedia.org/wiki/Linux https://en.wikipedia.org/wiki/Linus_Torvalds https://pt.wikipedia.org/wiki/MINIX Resolveu criar um sistema operacional do zero, baseado em UNIX e seguindo o livro de um de seus professores: Andrew S. Tanenbaum, que era a base do minix por\u00e9m liberado apenas para complementar o livro. https://en.wikipedia.org/wiki/Andrew_S._Tanenbaum livro: https://www.amazon.com/Operating-Systems-Design-Implementation-3rd/dp/0131429388 https://images-na.ssl-images-amazon.com/images/I/61rSUrfS5HL._SX384_BO1,204,203,200_.jpg UNIX? Define a arquitetura do sistema operacional, as APIS e estrutura do kernel Fato: Unix + Linus = Linux! Primeira vers\u00e3o \u00b6 Aos 21 anos, Linus terminou a primeira vers\u00e3o do OS e publicou em uma lista de mensagens (n\u00e3o tinha forum/ e-mail/ ... na \u00e9poca, essas listas eram o come\u00e7o) a seguinte mensagem: Hello everybody out there using minix - I'm doing a (free) operating system (just a hobby, won't be big and professional like gnu) for 386(486) AT clones. This has been brewing since april, and is starting to get ready. I'd like any feedback on things people like/dislike in minix, as my OS resembles it somewhat (same physical layout of the file-system (due to practical reasons) among other things). I've currently ported bash(1.08) and gcc(1.40), and things seem to work. This implies that I'll get something practical within a few months, and I'd like to know what features most people would want. Any suggestions are welcome, but I won't promise I'll implement them :-) Linus ( torvalds@kruuna.helsinki.fi ) PS. Yes - it's free of any minix code, and it has a multi-threaded fs. It is NOT portable (uses 386 task switching etc), and it probably never will support anything other than AT-harddisks, as that's all I have :-(. \u2014\u2009Linus Torvalds https://en.wikipedia.org/wiki/History_of_Linux GNU \u00b6 Um dos fatores que deu for\u00e7a para o sistema operacional rec\u00e9m lan\u00e7ado foi que ele foi desenvolvido utilizando ferramentas de outro projeto importante o GNU, que estava ganhando for\u00e7a na mesma \u00e9poca e fornecia uma s\u00e9rie de programas gratuitos para a comunidade, ele tamb\u00e9m introduziu o conceito de \"Software Livre\" e licen\u00e7a open source. Conduzido por Richard Stallman no MIT. https://en.wikipedia.org/wiki/GNU_Project https://pt.wikipedia.org/wiki/Richard_Matthew_Stallman O Linux como conhecemos hoje em dia \u00e9 tamb\u00e9m conhecido como Linux/GNU, pois faz uso extensivo dos dois projetos (compiladores, editores de texto, ...). Inclusive, a vers\u00e3o 0.99 o linux j\u00e1 foi publicado utilizando a licen\u00e7a GNU GPL. GPL \u00b6 A licen\u00e7a GNU GPL (GNU General Public License) possui os seguintes princ\u00edpios: A liberdade de executar o programa, para qualquer prop\u00f3sito (liberdade n\u00ba 0) A liberdade de estudar como o programa funciona e adapt\u00e1-lo \u00e0s suas necessidades (liberdade n\u00ba 1). O acesso ao c\u00f3digo-fonte \u00e9 um pr\u00e9-requisito para esta liberdade. A liberdade de redistribuir c\u00f3pias de modo que voc\u00ea possa ajudar ao seu pr\u00f3ximo (liberdade n\u00ba 2). A liberdade de aperfei\u00e7oar o programa e liberar os seus aperfei\u00e7oamentos, de modo que toda a comunidade beneficie deles (liberdade n\u00ba 3). O acesso ao c\u00f3digo-fonte \u00e9 um pr\u00e9-requisito para esta liberdade. https://pt.wikipedia.org/wiki/GNU_General_Public_License N\u00e3o podemos confundir software livre com software gratuito (como o google por exemplo). Mascote - Tux \u00b6 Em 1996 Linux anuncia o novo mascote para o Linux, um pinguim! Torvalds faz muitos mergulhos como hoobie, e diz ele que foi mordido por um pinguim na visita a um aqu\u00e1rio. https://duckduckgo.com/?q=linux+mascote&t=canonical&iax=images&ia=images&iai=http%3A%2F%2F4.bp.blogspot.com%2F-c8uUx6EnHv8%2FVo7_P8mUt4I%2FAAAAAAAACEw%2FeKA-7sjxGak%2Fs400%2FTux%252Bmascote%252Bdo%252Blinux.png Distribui\u00e7\u00f5es \u00b6 No come\u00e7o os softwares n\u00e3o eram distribu\u00eddos junto com o Linux, o desenvolvedor tinha que instalar e compilar tudo o que queria utilizar, e a coisas eram dispersas. Foi ai que surgiu a ideia de distribuir um pacote com o kernel do linux + alguns programas + configura\u00e7\u00f5es b\u00e1sicas. A distribui\u00e7\u00e3o mais antiga e ainda em 'uso' \u00e9 o SlackWare. https://www.cyberciti.biz/tips/wp-content/uploads/2007/06/44218-linuxdistrotimeline-7.2.png http://www.slackware.com/ Ubuntu \u00b6 Ubuntu foi criado em 2004 pelo empres\u00e1rio sul africano Mark Shuttleworth com o foco de disponibilizar uma distribui\u00e7\u00e3o para todos os usu\u00e1rios (desktop + server) e n\u00e3o apenas com foco empresarial como as demais distribui\u00e7\u00f5es. https://en.wikipedia.org/wiki/Mark_Shuttleworth https://en.wikipedia.org/wiki/Ubuntu O Ubuntu \u00e9 baseado em outra distribui\u00e7\u00e3o, o Debian, que teve sua origem muito antes em 1993. Os pacotes .deb foram criados por essa distro. distro hopping \u00b6 Achar uma distribui\u00e7\u00e3o que te agrade \u00e9 muito dif\u00edcil, o distro hopping \u00e9 o ato de ficar mudando de distribui\u00e7\u00e3o toda hora, instalando tudo novamente e ent\u00e3o, mudando de distro novamente. https://www.quora.com/What-is-distro-hopping-as-regards-Linux linux != Distro != Ambiente de desktop \u00b6 O linux em si \u00e9 apenas o kernel, o core do sistema operacional, por\u00e9m hoje me dia poucas pessoas utilizam apenas o bash no desktop. Muitas vezes o Linux \u00e9 associado apenas a interface gr\u00e1fica, que alias tem para todos os gostos! https://pt.wikipedia.org/wiki/Ambiente_de_desktop (padr\u00e3o atual do ubuntu) https://www.gnome.org/ https://kde.org/ https://ubuntubudgie.org/ (pantheon) https://elementary.io/ https://en.wikipedia.org/wiki/LXDE https://linuxmint.com/ Linux atualmente \u00b6 https://www.youtube.com/watch?v=yVpbFMhOAwE https://www.youtube.com/watch?v=SOXeXauRAm0&list=PLbzoR-pLrL6rsb1bc3En9zaEor9S0gyIp https://www.youtube.com/watch?v=rSjgVeNQrN0&list=PLbzoR-pLrL6rsb1bc3En9zaEor9S0gyIp&index=2 git? \u00b6 At\u00e9 2005 o linux utilizava um sistema privado de gerenciamento de vers\u00e3o privado, Linus tirou uma semana de f\u00e9rias e nasceu o git!","title":"Historia linux"},{"location":"Historia-linux/#linus","text":"Desenvolvido em 1991 por Linux Torvalds na Finl\u00e2ndia quando terminava sua gradua\u00e7\u00e3o em ci\u00eancia da computa\u00e7\u00e3o, e n\u00e3o satisfeito com o os sistemas operacionais da \u00e9poca que eram PAGOS (MAC, UNIX, ...) ou puramente acad\u00eamico (Minix) https://en.wikipedia.org/wiki/Linux https://en.wikipedia.org/wiki/Linus_Torvalds https://pt.wikipedia.org/wiki/MINIX Resolveu criar um sistema operacional do zero, baseado em UNIX e seguindo o livro de um de seus professores: Andrew S. Tanenbaum, que era a base do minix por\u00e9m liberado apenas para complementar o livro. https://en.wikipedia.org/wiki/Andrew_S._Tanenbaum livro: https://www.amazon.com/Operating-Systems-Design-Implementation-3rd/dp/0131429388 https://images-na.ssl-images-amazon.com/images/I/61rSUrfS5HL._SX384_BO1,204,203,200_.jpg UNIX? Define a arquitetura do sistema operacional, as APIS e estrutura do kernel Fato: Unix + Linus = Linux!","title":"Linus"},{"location":"Historia-linux/#primeira-versao","text":"Aos 21 anos, Linus terminou a primeira vers\u00e3o do OS e publicou em uma lista de mensagens (n\u00e3o tinha forum/ e-mail/ ... na \u00e9poca, essas listas eram o come\u00e7o) a seguinte mensagem: Hello everybody out there using minix - I'm doing a (free) operating system (just a hobby, won't be big and professional like gnu) for 386(486) AT clones. This has been brewing since april, and is starting to get ready. I'd like any feedback on things people like/dislike in minix, as my OS resembles it somewhat (same physical layout of the file-system (due to practical reasons) among other things). I've currently ported bash(1.08) and gcc(1.40), and things seem to work. This implies that I'll get something practical within a few months, and I'd like to know what features most people would want. Any suggestions are welcome, but I won't promise I'll implement them :-) Linus ( torvalds@kruuna.helsinki.fi ) PS. Yes - it's free of any minix code, and it has a multi-threaded fs. It is NOT portable (uses 386 task switching etc), and it probably never will support anything other than AT-harddisks, as that's all I have :-(. \u2014\u2009Linus Torvalds https://en.wikipedia.org/wiki/History_of_Linux","title":"Primeira vers\u00e3o"},{"location":"Historia-linux/#gnu","text":"Um dos fatores que deu for\u00e7a para o sistema operacional rec\u00e9m lan\u00e7ado foi que ele foi desenvolvido utilizando ferramentas de outro projeto importante o GNU, que estava ganhando for\u00e7a na mesma \u00e9poca e fornecia uma s\u00e9rie de programas gratuitos para a comunidade, ele tamb\u00e9m introduziu o conceito de \"Software Livre\" e licen\u00e7a open source. Conduzido por Richard Stallman no MIT. https://en.wikipedia.org/wiki/GNU_Project https://pt.wikipedia.org/wiki/Richard_Matthew_Stallman O Linux como conhecemos hoje em dia \u00e9 tamb\u00e9m conhecido como Linux/GNU, pois faz uso extensivo dos dois projetos (compiladores, editores de texto, ...). Inclusive, a vers\u00e3o 0.99 o linux j\u00e1 foi publicado utilizando a licen\u00e7a GNU GPL.","title":"GNU"},{"location":"Historia-linux/#gpl","text":"A licen\u00e7a GNU GPL (GNU General Public License) possui os seguintes princ\u00edpios: A liberdade de executar o programa, para qualquer prop\u00f3sito (liberdade n\u00ba 0) A liberdade de estudar como o programa funciona e adapt\u00e1-lo \u00e0s suas necessidades (liberdade n\u00ba 1). O acesso ao c\u00f3digo-fonte \u00e9 um pr\u00e9-requisito para esta liberdade. A liberdade de redistribuir c\u00f3pias de modo que voc\u00ea possa ajudar ao seu pr\u00f3ximo (liberdade n\u00ba 2). A liberdade de aperfei\u00e7oar o programa e liberar os seus aperfei\u00e7oamentos, de modo que toda a comunidade beneficie deles (liberdade n\u00ba 3). O acesso ao c\u00f3digo-fonte \u00e9 um pr\u00e9-requisito para esta liberdade. https://pt.wikipedia.org/wiki/GNU_General_Public_License N\u00e3o podemos confundir software livre com software gratuito (como o google por exemplo).","title":"GPL"},{"location":"Historia-linux/#mascote-tux","text":"Em 1996 Linux anuncia o novo mascote para o Linux, um pinguim! Torvalds faz muitos mergulhos como hoobie, e diz ele que foi mordido por um pinguim na visita a um aqu\u00e1rio. https://duckduckgo.com/?q=linux+mascote&t=canonical&iax=images&ia=images&iai=http%3A%2F%2F4.bp.blogspot.com%2F-c8uUx6EnHv8%2FVo7_P8mUt4I%2FAAAAAAAACEw%2FeKA-7sjxGak%2Fs400%2FTux%252Bmascote%252Bdo%252Blinux.png","title":"Mascote - Tux"},{"location":"Historia-linux/#distribuicoes","text":"No come\u00e7o os softwares n\u00e3o eram distribu\u00eddos junto com o Linux, o desenvolvedor tinha que instalar e compilar tudo o que queria utilizar, e a coisas eram dispersas. Foi ai que surgiu a ideia de distribuir um pacote com o kernel do linux + alguns programas + configura\u00e7\u00f5es b\u00e1sicas. A distribui\u00e7\u00e3o mais antiga e ainda em 'uso' \u00e9 o SlackWare. https://www.cyberciti.biz/tips/wp-content/uploads/2007/06/44218-linuxdistrotimeline-7.2.png http://www.slackware.com/","title":"Distribui\u00e7\u00f5es"},{"location":"Historia-linux/#ubuntu","text":"Ubuntu foi criado em 2004 pelo empres\u00e1rio sul africano Mark Shuttleworth com o foco de disponibilizar uma distribui\u00e7\u00e3o para todos os usu\u00e1rios (desktop + server) e n\u00e3o apenas com foco empresarial como as demais distribui\u00e7\u00f5es. https://en.wikipedia.org/wiki/Mark_Shuttleworth https://en.wikipedia.org/wiki/Ubuntu O Ubuntu \u00e9 baseado em outra distribui\u00e7\u00e3o, o Debian, que teve sua origem muito antes em 1993. Os pacotes .deb foram criados por essa distro.","title":"Ubuntu"},{"location":"Historia-linux/#distro-hopping","text":"Achar uma distribui\u00e7\u00e3o que te agrade \u00e9 muito dif\u00edcil, o distro hopping \u00e9 o ato de ficar mudando de distribui\u00e7\u00e3o toda hora, instalando tudo novamente e ent\u00e3o, mudando de distro novamente. https://www.quora.com/What-is-distro-hopping-as-regards-Linux","title":"distro hopping"},{"location":"Historia-linux/#linux-distro-ambiente-de-desktop","text":"O linux em si \u00e9 apenas o kernel, o core do sistema operacional, por\u00e9m hoje me dia poucas pessoas utilizam apenas o bash no desktop. Muitas vezes o Linux \u00e9 associado apenas a interface gr\u00e1fica, que alias tem para todos os gostos! https://pt.wikipedia.org/wiki/Ambiente_de_desktop (padr\u00e3o atual do ubuntu) https://www.gnome.org/ https://kde.org/ https://ubuntubudgie.org/ (pantheon) https://elementary.io/ https://en.wikipedia.org/wiki/LXDE https://linuxmint.com/","title":"linux != Distro != Ambiente de desktop"},{"location":"Historia-linux/#linux-atualmente","text":"https://www.youtube.com/watch?v=yVpbFMhOAwE https://www.youtube.com/watch?v=SOXeXauRAm0&list=PLbzoR-pLrL6rsb1bc3En9zaEor9S0gyIp https://www.youtube.com/watch?v=rSjgVeNQrN0&list=PLbzoR-pLrL6rsb1bc3En9zaEor9S0gyIp&index=2","title":"Linux atualmente"},{"location":"Historia-linux/#git","text":"At\u00e9 2005 o linux utilizava um sistema privado de gerenciamento de vers\u00e3o privado, Linus tirou uma semana de f\u00e9rias e nasceu o git!","title":"git?"},{"location":"J-VMtranslator-Projeto/","text":"I - VM Translator \u00b6 Entrega Nesse projeto iremos criar o programa VM translator que \u00e9 respons\u00e1vel por traduzir os c\u00f3digos escrito em linguagem VM de pilha para a linguagem assembly. Instru\u00e7\u00f5es \u00b6 As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e1 no lab 18 . M\u00f3dulos a serem implementados \u00b6 Apenas o Code.java . O projeto no total possui 5 m\u00f3dulos, sendo que o m\u00f3dulo VMTranslator.java , VMtranslate.java , Parser.java e Error.java j\u00e1 est\u00e3o foram entregues implementados. Os m\u00f3dulos est\u00e3o listados de maneira Top - Down VMTranslator Arquivo : VMTranslator.java Descri\u00e7\u00e3o : Main do projeto. Recebe como par\u00e2metro o nome do arquivo .vm (ou diret\u00f3rio) e o nome do arquivo bin\u00e1rio assembly ( .nasm ) a ser escrito, passa essas informa\u00e7\u00f5es para a classe VMtranslate. Depend\u00eancias : VMtranslate.java VMtranslate Arquivo : VMtranslate.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo assembly, ela que efetivamente faz a varredura do arquivo .vm de entrada e escreve o arquivo .nasm de sa\u00edda, gerando a tradu\u00e7\u00e3o vm -> nasm. Depend\u00eancias : Code.java , Parser.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz comandos da linguagem vm para os comandos em nasm que a executam. Depend\u00eancias : None Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem vm, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none Sugest\u00e3o de implementa\u00e7\u00e3o (partes) \u00b6 Sugerimos que o VMTranslator seja implementado em duas partes, a primeira implementa somente o Parser.java e opera\u00e7\u00f5es aritm\u00e9ticas e push/pop . A segunda parte faz a implementa\u00e7\u00e3o de fun\u00e7\u00f5es, goto e chamada de fun\u00e7\u00f5es. Parte 1 - Conceito C \u00b6 Code.writeArithmetic() Code.writePushPop() Parte 2 - Conceito B \u00b6 Code.writeGoto() Code.writeIf() Parte 3 - Conceito A \u00b6 Code.writeCall() Code.writeReturn() Code.writeFunction() Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito I - Menos da metade dos m\u00f3dulos funcionando D - writeArithmetic OU writePushPop C - writeArithmetic E writePushPop B - writeLabel, writeGoto, writeIf A - writeCall, writeReturn, writeFunction Para testar \u00b6 A seguir os testes que devem passar para cada nota : C \u00b6 SimpleAdd SimpleNeg SimpleSub SimpleEq SimpleGt SimpleLt SimpleAnd SimpleOr SimplePushConst SimplePushTemp SimplePushLocal SimplePushArg SimplePushThis SimplePushThat SimplePopTemp SimplePopLocal SimplePopThat SimplePopThis SimplePushAdd SimplePopPointer StackTest (opcional) B \u00b6 BasicLoop A \u00b6 SimpleFunction StaticsTest Mult 1a-Add 1b-Add 2a-Calculadora 2b-Calculadora 2c-Calculadora 2d-Calculadora SimpleGoto SimpleIfGoto","title":"I - VM Translator"},{"location":"J-VMtranslator-Projeto/#i-vm-translator","text":"Entrega Nesse projeto iremos criar o programa VM translator que \u00e9 respons\u00e1vel por traduzir os c\u00f3digos escrito em linguagem VM de pilha para a linguagem assembly.","title":"I - VM Translator"},{"location":"J-VMtranslator-Projeto/#instrucoes","text":"As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e1 no lab 18 .","title":"Instru\u00e7\u00f5es"},{"location":"J-VMtranslator-Projeto/#modulos-a-serem-implementados","text":"Apenas o Code.java . O projeto no total possui 5 m\u00f3dulos, sendo que o m\u00f3dulo VMTranslator.java , VMtranslate.java , Parser.java e Error.java j\u00e1 est\u00e3o foram entregues implementados. Os m\u00f3dulos est\u00e3o listados de maneira Top - Down VMTranslator Arquivo : VMTranslator.java Descri\u00e7\u00e3o : Main do projeto. Recebe como par\u00e2metro o nome do arquivo .vm (ou diret\u00f3rio) e o nome do arquivo bin\u00e1rio assembly ( .nasm ) a ser escrito, passa essas informa\u00e7\u00f5es para a classe VMtranslate. Depend\u00eancias : VMtranslate.java VMtranslate Arquivo : VMtranslate.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo assembly, ela que efetivamente faz a varredura do arquivo .vm de entrada e escreve o arquivo .nasm de sa\u00edda, gerando a tradu\u00e7\u00e3o vm -> nasm. Depend\u00eancias : Code.java , Parser.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz comandos da linguagem vm para os comandos em nasm que a executam. Depend\u00eancias : None Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem vm, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none","title":"M\u00f3dulos a serem implementados"},{"location":"J-VMtranslator-Projeto/#sugestao-de-implementacao-partes","text":"Sugerimos que o VMTranslator seja implementado em duas partes, a primeira implementa somente o Parser.java e opera\u00e7\u00f5es aritm\u00e9ticas e push/pop . A segunda parte faz a implementa\u00e7\u00e3o de fun\u00e7\u00f5es, goto e chamada de fun\u00e7\u00f5es.","title":"Sugest\u00e3o de implementa\u00e7\u00e3o (partes)"},{"location":"J-VMtranslator-Projeto/#parte-1-conceito-c","text":"Code.writeArithmetic() Code.writePushPop()","title":"Parte 1 - Conceito C"},{"location":"J-VMtranslator-Projeto/#parte-2-conceito-b","text":"Code.writeGoto() Code.writeIf()","title":"Parte 2 - Conceito B"},{"location":"J-VMtranslator-Projeto/#parte-3-conceito-a","text":"Code.writeCall() Code.writeReturn() Code.writeFunction()","title":"Parte 3 - Conceito A"},{"location":"J-VMtranslator-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"J-VMtranslator-Projeto/#projeto","text":"Conceito I - Menos da metade dos m\u00f3dulos funcionando D - writeArithmetic OU writePushPop C - writeArithmetic E writePushPop B - writeLabel, writeGoto, writeIf A - writeCall, writeReturn, writeFunction","title":"Projeto"},{"location":"J-VMtranslator-Projeto/#para-testar","text":"A seguir os testes que devem passar para cada nota :","title":"Para testar"},{"location":"J-VMtranslator-Projeto/#c","text":"SimpleAdd SimpleNeg SimpleSub SimpleEq SimpleGt SimpleLt SimpleAnd SimpleOr SimplePushConst SimplePushTemp SimplePushLocal SimplePushArg SimplePushThis SimplePushThat SimplePopTemp SimplePopLocal SimplePopThat SimplePopThis SimplePushAdd SimplePopPointer StackTest (opcional)","title":"C"},{"location":"J-VMtranslator-Projeto/#b","text":"BasicLoop","title":"B"},{"location":"J-VMtranslator-Projeto/#a","text":"SimpleFunction StaticsTest Mult 1a-Add 1b-Add 2a-Calculadora 2b-Calculadora 2c-Calculadora 2d-Calculadora SimpleGoto SimpleIfGoto","title":"A"},{"location":"J-VMtranslator-memoria/","text":"Fun\u00e7\u00e3o \u00b6 Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o. O ARG indica em qual endere\u00e7o da stack os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 usado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais da fun\u00e7\u00e3o. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9: Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o primeiro argumento colocado na stack \u00e9 o de index 0 Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar as vari\u00e1veis locais Atualiza os ponteiros: SP, LCL, ARG, THIS e THAT O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o). Para isso \u00e9 salvo na pilha, NA ORDEM A SEGUIR: Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o) LCL - Local \u00b6 Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Peguemos como exemplo uma fun\u00e7\u00e3o em java : void example(int a, int b){ int aux0; int aux1; aux0 = a; aux1 = b; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais: aux0 e aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis ( aux0 , aux1 ) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir : O exemplo em java anterior seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira: function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n endere\u00e7o local n = LCL + n ARG - Argumento \u00b6 O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Os ARG s\u00e3o salvos na pr\u00f3pria pilha, antes da chamada da fun\u00e7\u00e3o: pilha comando VM endere\u00e7os -------------------------------------------- 12 | call mult 2 | 12 <- ARG 13 | | 13 SP -> | |----\\ | | |----/ | Exemplo Stack chamada de fun\u00e7\u00e3o \u00b6 258 : SP 265 : SP 257 : SP 333 : LCL 263 : LCL 333 : LCL 444 : ARG call mult 2 256 : ARG return 444 : ARG 555 : THIS |----\\ 555 : THIS |----\\ 555 : THIS 666 : THAT |----/ 666 : THAT |----/ 666 : THAT ~~~~~~~~~~~~ ~~~~~~~~~~~ ~~~~~~~~~~~~ 8 : 256 8 : 256 <- LCL 32 : 256 4 : 257 4 : 257 4 : 257 <- SP 0 : 258 <- SP 256 : 258 : RETURN 0 : 258 333 : 259 : LCL 444 : 260 : ARG 555 : 261 : THIS 666 : 262 : THAT 0 : 263 <- LCL 0 : 264 0 : 265 <- SP Static variables \u00b6 \u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static : O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/ HEAP \u00b6 O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria. This \u00b6 This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm That \u00b6 O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir : M\u00e9todo objetoCeleste : void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal : void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, inclu\u00edmos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM ? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chama da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"J VMtranslator memoria"},{"location":"J-VMtranslator-memoria/#funcao","text":"Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o. O ARG indica em qual endere\u00e7o da stack os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 usado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais da fun\u00e7\u00e3o. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9: Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o primeiro argumento colocado na stack \u00e9 o de index 0 Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar as vari\u00e1veis locais Atualiza os ponteiros: SP, LCL, ARG, THIS e THAT O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o). Para isso \u00e9 salvo na pilha, NA ORDEM A SEGUIR: Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o)","title":"Fun\u00e7\u00e3o"},{"location":"J-VMtranslator-memoria/#lcl-local","text":"Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Peguemos como exemplo uma fun\u00e7\u00e3o em java : void example(int a, int b){ int aux0; int aux1; aux0 = a; aux1 = b; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais: aux0 e aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis ( aux0 , aux1 ) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir : O exemplo em java anterior seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira: function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n endere\u00e7o local n = LCL + n","title":"LCL - Local"},{"location":"J-VMtranslator-memoria/#arg-argumento","text":"O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Os ARG s\u00e3o salvos na pr\u00f3pria pilha, antes da chamada da fun\u00e7\u00e3o: pilha comando VM endere\u00e7os -------------------------------------------- 12 | call mult 2 | 12 <- ARG 13 | | 13 SP -> | |----\\ | | |----/ |","title":"ARG - Argumento"},{"location":"J-VMtranslator-memoria/#exemplo-stack-chamada-de-funcao","text":"258 : SP 265 : SP 257 : SP 333 : LCL 263 : LCL 333 : LCL 444 : ARG call mult 2 256 : ARG return 444 : ARG 555 : THIS |----\\ 555 : THIS |----\\ 555 : THIS 666 : THAT |----/ 666 : THAT |----/ 666 : THAT ~~~~~~~~~~~~ ~~~~~~~~~~~ ~~~~~~~~~~~~ 8 : 256 8 : 256 <- LCL 32 : 256 4 : 257 4 : 257 4 : 257 <- SP 0 : 258 <- SP 256 : 258 : RETURN 0 : 258 333 : 259 : LCL 444 : 260 : ARG 555 : 261 : THIS 666 : 262 : THAT 0 : 263 <- LCL 0 : 264 0 : 265 <- SP","title":"Exemplo Stack chamada de fun\u00e7\u00e3o"},{"location":"J-VMtranslator-memoria/#static-variables","text":"\u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static : O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/","title":"Static variables"},{"location":"J-VMtranslator-memoria/#heap","text":"O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria.","title":"HEAP"},{"location":"J-VMtranslator-memoria/#this","text":"This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm","title":"This"},{"location":"J-VMtranslator-memoria/#that","text":"O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir : M\u00e9todo objetoCeleste : void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal : void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, inclu\u00edmos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM ? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chama da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"That"},{"location":"LogiComb-Lab-1/","text":"Lab 4: FPGA - VHDL \u00b6 Material de estudos https://insper.github.io/Z01.1/Teoria-Componentes/ https://insper.github.io/Z01.1/VHDL-basico/ https://insper.github.io/Z01.1/VHDL-Combinacional/ Trabalhando Usar o Linux fornecido. Esse laborat\u00f3rio \u00e9 para ser realizado individualmente. Ficar conectado no canal do grupo para discutir com os colegas. Este laborat\u00f3rio \u00e9 introdut\u00f3rio para o desenvolvimento do projeto ( B-L\u00f3gica-Combinacional ), onde iremos criar componentes de hardware que ser\u00e3o os alicerces do nosso computador. Primeiro precisamos praticar um pouco de VHDL e entender a ferramenta e o fluxo de compila\u00e7\u00e3o, teste e programa\u00e7\u00e3o (Quartus). Ap\u00f3s essa etapa, iremos come\u00e7ar o desenvolvimento do projeto, programando os m\u00f3dulos que vir\u00e3o a ser utilizados no computador Z01 (pr\u00f3ximo lab). Come\u00e7ando laborat\u00f3rio! Antes de come\u00e7ar \u00b6 Executar os comandos: $ sudo apt install ghdl gtkwave $ pip install cocotb para instalar o simulador GHDL e a library cocotb para os testes a serem realizados atrav\u00e9s de script. Progress Cheguei aqui! Entendendo a estrutura de pastas dos projetos \u00b6 A pasta do projeto B-LogicaCombinacional no reposit\u00f3rio Z01 possui a seguinte estrutura (assim como todos os demais projetos): /B-LogicaCombinacional testeLogicaCombinacional.py /Quartus /src *.vhd config_testes.txt /testes *.vhd Quartus : Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd Serve para programar a FPGA *.py : Scripts em python automatiza a execu\u00e7\u00e3o dos testes src/*.vhd : Arquivos VHDL que ser\u00e3o implementado pelo grupo config_testes.txt : Configura\u00e7\u00e3o dos testes testes/*.vhd : Arquivos VHDL que realizam teste l\u00f3gico nos arquivos do rtl Abrindo o Quartus \u00b6 Abra o software do Quartus e clique em File Open Project escolha o projeto localizado na pasta B-LogicaCombinacional/Quartus . O arquivo que o Quartus ir\u00e1 reconhecer \u00e9 o: DE0_CV_Default.qpf como no gif a seguir: Tip Se n\u00e3o encontrar o software na barra de tarefas abra o terminal e escreva quartus enter . Abra o arquivo TopLevel.vhd como demonstrado no gif anterior, este arquivo \u00e9 o que chamamos de top level (pode-se fazer uma analogia com o main de um c\u00f3digo), ele ser\u00e1 o primeiro a ser executado na compila\u00e7\u00e3o e utilizar\u00e1 os demais m\u00f3dulos do sistema. Progress Cheguei aqui! Compilando o c\u00f3digo \u00b6 Note O c\u00f3digo original dispon\u00edvel n\u00e3o realiza nenhuma l\u00f3gica, repare que sua arquitetura est\u00e1 vazia! Para compilarmos esse c\u00f3digo VHDL basta irmos em: Processing Start Compilation . A ferramenta ir\u00e1 \"realizar\" o c\u00f3digo, ou seja, interpretar e torna-lo um hardware. Progress Cheguei aqui! RTL View \u00b6 Podemos gerar a vis\u00e3o RTL do c\u00f3digo em vhdl, esse diagrama \u00e9 a interpreta\u00e7\u00e3o do c\u00f3digo em VHDL pelo compilador e como ele seria supostamente implementando em hardware. Para isso: Tools Netlist Viewers RTL viewer Ele ir\u00e1 gerar o diagrama a seguir: Onde podemos analisar que n\u00e3o existe nenhuma l\u00f3gica que relaciona entrada com sa\u00edda. RTL O RTL aqui tem outro significado de quando foi utilizado com transistores, aqui \u00e9 Register-transfer level e nos transistores \u00e9 Resistor\u2013transistor logic . Info SW = Switchs = Chaves da placa Tip Iremos utilizar bastante o RTL, aprenda a gerar e a interpretar! Progress Cheguei aqui! Modificando o projeto \u00b6 Vamos modificar o arquivo toplevel.vhd do projeto para que o bit 0 do vetor LEDR seja igual ao bit 0 da chave SW , a arquitetura deve ficar como a seguir: --------------- -- implementacao --------------- begin LEDR ( 0 ) <= SW ( 0 ); end rtl ; Tarefa Edite o toplevel Compile Gere o RTL Viewer novamente O resultado deve ser o seguinte: Onde o valor do LEDR0 ser\u00e1 o pr\u00f3prio valor de entrada chave SW0 . \"Programando a FPGA\" \u00b6 Para programar a FPGA voc\u00ea deve: Conectar a placa via USB (n\u00e3o precisa da fonte) Ligar a placa (bot\u00e3o vermelho) Verificar se a chave SW10 est\u00e1 em 'run' No quartus v\u00e1 em Tools Programmer . Ele deve abrir uma nova interface: Mexa na chave SW0 e note que o LED ir\u00e1 acender conforme a chave \u00e9 colocada na posi\u00e7\u00e3o on. Progress Cheguei aqui! Exerc\u00edcios \u00b6 Para cada desafio proposto a seguir, verifique se o RTL corresponde a l\u00f3gica que deseja implementar. Compile Verifique o RTL Programe a FPGA Tarefa Fa\u00e7a a sa\u00edda LEDR(0) ser o inverso da entrada SW(0) Progress Cheguei aqui! Tarefa Fa\u00e7a a sa\u00edda LEDR(0) ser a entrada SW(0) ou SW(1) Progress Cheguei aqui! Tarefa Fa\u00e7a: LEDR(0) ser a entrada SW(0) ou SW(1) LEDR(1) ser a chave SW(1) Progress Cheguei aqui! Tarefa Fa\u00e7a TODOs os LEDs acenderem quando a seguinte combina\u00e7\u00e3o de entrada for: SW9 SW0 1 0 0 1 1 0 1 0 1 0 Progress Cheguei aqui! Tarefa Escreva um c\u00f3digo VHDL para implementar o circuito a seguir: Sendo: X: chave 0 (SW(0)) y: chave 1 (SW(1)) z: chave 2 (SW(2)) Dica: encontre a equa\u00e7\u00e3o, implemente em VHDL. Progress Cheguei aqui! Sete segmentos \u00b6 Note que na nossa FPGA possu\u00edmos seis displays de sete segmentos . Para termos acesso a esses displays, basta modificar a entidade do projeto para: entity TopLevel is port ( SW : in std_logic_vector ( 9 downto 0 ); HEX0 : out std_logic_vector ( 6 downto 0 ); -- 7seg0 LEDR : out std_logic_vector ( 9 downto 0 ) ); end entity ; Agora com um display de 7 segmentos mapeado como sa\u00edda ( out ) na nossa entity podemos acionar cada led do display como descrito no manual da placa (isso s\u00f3 \u00e9 poss\u00edvel pois o projeto j\u00e1 foi configurado corretamente antes pelo seu professor). Tip Para acender um segmento \u00e9 necess\u00e1rio colocar 0 e para apagar 1 . Tarefa Modifique a entity para possuir a nova sa\u00edda Fa\u00e7a aparecer o n\u00famero 5 no HEX0 .","title":"Lab 4: FPGA - VHDL"},{"location":"LogiComb-Lab-1/#lab-4-fpga-vhdl","text":"Material de estudos https://insper.github.io/Z01.1/Teoria-Componentes/ https://insper.github.io/Z01.1/VHDL-basico/ https://insper.github.io/Z01.1/VHDL-Combinacional/ Trabalhando Usar o Linux fornecido. Esse laborat\u00f3rio \u00e9 para ser realizado individualmente. Ficar conectado no canal do grupo para discutir com os colegas. Este laborat\u00f3rio \u00e9 introdut\u00f3rio para o desenvolvimento do projeto ( B-L\u00f3gica-Combinacional ), onde iremos criar componentes de hardware que ser\u00e3o os alicerces do nosso computador. Primeiro precisamos praticar um pouco de VHDL e entender a ferramenta e o fluxo de compila\u00e7\u00e3o, teste e programa\u00e7\u00e3o (Quartus). Ap\u00f3s essa etapa, iremos come\u00e7ar o desenvolvimento do projeto, programando os m\u00f3dulos que vir\u00e3o a ser utilizados no computador Z01 (pr\u00f3ximo lab). Come\u00e7ando laborat\u00f3rio!","title":"Lab 4: FPGA - VHDL"},{"location":"LogiComb-Lab-1/#antes-de-comecar","text":"Executar os comandos: $ sudo apt install ghdl gtkwave $ pip install cocotb para instalar o simulador GHDL e a library cocotb para os testes a serem realizados atrav\u00e9s de script. Progress Cheguei aqui!","title":"Antes de come\u00e7ar"},{"location":"LogiComb-Lab-1/#entendendo-a-estrutura-de-pastas-dos-projetos","text":"A pasta do projeto B-LogicaCombinacional no reposit\u00f3rio Z01 possui a seguinte estrutura (assim como todos os demais projetos): /B-LogicaCombinacional testeLogicaCombinacional.py /Quartus /src *.vhd config_testes.txt /testes *.vhd Quartus : Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd Serve para programar a FPGA *.py : Scripts em python automatiza a execu\u00e7\u00e3o dos testes src/*.vhd : Arquivos VHDL que ser\u00e3o implementado pelo grupo config_testes.txt : Configura\u00e7\u00e3o dos testes testes/*.vhd : Arquivos VHDL que realizam teste l\u00f3gico nos arquivos do rtl","title":"Entendendo a estrutura de pastas dos projetos"},{"location":"LogiComb-Lab-1/#abrindo-o-quartus","text":"Abra o software do Quartus e clique em File Open Project escolha o projeto localizado na pasta B-LogicaCombinacional/Quartus . O arquivo que o Quartus ir\u00e1 reconhecer \u00e9 o: DE0_CV_Default.qpf como no gif a seguir: Tip Se n\u00e3o encontrar o software na barra de tarefas abra o terminal e escreva quartus enter . Abra o arquivo TopLevel.vhd como demonstrado no gif anterior, este arquivo \u00e9 o que chamamos de top level (pode-se fazer uma analogia com o main de um c\u00f3digo), ele ser\u00e1 o primeiro a ser executado na compila\u00e7\u00e3o e utilizar\u00e1 os demais m\u00f3dulos do sistema. Progress Cheguei aqui!","title":"Abrindo o Quartus"},{"location":"LogiComb-Lab-1/#compilando-o-codigo","text":"Note O c\u00f3digo original dispon\u00edvel n\u00e3o realiza nenhuma l\u00f3gica, repare que sua arquitetura est\u00e1 vazia! Para compilarmos esse c\u00f3digo VHDL basta irmos em: Processing Start Compilation . A ferramenta ir\u00e1 \"realizar\" o c\u00f3digo, ou seja, interpretar e torna-lo um hardware. Progress Cheguei aqui!","title":"Compilando o c\u00f3digo"},{"location":"LogiComb-Lab-1/#rtl-view","text":"Podemos gerar a vis\u00e3o RTL do c\u00f3digo em vhdl, esse diagrama \u00e9 a interpreta\u00e7\u00e3o do c\u00f3digo em VHDL pelo compilador e como ele seria supostamente implementando em hardware. Para isso: Tools Netlist Viewers RTL viewer Ele ir\u00e1 gerar o diagrama a seguir: Onde podemos analisar que n\u00e3o existe nenhuma l\u00f3gica que relaciona entrada com sa\u00edda. RTL O RTL aqui tem outro significado de quando foi utilizado com transistores, aqui \u00e9 Register-transfer level e nos transistores \u00e9 Resistor\u2013transistor logic . Info SW = Switchs = Chaves da placa Tip Iremos utilizar bastante o RTL, aprenda a gerar e a interpretar! Progress Cheguei aqui!","title":"RTL View"},{"location":"LogiComb-Lab-1/#modificando-o-projeto","text":"Vamos modificar o arquivo toplevel.vhd do projeto para que o bit 0 do vetor LEDR seja igual ao bit 0 da chave SW , a arquitetura deve ficar como a seguir: --------------- -- implementacao --------------- begin LEDR ( 0 ) <= SW ( 0 ); end rtl ; Tarefa Edite o toplevel Compile Gere o RTL Viewer novamente O resultado deve ser o seguinte: Onde o valor do LEDR0 ser\u00e1 o pr\u00f3prio valor de entrada chave SW0 .","title":"Modificando o projeto"},{"location":"LogiComb-Lab-1/#programando-a-fpga","text":"Para programar a FPGA voc\u00ea deve: Conectar a placa via USB (n\u00e3o precisa da fonte) Ligar a placa (bot\u00e3o vermelho) Verificar se a chave SW10 est\u00e1 em 'run' No quartus v\u00e1 em Tools Programmer . Ele deve abrir uma nova interface: Mexa na chave SW0 e note que o LED ir\u00e1 acender conforme a chave \u00e9 colocada na posi\u00e7\u00e3o on. Progress Cheguei aqui!","title":"\"Programando a FPGA\""},{"location":"LogiComb-Lab-1/#exercicios","text":"Para cada desafio proposto a seguir, verifique se o RTL corresponde a l\u00f3gica que deseja implementar. Compile Verifique o RTL Programe a FPGA Tarefa Fa\u00e7a a sa\u00edda LEDR(0) ser o inverso da entrada SW(0) Progress Cheguei aqui! Tarefa Fa\u00e7a a sa\u00edda LEDR(0) ser a entrada SW(0) ou SW(1) Progress Cheguei aqui! Tarefa Fa\u00e7a: LEDR(0) ser a entrada SW(0) ou SW(1) LEDR(1) ser a chave SW(1) Progress Cheguei aqui! Tarefa Fa\u00e7a TODOs os LEDs acenderem quando a seguinte combina\u00e7\u00e3o de entrada for: SW9 SW0 1 0 0 1 1 0 1 0 1 0 Progress Cheguei aqui! Tarefa Escreva um c\u00f3digo VHDL para implementar o circuito a seguir: Sendo: X: chave 0 (SW(0)) y: chave 1 (SW(1)) z: chave 2 (SW(2)) Dica: encontre a equa\u00e7\u00e3o, implemente em VHDL. Progress Cheguei aqui!","title":"Exerc\u00edcios"},{"location":"LogiComb-Lab-1/#sete-segmentos","text":"Note que na nossa FPGA possu\u00edmos seis displays de sete segmentos . Para termos acesso a esses displays, basta modificar a entidade do projeto para: entity TopLevel is port ( SW : in std_logic_vector ( 9 downto 0 ); HEX0 : out std_logic_vector ( 6 downto 0 ); -- 7seg0 LEDR : out std_logic_vector ( 9 downto 0 ) ); end entity ; Agora com um display de 7 segmentos mapeado como sa\u00edda ( out ) na nossa entity podemos acionar cada led do display como descrito no manual da placa (isso s\u00f3 \u00e9 poss\u00edvel pois o projeto j\u00e1 foi configurado corretamente antes pelo seu professor). Tip Para acender um segmento \u00e9 necess\u00e1rio colocar 0 e para apagar 1 . Tarefa Modifique a entity para possuir a nova sa\u00edda Fa\u00e7a aparecer o n\u00famero 5 no HEX0 .","title":"Sete segmentos"},{"location":"LogiComb-Lab-2/","text":"Lab 5: L\u00f3gica Combinacional \u00b6 Individual Esse laborat\u00f3rio \u00e9 para ser realizado individualmente. Esse laborat\u00f3rio introduz o modelo de desenvolvimento baseado em testes que ser\u00e1 utilizado em todos os projetos. Progress Come\u00e7ando... or16.vhd \u00b6 Iremos trabalhar implementando o m\u00f3dulo or16 que \u00e9 uma parte do projeto B. Para isso devemos editar o arquivo de configura\u00e7\u00e3o Projetos/B-LogicaCombinacional/config_testes.txt descomentando o m\u00f3dulo Or16.vhd : ###################################### # Rafael.Corsi @ Insper.edu.br # # Elementos de Sistemas # # # # Arquivos de teste do projeto B # # - Para incluir o teste basta # # descomentar a linha # # # ###################################### nand . vhd Or16 . vhd #Nor8Way.vhd #And16.vhd #Not16.vhd #Or8Way.vhd #DMux2Way.vhd #DMux4Way.vhd #DMux8Way.vhd #Mux2Way.vhd #Mux4Way.vhd #Mux16.vhd #Mux4Way16.vhd #Mux8Way.vhd #Mux8Way16.vhd Note Vamos ter dois m\u00f3dulos no teste: nand.vhd e o Or16.vhd Abra o terminal na pasta B-Logica-Combinacional/ e execute o script python testeLogicaCombinacional.py : $ ./testeLogicaCombinacional.py O mesmo ir\u00e1 executar a compila\u00e7\u00e3o dos arquivos src/*.vhd e realizar testes unit\u00e1rios em cada um desses m\u00f3dulos, como os m\u00f3dulos n\u00e3o est\u00e3o implementados e como estamos for\u00e7ando o teste do or16 devemos ter um erro nesse m\u00f3dulo. Progress Cheguei aqui! Esse erro acontece pois o m\u00f3dulo n\u00e3o possui nenhuma implementa\u00e7\u00e3o: -- Or16.vhd library IEEE ; use IEEE.STD_LOGIC_1164. ALL ; entity Or16 is port ( a : in STD_LOGIC_VECTOR ( 15 downto 0 ); b : in STD_LOGIC_VECTOR ( 15 downto 0 ); q : out STD_LOGIC_VECTOR ( 15 downto 0 )); end entity ; architecture arch of Or16 is begin end architecture ; Vamos agora editar esse arquivo para realizar sua implementa\u00e7\u00e3o. Esse m\u00f3dulo deve realizar uma OR entre as entras a e b e colocar o resultado na sa\u00edda q , para isso insira a seguinte linha no arquivo q <= a or b ; Teste novamente ( ./testeLogicaCombinacional.py ) agora deve passar: Progress Cheguei aqui! Uma vez implementando, testado e validado, podemos fazer o commit e enviar para o reposit\u00f3rio do grupo esse novo branch. Essa modifica\u00e7\u00e3o deve ser salva em novo branch or16 . Dentro do terminal (na pasta do projeto B): $ git checkout -B or16-SEU-USER $ git commit -am \"funcionando e testado\" $ git push origin or16-SEU-USER Note trocar SEU-USER pelo seu usu\u00e1rio insper, para evitar conflito quando forem enviar para o git. Com o branch enviado ao github voc\u00ea deve gerar um pull-request para o mediador verificar e aprovar ou n\u00e3o a sua implementa\u00e7\u00e3o. Para o Mediador Como voc\u00eas est\u00e3o realizando isso individualmente, o mediador do projeto vai receber v\u00e1rios PRs desse branch, voc\u00ea s\u00f3 deve aceitar um, j\u00e1 que todos fizeram o mesmo. Progress Cheguei aqui! And16.vhd \u00b6 Agora voc\u00ea vai fazer o desenvolvimento do m\u00f3dulo And16.vhd . Esse componente recebe dois vetores de 16 bits ( a e b ) e realizada uma AND bit a bit ( q(0) = a(0) and b(0) .... ). Para implementar voc\u00ea deve seguir os passos a seguir: Abrir o arquivo de teste e descomentar o m\u00f3dulo And16.vhd Fazer a implementa\u00e7\u00e3o em vhdl Testar Criar uma branch Fazer um commit Enviar a implementa\u00e7\u00e3o Tip Esse vai ser o fluxo para quase todos os projetos que iremos realizar na disciplina. Progress Cheguei aqui! Mux2Way.vhd \u00b6 Teoria Para implementar esse m\u00f3dulo, leia a teoria em: VHDL/Combinacional . Fa\u00e7a a implementa\u00e7\u00e3o do Mux2Way.vhd , usando os mesmos passos anteriores. Progress Cheguei aqui! Pr\u00f3ximos passos \u00b6 Agora \u00e9 come\u00e7ar a trabalhar nos demais m\u00f3dulos do projeto, leia a descri\u00e7\u00e3o do Projeto B na p\u00e1gina de projetos. Scrum Master Voc\u00ea \u00e9 scrum? Ent\u00e3o tem v\u00e1rias tarefas pela frente! Acesse a p\u00e1gina Util -> Vixi! Sou scrum master e siga os passos l\u00e1!","title":"Lab 5: L\u00f3gica Combinacional"},{"location":"LogiComb-Lab-2/#lab-5-logica-combinacional","text":"Individual Esse laborat\u00f3rio \u00e9 para ser realizado individualmente. Esse laborat\u00f3rio introduz o modelo de desenvolvimento baseado em testes que ser\u00e1 utilizado em todos os projetos. Progress Come\u00e7ando...","title":"Lab 5: L\u00f3gica Combinacional"},{"location":"LogiComb-Lab-2/#or16vhd","text":"Iremos trabalhar implementando o m\u00f3dulo or16 que \u00e9 uma parte do projeto B. Para isso devemos editar o arquivo de configura\u00e7\u00e3o Projetos/B-LogicaCombinacional/config_testes.txt descomentando o m\u00f3dulo Or16.vhd : ###################################### # Rafael.Corsi @ Insper.edu.br # # Elementos de Sistemas # # # # Arquivos de teste do projeto B # # - Para incluir o teste basta # # descomentar a linha # # # ###################################### nand . vhd Or16 . vhd #Nor8Way.vhd #And16.vhd #Not16.vhd #Or8Way.vhd #DMux2Way.vhd #DMux4Way.vhd #DMux8Way.vhd #Mux2Way.vhd #Mux4Way.vhd #Mux16.vhd #Mux4Way16.vhd #Mux8Way.vhd #Mux8Way16.vhd Note Vamos ter dois m\u00f3dulos no teste: nand.vhd e o Or16.vhd Abra o terminal na pasta B-Logica-Combinacional/ e execute o script python testeLogicaCombinacional.py : $ ./testeLogicaCombinacional.py O mesmo ir\u00e1 executar a compila\u00e7\u00e3o dos arquivos src/*.vhd e realizar testes unit\u00e1rios em cada um desses m\u00f3dulos, como os m\u00f3dulos n\u00e3o est\u00e3o implementados e como estamos for\u00e7ando o teste do or16 devemos ter um erro nesse m\u00f3dulo. Progress Cheguei aqui! Esse erro acontece pois o m\u00f3dulo n\u00e3o possui nenhuma implementa\u00e7\u00e3o: -- Or16.vhd library IEEE ; use IEEE.STD_LOGIC_1164. ALL ; entity Or16 is port ( a : in STD_LOGIC_VECTOR ( 15 downto 0 ); b : in STD_LOGIC_VECTOR ( 15 downto 0 ); q : out STD_LOGIC_VECTOR ( 15 downto 0 )); end entity ; architecture arch of Or16 is begin end architecture ; Vamos agora editar esse arquivo para realizar sua implementa\u00e7\u00e3o. Esse m\u00f3dulo deve realizar uma OR entre as entras a e b e colocar o resultado na sa\u00edda q , para isso insira a seguinte linha no arquivo q <= a or b ; Teste novamente ( ./testeLogicaCombinacional.py ) agora deve passar: Progress Cheguei aqui! Uma vez implementando, testado e validado, podemos fazer o commit e enviar para o reposit\u00f3rio do grupo esse novo branch. Essa modifica\u00e7\u00e3o deve ser salva em novo branch or16 . Dentro do terminal (na pasta do projeto B): $ git checkout -B or16-SEU-USER $ git commit -am \"funcionando e testado\" $ git push origin or16-SEU-USER Note trocar SEU-USER pelo seu usu\u00e1rio insper, para evitar conflito quando forem enviar para o git. Com o branch enviado ao github voc\u00ea deve gerar um pull-request para o mediador verificar e aprovar ou n\u00e3o a sua implementa\u00e7\u00e3o. Para o Mediador Como voc\u00eas est\u00e3o realizando isso individualmente, o mediador do projeto vai receber v\u00e1rios PRs desse branch, voc\u00ea s\u00f3 deve aceitar um, j\u00e1 que todos fizeram o mesmo. Progress Cheguei aqui!","title":"or16.vhd"},{"location":"LogiComb-Lab-2/#and16vhd","text":"Agora voc\u00ea vai fazer o desenvolvimento do m\u00f3dulo And16.vhd . Esse componente recebe dois vetores de 16 bits ( a e b ) e realizada uma AND bit a bit ( q(0) = a(0) and b(0) .... ). Para implementar voc\u00ea deve seguir os passos a seguir: Abrir o arquivo de teste e descomentar o m\u00f3dulo And16.vhd Fazer a implementa\u00e7\u00e3o em vhdl Testar Criar uma branch Fazer um commit Enviar a implementa\u00e7\u00e3o Tip Esse vai ser o fluxo para quase todos os projetos que iremos realizar na disciplina. Progress Cheguei aqui!","title":"And16.vhd"},{"location":"LogiComb-Lab-2/#mux2wayvhd","text":"Teoria Para implementar esse m\u00f3dulo, leia a teoria em: VHDL/Combinacional . Fa\u00e7a a implementa\u00e7\u00e3o do Mux2Way.vhd , usando os mesmos passos anteriores. Progress Cheguei aqui!","title":"Mux2Way.vhd"},{"location":"LogiComb-Lab-2/#proximos-passos","text":"Agora \u00e9 come\u00e7ar a trabalhar nos demais m\u00f3dulos do projeto, leia a descri\u00e7\u00e3o do Projeto B na p\u00e1gina de projetos. Scrum Master Voc\u00ea \u00e9 scrum? Ent\u00e3o tem v\u00e1rias tarefas pela frente! Acesse a p\u00e1gina Util -> Vixi! Sou scrum master e siga os passos l\u00e1!","title":"Pr\u00f3ximos passos"},{"location":"LogiComb-Projeto/","text":"B - L\u00f3gica Combinacional \u00b6 Data da entrega Quinta - 15/09 Scrum Master Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Esse projeto tem como objetivo trabalhar com portas l\u00f3gicas e sistemas digitais combinacionais (sem um clock) em FPGA e VHDL. Os elementos l\u00f3gicos desenvolvidos nessa etapa ser\u00e3o utilizados como elementos b\u00e1sicos para a constru\u00e7\u00e3o do computador. Instru\u00e7\u00f5es \u00b6 O desenvolvimento ser\u00e1 na linguagem VHDL, o grupo deve se organizar para implementar todos os elementos propostos. O facilitador escolhido ser\u00e1 respons\u00e1vel pela completude e consist\u00eancia do branch master do grupo. Integrantes \u00b6 Tarefas devem ser criadas no Issues e atribu\u00eddas aos demais colegas. As tarefas devem ser resolvidas individualmente! Utilize a ajuda de seus colegas, mas resolva o que foi atribu\u00eddo a voc\u00eas, essa \u00e9 sua tarefa/ responsabilidade! Warning Este projeto \u00e9 para ser realizado por todos os integrantes do grupo em seus pr\u00f3prios computadores, quem n\u00e3o participar, n\u00e3o implementar os m\u00f3dulos que foram atribu\u00eddos, ou n\u00e3o realizar pull-request n\u00e3o ganhar\u00e1 nota de participa\u00e7\u00e3o individual. Controle de Tarefas e Reposit\u00f3rio \u00b6 Nas discuss\u00f5es com os outros colegas o scrum master deve definir os m\u00f3dulos que cada um do grupo ir\u00e1 desenvolver. Crie uma rotina para commits e pull-request. Sempre teste os m\u00f3dulos e verifique se est\u00e1 fazendo o esperado. Facilitador (Scrum Master) \u00b6 Fazer a atualiza\u00e7\u00e3o do fork com o upstream Organizar o github + issues + project Gerenciar o grupo (atribuir tarefas) Gerenciar os pull-requests Criar relat\u00f3rio da performance de cada um do grupo Entregar/Apresentar o projeto no final Desenvolvedores \u00b6 Realizar as tarefas atribuidas pelo scrum-master Ajudar na entrega final Testar os c\u00f3digos Realizar os pull-requests Arquivos \u00b6 A pasta cont\u00e9m dois diret\u00f3rios distintos : src/ e Quartus/ . O diret\u00f3rio src cont\u00e9m os arquivos fontes que dever\u00e3o ser editados para implementar o projeto. O diret\u00f3rio quartus/ cont\u00e9m o projeto que possibilitar\u00e1 compilar os m\u00f3dulos e testar em hardware. Entendendo o projeto \u00b6 A pasta do projeto B no reposit\u00f3rio Z01.1-proj possui a seguinte estrutura : /B-LogicaCombinacional testeLogicaCombinacional.py /Quartus /src *.vhd config_testes.txt /testes *.vhd Quartus : Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd Serve para programar a FPGA *.py : Scripts em python automatiza a execu\u00e7\u00e3o dos testes src/*.vhd : Arquivos VHDL que ser\u00e3o implementado pelo grupo config_testes.txt : Configura\u00e7\u00e3o dos testes testes/*.vhd : Arquivos VHDL que realizam teste l\u00f3gico nos arquivos do rtl Executando o script de teste \u00b6 Abra o terminal na pasta B-LogicaCombinacional e execute o script python localizado nessa pasta: $ ./testeLogicaCombinacional.py Note No exemplo de teste verificamos que aimplementa\u00e7\u00e3o da nand est\u00e1 errada. Entrega \u00b6 A entrega deve ser feita no ramo main do git. Implementar todos os m\u00f3dulos listados Todos os m\u00f3dulos devem passar nos testes Actions deve estar configurado e funcionando Implementar acionamento do diplay de 7 segmentos e demonstrar na FPGA Note Esses arquivos est\u00e3o localizados em B-LogicaCombinacional/src/ Tip Utilize o VScode para editar os arquivos em vhdl e valide a implementa\u00e7\u00e3o executando o script de testes. Deve-se implementar os seguintes circuitos combinacionais: Conceito C+ \u00b6 AND 16 bits Arquivo : And16.vhd Descri\u00e7\u00e3o : And bit a bit entre duas palavras de 16 bits. OR de 16 bits Arquivo : Or16.vhd Descri\u00e7\u00e3o : OR bit a bit entre duas palavras de 16 bits. NOT de 16 bits Arquivo : Not16.vhd Descri\u00e7\u00e3o : NOT bit a bit entre duas palavras de 16 bits. NOR 8 Way Arquivo : Nor8Way.vhd Descri\u00e7\u00e3o : NOR entre 8 bits, resulta em uma \u00fanica sa\u00edda OR 8 Way Arquivo : Or8Way.vhd Descri\u00e7\u00e3o : OR entre 8 bits, resulta em uma \u00fanica sa\u00edda Demultiplexador de 2 sa\u00eddas Arquivo : DMux2Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em duas sa\u00eddas. Demultiplexador de 4 sa\u00eddas Arquivo : DMux4Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em quatro sa\u00eddas. Demultiplexador de 8 sa\u00eddas Arquivo : DMux8Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em oito sa\u00eddas. Multiplexador de duas entradas de 16 bits Arquivo : Mux16.vhd Descri\u00e7\u00e3o : Multiplexa duas entradas de 16 bits para uma de 16 bits. Multiplexador 2 entradas de um bit cada Arquivo : Mux2Way.vhd Descri\u00e7\u00e3o : Multiplexa 2 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de um bit cada Arquivo : Mux4Way.vhd Descri\u00e7\u00e3o : Multiplexa 4 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 8 entradas de um bit cada Arquivo : Mux8Way.vhd Descri\u00e7\u00e3o : Multiplexa 8 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de 16 bits cada Arquivo : Mux4Way16.vhd Descri\u00e7\u00e3o : Multiplexa 4 entradas de 16 bits cada em uma sa\u00edda de 16 bits. Multiplexador 8 entradas de 16 bits cada Arquivo : Mux8Way16.vhd Deslocador de bits Arquivo : BarrelShifter16.vhd Conceito B+ \u00b6 Circuito l\u00f3gico Arquivo : circuito.vhd Descri\u00e7\u00e3o : Primeira quest\u00e3o da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Detector de moedas Arquivo : detectorDeMoedas.vhd Descri\u00e7\u00e3o : Quest\u00e3o do detector de moedas da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Impressora Arquivo : impressora.vhd Descri\u00e7\u00e3o : Quest\u00e3o da impressora da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Porta xor de 3 entradas Arquivo : xor3.vhd Descri\u00e7\u00e3o : Implemente uma porta XOR de 3 entradas utilizando necessariamente apenas um Mux8Way. Display de 7s Arquivo : `sevenSeg.vhd' Descri\u00e7\u00e3o : Quest\u00e3o do display de sete segmentos da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Display 7s Esse item \u00e9 uma continua\u00e7\u00e3o do que foi realizado no Lab4 , onde voc\u00eas tiveram que exibir um valor constante no display de 7s. Para cada segmento do display, voc\u00eas devem encontrar uma equa\u00e7\u00e3o booleana que o represente, e ent\u00e3o implementar em VHDL e testar na FPGA. Rubricas para avalia\u00e7\u00e3o do projeto \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: Uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo. Grupo \u00b6 Para atingir os objetivos A e B, deve-se antes atingir o C. Conceito Descritivo A+ Exibe tr\u00eas d\u00edgitos em Hexadecimal na FPGA - anexar video ao reposit\u00f3rio (exibir at\u00e9 o valor 0x3FF = 2^10 - 1) B+ M\u00f3dulos adicionais implementados e funcionado (circuito, detector de moedas, impressora, xor) Implementar um \u00fanico display de 7s (conta de 0x0 0xF) - anexar video ao reposit\u00f3rio C+ Ter criado o project no github Actions configurado e funcionando Todos os m\u00f3dulos b\u00e1sicos implementados e funcionado D At\u00e9 dois M\u00f3dulos com falha/ n\u00e3o apresentou o v\u00eddeo da FPGA I Mais de tr\u00eas m\u00f3dulos com falha Conceito A Voc\u00eas devem implementar o \"exibe hexadecimal\" no arquivo ConceitoA.vhd . Tem um teste para os m\u00f3dulos, voc\u00ea pode testar incluindo o arquivo de configura\u00e7\u00e3o de testes. Sugerimos que voc\u00eas reutilizem o m\u00f3dulo sevenSeg.vhd , para isso devem utilizar uma recurso do VHDL chamado de port map . VHDL/port map Individual \u00b6 As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link: Rubricas Scrum e Desenvolvedor Formul\u00e1rios \u00b6 Scrum Master Desenvolvedores","title":"B - L\u00f3gica Combinacional"},{"location":"LogiComb-Projeto/#b-logica-combinacional","text":"Data da entrega Quinta - 15/09 Scrum Master Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Esse projeto tem como objetivo trabalhar com portas l\u00f3gicas e sistemas digitais combinacionais (sem um clock) em FPGA e VHDL. Os elementos l\u00f3gicos desenvolvidos nessa etapa ser\u00e3o utilizados como elementos b\u00e1sicos para a constru\u00e7\u00e3o do computador.","title":"B - L\u00f3gica Combinacional"},{"location":"LogiComb-Projeto/#instrucoes","text":"O desenvolvimento ser\u00e1 na linguagem VHDL, o grupo deve se organizar para implementar todos os elementos propostos. O facilitador escolhido ser\u00e1 respons\u00e1vel pela completude e consist\u00eancia do branch master do grupo.","title":"Instru\u00e7\u00f5es"},{"location":"LogiComb-Projeto/#integrantes","text":"Tarefas devem ser criadas no Issues e atribu\u00eddas aos demais colegas. As tarefas devem ser resolvidas individualmente! Utilize a ajuda de seus colegas, mas resolva o que foi atribu\u00eddo a voc\u00eas, essa \u00e9 sua tarefa/ responsabilidade! Warning Este projeto \u00e9 para ser realizado por todos os integrantes do grupo em seus pr\u00f3prios computadores, quem n\u00e3o participar, n\u00e3o implementar os m\u00f3dulos que foram atribu\u00eddos, ou n\u00e3o realizar pull-request n\u00e3o ganhar\u00e1 nota de participa\u00e7\u00e3o individual.","title":"Integrantes"},{"location":"LogiComb-Projeto/#controle-de-tarefas-e-repositorio","text":"Nas discuss\u00f5es com os outros colegas o scrum master deve definir os m\u00f3dulos que cada um do grupo ir\u00e1 desenvolver. Crie uma rotina para commits e pull-request. Sempre teste os m\u00f3dulos e verifique se est\u00e1 fazendo o esperado.","title":"Controle de Tarefas e Reposit\u00f3rio"},{"location":"LogiComb-Projeto/#facilitador-scrum-master","text":"Fazer a atualiza\u00e7\u00e3o do fork com o upstream Organizar o github + issues + project Gerenciar o grupo (atribuir tarefas) Gerenciar os pull-requests Criar relat\u00f3rio da performance de cada um do grupo Entregar/Apresentar o projeto no final","title":"Facilitador (Scrum Master)"},{"location":"LogiComb-Projeto/#desenvolvedores","text":"Realizar as tarefas atribuidas pelo scrum-master Ajudar na entrega final Testar os c\u00f3digos Realizar os pull-requests","title":"Desenvolvedores"},{"location":"LogiComb-Projeto/#arquivos","text":"A pasta cont\u00e9m dois diret\u00f3rios distintos : src/ e Quartus/ . O diret\u00f3rio src cont\u00e9m os arquivos fontes que dever\u00e3o ser editados para implementar o projeto. O diret\u00f3rio quartus/ cont\u00e9m o projeto que possibilitar\u00e1 compilar os m\u00f3dulos e testar em hardware.","title":"Arquivos"},{"location":"LogiComb-Projeto/#entendendo-o-projeto","text":"A pasta do projeto B no reposit\u00f3rio Z01.1-proj possui a seguinte estrutura : /B-LogicaCombinacional testeLogicaCombinacional.py /Quartus /src *.vhd config_testes.txt /testes *.vhd Quartus : Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd Serve para programar a FPGA *.py : Scripts em python automatiza a execu\u00e7\u00e3o dos testes src/*.vhd : Arquivos VHDL que ser\u00e3o implementado pelo grupo config_testes.txt : Configura\u00e7\u00e3o dos testes testes/*.vhd : Arquivos VHDL que realizam teste l\u00f3gico nos arquivos do rtl","title":"Entendendo o projeto"},{"location":"LogiComb-Projeto/#executando-o-script-de-teste","text":"Abra o terminal na pasta B-LogicaCombinacional e execute o script python localizado nessa pasta: $ ./testeLogicaCombinacional.py Note No exemplo de teste verificamos que aimplementa\u00e7\u00e3o da nand est\u00e1 errada.","title":"Executando o script de teste"},{"location":"LogiComb-Projeto/#entrega","text":"A entrega deve ser feita no ramo main do git. Implementar todos os m\u00f3dulos listados Todos os m\u00f3dulos devem passar nos testes Actions deve estar configurado e funcionando Implementar acionamento do diplay de 7 segmentos e demonstrar na FPGA Note Esses arquivos est\u00e3o localizados em B-LogicaCombinacional/src/ Tip Utilize o VScode para editar os arquivos em vhdl e valide a implementa\u00e7\u00e3o executando o script de testes. Deve-se implementar os seguintes circuitos combinacionais:","title":"Entrega"},{"location":"LogiComb-Projeto/#conceito-c","text":"AND 16 bits Arquivo : And16.vhd Descri\u00e7\u00e3o : And bit a bit entre duas palavras de 16 bits. OR de 16 bits Arquivo : Or16.vhd Descri\u00e7\u00e3o : OR bit a bit entre duas palavras de 16 bits. NOT de 16 bits Arquivo : Not16.vhd Descri\u00e7\u00e3o : NOT bit a bit entre duas palavras de 16 bits. NOR 8 Way Arquivo : Nor8Way.vhd Descri\u00e7\u00e3o : NOR entre 8 bits, resulta em uma \u00fanica sa\u00edda OR 8 Way Arquivo : Or8Way.vhd Descri\u00e7\u00e3o : OR entre 8 bits, resulta em uma \u00fanica sa\u00edda Demultiplexador de 2 sa\u00eddas Arquivo : DMux2Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em duas sa\u00eddas. Demultiplexador de 4 sa\u00eddas Arquivo : DMux4Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em quatro sa\u00eddas. Demultiplexador de 8 sa\u00eddas Arquivo : DMux8Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em oito sa\u00eddas. Multiplexador de duas entradas de 16 bits Arquivo : Mux16.vhd Descri\u00e7\u00e3o : Multiplexa duas entradas de 16 bits para uma de 16 bits. Multiplexador 2 entradas de um bit cada Arquivo : Mux2Way.vhd Descri\u00e7\u00e3o : Multiplexa 2 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de um bit cada Arquivo : Mux4Way.vhd Descri\u00e7\u00e3o : Multiplexa 4 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 8 entradas de um bit cada Arquivo : Mux8Way.vhd Descri\u00e7\u00e3o : Multiplexa 8 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de 16 bits cada Arquivo : Mux4Way16.vhd Descri\u00e7\u00e3o : Multiplexa 4 entradas de 16 bits cada em uma sa\u00edda de 16 bits. Multiplexador 8 entradas de 16 bits cada Arquivo : Mux8Way16.vhd Deslocador de bits Arquivo : BarrelShifter16.vhd","title":"Conceito C+"},{"location":"LogiComb-Projeto/#conceito-b","text":"Circuito l\u00f3gico Arquivo : circuito.vhd Descri\u00e7\u00e3o : Primeira quest\u00e3o da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Detector de moedas Arquivo : detectorDeMoedas.vhd Descri\u00e7\u00e3o : Quest\u00e3o do detector de moedas da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Impressora Arquivo : impressora.vhd Descri\u00e7\u00e3o : Quest\u00e3o da impressora da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Porta xor de 3 entradas Arquivo : xor3.vhd Descri\u00e7\u00e3o : Implemente uma porta XOR de 3 entradas utilizando necessariamente apenas um Mux8Way. Display de 7s Arquivo : `sevenSeg.vhd' Descri\u00e7\u00e3o : Quest\u00e3o do display de sete segmentos da lista de exerc\u00edcios \u00c1lgebra Booleana 2 Display 7s Esse item \u00e9 uma continua\u00e7\u00e3o do que foi realizado no Lab4 , onde voc\u00eas tiveram que exibir um valor constante no display de 7s. Para cada segmento do display, voc\u00eas devem encontrar uma equa\u00e7\u00e3o booleana que o represente, e ent\u00e3o implementar em VHDL e testar na FPGA.","title":"Conceito B+"},{"location":"LogiComb-Projeto/#rubricas-para-avaliacao-do-projeto","text":"Cada integrante do grupo ir\u00e1 receber duas notas: Uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo.","title":"Rubricas para avalia\u00e7\u00e3o do projeto"},{"location":"LogiComb-Projeto/#grupo","text":"Para atingir os objetivos A e B, deve-se antes atingir o C. Conceito Descritivo A+ Exibe tr\u00eas d\u00edgitos em Hexadecimal na FPGA - anexar video ao reposit\u00f3rio (exibir at\u00e9 o valor 0x3FF = 2^10 - 1) B+ M\u00f3dulos adicionais implementados e funcionado (circuito, detector de moedas, impressora, xor) Implementar um \u00fanico display de 7s (conta de 0x0 0xF) - anexar video ao reposit\u00f3rio C+ Ter criado o project no github Actions configurado e funcionando Todos os m\u00f3dulos b\u00e1sicos implementados e funcionado D At\u00e9 dois M\u00f3dulos com falha/ n\u00e3o apresentou o v\u00eddeo da FPGA I Mais de tr\u00eas m\u00f3dulos com falha Conceito A Voc\u00eas devem implementar o \"exibe hexadecimal\" no arquivo ConceitoA.vhd . Tem um teste para os m\u00f3dulos, voc\u00ea pode testar incluindo o arquivo de configura\u00e7\u00e3o de testes. Sugerimos que voc\u00eas reutilizem o m\u00f3dulo sevenSeg.vhd , para isso devem utilizar uma recurso do VHDL chamado de port map . VHDL/port map","title":"Grupo"},{"location":"LogiComb-Projeto/#individual","text":"As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link: Rubricas Scrum e Desenvolvedor","title":"Individual"},{"location":"LogiComb-Projeto/#formularios","text":"Scrum Master Desenvolvedores","title":"Formul\u00e1rios"},{"location":"Sobre-Criterios-de-Avaliacao/","text":"Crit\u00e9rios de Avalia\u00e7\u00e3o \u00b6 Os crit\u00e9rios de avalia\u00e7\u00e3o a seguir ser\u00e3o aplicados a disciplina: Crit\u00e9rios \u00b6 Os alunos devem: Ter acumulado no m\u00ednimo 50 pontos de HW (\u00c1lgebra booleana, l\u00f3gica combinacional, unidade l\u00f3gica aritm\u00e9tica, l\u00f3gica sequencial, CPU) nas provas Ter acumulado no m\u00ednimo 50 pontos de SW (Dados digitais, assembly, assembler, m\u00e1quina virtual, VM translator) nas provas Ter no m\u00ednimo conceito C na m\u00e9dia de todos os Projetos nos quesitos Individual e Grupo Ter no m\u00e1ximo duas notas inferiores a C na avalia\u00e7\u00e3o individual e uma nota inferior a C na avalia\u00e7\u00e3o coletiva dos Projetos Provas \u00b6 Ao longo do semestre o aluno deve acumular 50 pontos de Software e 50 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro provas (A1, A2, A3, A4) que ser\u00e3o aplicadas ao longo do semestre. A nota final de prova (atingido atingido o crit\u00e9rio) ser\u00e1 a m\u00e9dia da soma das notas de HW e SW aplicado o conceito (final da p\u00e1gina). Provas Pontua\u00e7\u00e3o HW Pontua\u00e7\u00e3o SW Pontua\u00e7\u00e3o Total Conte\u00fado A1 30 10 40 \u00c1lgebra booleana, dados digitais A2 40 10 50 Dados digitais, l\u00f3gica combinacional, ULA A3 20 35 55 L\u00f3gica sequencial, Assembly A4 10 45 55 CPU, Assembler, m\u00e1quina virtual Total 100 100 200 Projetos (APS) \u00b6 O projeto \u00e9 composto por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivos diferentes do curso. A nota final de projeto (quando atingindo o crit\u00e9rio) ser\u00e1 a m\u00e9dia de todas as entregas, aplicado a regra a baixo. Contribui\u00e7\u00e3o individual menor que C Nota final nenhuma M\u00e9dia uma M\u00e9dia - 1 conceito duas M\u00e9dia - 2 conceitos tr\u00eas ou mais Fora do crit\u00e9rio Nota final \u00b6 A nota final ser\u00e1 composta pela nota de Projeto e a nota da Prova: Nota Final = mean([Prova, Projeto]) Conceito \u00b6 A seguinte tabela ser\u00e1 aplicada para o c\u00e1lculo dos conceitos. Nota Conceito 10 A+ 9 A 8 B+ 7 B 6 C+ 5 C 4-3 D 3-0 I","title":"Crit\u00e9rios de Avalia\u00e7\u00e3o"},{"location":"Sobre-Criterios-de-Avaliacao/#criterios-de-avaliacao","text":"Os crit\u00e9rios de avalia\u00e7\u00e3o a seguir ser\u00e3o aplicados a disciplina:","title":"Crit\u00e9rios de Avalia\u00e7\u00e3o"},{"location":"Sobre-Criterios-de-Avaliacao/#criterios","text":"Os alunos devem: Ter acumulado no m\u00ednimo 50 pontos de HW (\u00c1lgebra booleana, l\u00f3gica combinacional, unidade l\u00f3gica aritm\u00e9tica, l\u00f3gica sequencial, CPU) nas provas Ter acumulado no m\u00ednimo 50 pontos de SW (Dados digitais, assembly, assembler, m\u00e1quina virtual, VM translator) nas provas Ter no m\u00ednimo conceito C na m\u00e9dia de todos os Projetos nos quesitos Individual e Grupo Ter no m\u00e1ximo duas notas inferiores a C na avalia\u00e7\u00e3o individual e uma nota inferior a C na avalia\u00e7\u00e3o coletiva dos Projetos","title":"Crit\u00e9rios"},{"location":"Sobre-Criterios-de-Avaliacao/#provas","text":"Ao longo do semestre o aluno deve acumular 50 pontos de Software e 50 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro provas (A1, A2, A3, A4) que ser\u00e3o aplicadas ao longo do semestre. A nota final de prova (atingido atingido o crit\u00e9rio) ser\u00e1 a m\u00e9dia da soma das notas de HW e SW aplicado o conceito (final da p\u00e1gina). Provas Pontua\u00e7\u00e3o HW Pontua\u00e7\u00e3o SW Pontua\u00e7\u00e3o Total Conte\u00fado A1 30 10 40 \u00c1lgebra booleana, dados digitais A2 40 10 50 Dados digitais, l\u00f3gica combinacional, ULA A3 20 35 55 L\u00f3gica sequencial, Assembly A4 10 45 55 CPU, Assembler, m\u00e1quina virtual Total 100 100 200","title":"Provas"},{"location":"Sobre-Criterios-de-Avaliacao/#projetos-aps","text":"O projeto \u00e9 composto por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivos diferentes do curso. A nota final de projeto (quando atingindo o crit\u00e9rio) ser\u00e1 a m\u00e9dia de todas as entregas, aplicado a regra a baixo. Contribui\u00e7\u00e3o individual menor que C Nota final nenhuma M\u00e9dia uma M\u00e9dia - 1 conceito duas M\u00e9dia - 2 conceitos tr\u00eas ou mais Fora do crit\u00e9rio","title":"Projetos (APS)"},{"location":"Sobre-Criterios-de-Avaliacao/#nota-final","text":"A nota final ser\u00e1 composta pela nota de Projeto e a nota da Prova: Nota Final = mean([Prova, Projeto])","title":"Nota final"},{"location":"Sobre-Criterios-de-Avaliacao/#conceito","text":"A seguinte tabela ser\u00e1 aplicada para o c\u00e1lculo dos conceitos. Nota Conceito 10 A+ 9 A 8 B+ 7 B 6 C+ 5 C 4-3 D 3-0 I","title":"Conceito"},{"location":"Sobre-Objetivos-de-Aprendizagem/","text":"Ao final da disciplina o estudante ser\u00e1 capaz de: Implementar um computador digital simples a partir de componentes eletr\u00f4nicos. Integrar as camadas de programa\u00e7\u00e3o e execu\u00e7\u00e3o de um computador simples. Trabalhar de forma colaborativa no desenvolvimento de um sistema computacional. Compreender a evolu\u00e7\u00e3o da inform\u00e1tica. Descrever como dados e instru\u00e7\u00f5es s\u00e3o armazenados e tratados em computadores. Conte\u00fado Program\u00e1tico: L\u00f3gica Combinacional Unidade L\u00f3gica Aritm\u00e9tica L\u00f3gica Sequencial L\u00f3gica de Controle Linguagem de M\u00e1quinas Assembly Assembler M\u00e1quina Virtual Controle de programa Linguagem Orientada a Objetos An\u00e1lise L\u00e9xica e Sint\u00e1tica Linguagens","title":"Sobre Objetivos de Aprendizagem"},{"location":"Sobre-Rubricas/","text":"Rubricas individuais \u00b6 Voc\u00ea ser\u00e1 avaliado conforme o seu papel no desenvolvimento do projeto. Podendo ser: Facilitador Desenvolvedor O Facilitador ser\u00e1 atribu\u00eddo pelo professor antes do inicio do projeto. Facilitador \u00b6 O facilitador ser\u00e1 avaliado pelos 'Desenvolvedores' com base em seus objetivos: Fez a manuten\u00e7\u00e3o do Kanban board (GitHub project). Ex: cria cards, atribui tarefas, d\u00e1 feedback de issues. Gerenciou os pull-requests. Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio Ajudou outros colegas com o objetivo da entrega final e n\u00e3o somente das suas tarefas A nota final ser\u00e1 a m\u00e9dia das notas de cada 'Desenvolvedor' vezes Fator de participa\u00e7\u00e3o em aula (1, 0.5, 0). Fator de Participa\u00e7\u00e3o em aula: 1: Esteve presente e participou nas aulas referentes aos projetos 0.5: Faltou e/ou n\u00e3o participou de alguma aula referente ao projeto 0: Faltou e/ou n\u00e3o participou da maioria das aulas do projeto Warning Se algum facilitador n\u00e3o preencher o formul\u00e1rio no prazo estipulado sua nota ser\u00e1 I Desenvolvedor \u00b6 Se o facilitador tiver m\u00e9dia maior que C , a nota dos desenvolvedores ser\u00e1 dada pelo facilitador com base em seus objetivos: Participou das aulas referentes ao projetos (handouts, labs) Desenvolveu as rotinas atribu\u00eddas pelo Facilitador para passarem nos testes! Submeteu altera\u00e7\u00f5es por pull requests. Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio Entregas orientadas para o objetivo do projeto Tip Caso a nota do Facilitador seja inferior a C, a nota dos desenvolvedores se dar\u00e1 pela m\u00e9dia da avalia\u00e7\u00e3o dos seus colegas. Warning Se algum desenvolvedor n\u00e3o preencher o formul\u00e1rio no prazo estipulado sua nota ser\u00e1 D/I","title":"Rubricas individuais"},{"location":"Sobre-Rubricas/#rubricas-individuais","text":"Voc\u00ea ser\u00e1 avaliado conforme o seu papel no desenvolvimento do projeto. Podendo ser: Facilitador Desenvolvedor O Facilitador ser\u00e1 atribu\u00eddo pelo professor antes do inicio do projeto.","title":"Rubricas individuais"},{"location":"Sobre-Rubricas/#facilitador","text":"O facilitador ser\u00e1 avaliado pelos 'Desenvolvedores' com base em seus objetivos: Fez a manuten\u00e7\u00e3o do Kanban board (GitHub project). Ex: cria cards, atribui tarefas, d\u00e1 feedback de issues. Gerenciou os pull-requests. Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio Ajudou outros colegas com o objetivo da entrega final e n\u00e3o somente das suas tarefas A nota final ser\u00e1 a m\u00e9dia das notas de cada 'Desenvolvedor' vezes Fator de participa\u00e7\u00e3o em aula (1, 0.5, 0). Fator de Participa\u00e7\u00e3o em aula: 1: Esteve presente e participou nas aulas referentes aos projetos 0.5: Faltou e/ou n\u00e3o participou de alguma aula referente ao projeto 0: Faltou e/ou n\u00e3o participou da maioria das aulas do projeto Warning Se algum facilitador n\u00e3o preencher o formul\u00e1rio no prazo estipulado sua nota ser\u00e1 I","title":"Facilitador"},{"location":"Sobre-Rubricas/#desenvolvedor","text":"Se o facilitador tiver m\u00e9dia maior que C , a nota dos desenvolvedores ser\u00e1 dada pelo facilitador com base em seus objetivos: Participou das aulas referentes ao projetos (handouts, labs) Desenvolveu as rotinas atribu\u00eddas pelo Facilitador para passarem nos testes! Submeteu altera\u00e7\u00f5es por pull requests. Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio Entregas orientadas para o objetivo do projeto Tip Caso a nota do Facilitador seja inferior a C, a nota dos desenvolvedores se dar\u00e1 pela m\u00e9dia da avalia\u00e7\u00e3o dos seus colegas. Warning Se algum desenvolvedor n\u00e3o preencher o formul\u00e1rio no prazo estipulado sua nota ser\u00e1 D/I","title":"Desenvolvedor"},{"location":"Teoria-Algebra-Booleana/","text":"\u00c1lgebra Booleana \u00b6 Conte\u00fado: Equa\u00e7\u00f5es; Opera\u00e7\u00f5es (portas l\u00f3gicas); Tabela Verdade; Sintetiza\u00e7\u00e3o de fun\u00e7\u00f5es; Soma dos Produtos; Produto das Somas; Simplifica\u00e7\u00e3o Alg\u00e9brica; Mapa de Karnaught. Estudando Bibliografia [Cap1. Cap2. NISAN, 2005] [Cap6. TOCCI, 2011] [Cap1. FLOYD, 2007] [LAING, 2004] V\u00eddeos (extra) Logic 101 (#11): Truth Tables Logic 101 (#12): Truth Table Practice Computer Science: Karnaugh Maps \u2013 Introduction Computer Science: Karnaugh Maps - 4 vars A \u00e1lgebra booleana foi desenvolvida por George Boole , um matem\u00e1tico brit\u00e2nico que desenvolveu os conceitos em 1847, base da computa\u00e7\u00e3o moderna. Muito tempo depois, nos anos 30, Claude Shannon, um importante engenheiro na hist\u00f3ria da computa\u00e7\u00e3o moderna, aplicou as ideias de Boole em circuitos el\u00e9tricos. Ele trabalhava no Analisador Diferencial de Vannevar Bush, e logo percebeu a rela\u00e7\u00e3o dos rel\u00e9s com \u00e1lgebra booleana. Ele fazia um rel\u00e9 acionar o outro usando usando uma l\u00f3gica bin\u00e1ria do rel\u00e9 fechado ou aberto. Sua disserta\u00e7\u00e3o e artigos, levaram outras pessoas a perceber os benef\u00edcios da \u00e1lgebra booleana em eletr\u00f4nica e consequentemente computa\u00e7\u00e3o. Em \u00c1lgebra Booleana as vari\u00e1veis s\u00f3 podem assumir dois valores. Desligado e ligado, ou falso e verdadeiro, 0 volt e 5 volts, branco e preto. Por\u00e9m normalmente na computa\u00e7\u00e3o usamos 0 e 1 pela conveni\u00eancia. Todos os computadores tem como sua menor unidade de dado, esse elemento. Em computa\u00e7\u00e3o chamamos isso de bit. que vem de d\u00edgito bin\u00e1rio (ou do ingl\u00eas binary digit). Note Bit \u00e9 a unidade mais simples de representa\u00e7\u00e3o de dados digitais, um bit \u00e9 uma unidade que pode assumir apenas dois valores: 0 ou 1 . Com um bit podemos representar o estado de uma luz na sala de aula, se uma cadeira est\u00e1 vazio ou n\u00e3o, .... n\u00e3o conseguimos representar com apenas um bit uma informa\u00e7\u00e3o que n\u00e3o seja bin\u00e1ria. Mas se combinarmos mais de um bit, criando um vetor de bits, somos capazes de representar quantos estados desejarmos. Progress Cheguei Aqui! Equa\u00e7\u00f5es \u00b6 Uma equa\u00e7\u00e3o de l\u00f3gica booleana pode possuir uma ou mais 'entradas' e apenas uma sa\u00edda, na equa\u00e7\u00e3o exemplo a seguir, X \u00e9 uma sa\u00edda (e pode assumir apenas valor 1 ou 0 ) e A e B s\u00e3o entradas tamb\u00e9m do tipo bin\u00e1ria. X(A,B) = A . B Note A opera\u00e7\u00e3o . \u00e9 chamada de E ( and ) que tamb\u00e9m pode ser representada pelo s\u00edmbolo: ^ X = A and B X = A . B X = A ^ B A opera\u00e7\u00e3o de and pode ser entendida como uma multiplica\u00e7\u00e3o: A sa\u00edda ( X ) s\u00f3 \u00e9 verdadeira se as entradas A e B forem verdadeiras: 1 . 1 = 1 . Como A e B s\u00e3o n\u00fameros bin\u00e1rios, \u00e9 poss\u00edvel encontrar uma tabela que relaciona o TODOS os valor da sa\u00edda X com todas as entradas possiveis: A e B Entrada A Entrada B Sa\u00edda X 0 0 0 0 1 0 1 0 0 1 1 1 Tabela Verdade Essa tabela que acabamos de construir chama tabela verdade , e ser\u00e1 muito utilizada ao longo do curso. Tamb\u00e9m podemos representar essa equa\u00e7\u00e3o X = A . B como sendo um circuito digital: Note Resolver fun\u00e7\u00f5es booleanas \u00e9 entender quando a sa\u00edda ser\u00e1 Verdadeira ou Falsa dado a combina\u00e7\u00e3o poss\u00edvel de entradas. Progress Cheguei Aqui! Opera\u00e7\u00f5es \u00b6 O and utilizado no exemplo anterior \u00e9 um operador da l\u00f3gica booleana, operadores possuem uma ou mais entradas e geram uma sa\u00edda. Os operadores mais comuns s\u00e3o: not , and , or , nand , nor , xor . not \u00b6 O operador not atua sobre uma vari\u00e1vel, tornando a sa\u00edda o inverso da entrada, ou seja, se a entrada do operador for 1 sua sa\u00edda ser\u00e1 0 e vice versa. Uso: a luz interna do carro ser\u00e1 acesa ('1') quando a porta estiver fechada ('0'). Nota\u00e7\u00e3o: not , - , ~ , \u00ac : X = not A / X = A / X = \u00c3 / X = \u00ac A Tabela Verdade: Entrada A X = not A 0 1 1 0 Simbologia: and \u00b6 O operador and atua sobre duas vari\u00e1vel, tornando a sa\u00edda verdadeira somente se as duas entradas forem verdadeiras , se uma das entradas forem falsa a sa\u00edda ser\u00e1 falsa . Uso: o cofre ser\u00e1 aberto somente quando as duas chaves de seguran\u00e7as forem inseridas. Nota\u00e7\u00e3o: and , . , ^ : X = A and B / X = A . B / X = A ^ B Tabela Verdade: A B X = A and B 0 0 0 0 1 0 1 0 0 1 1 1 Simbologia: or \u00b6 O operador or atua sobre duas vari\u00e1vel, tornando a sa\u00edda verdadeira sempre que uma das entradas forem verdadeira . Uso: O alarme de inc\u00eandio ser\u00e1 acionado caso alguns dois dois bot\u00f5es sejam pressionados. Nota\u00e7\u00e3o: or , + , v : X = A or B / X = A + B / X = A v B Tabela Verdade: A B X = A or B 0 0 0 0 1 1 1 0 1 1 1 1 Simbologia: nand \u00b6 Podemos come\u00e7ar a 'unir' operadores para formar novos comportamentos, o nand \u00e9 a invers\u00e3o ( not ) da porta l\u00f3gica and . Na porta nand a sa\u00edda s\u00f3 \u00e9 verdadeira quando as entradas s\u00e3o falsas . Uso: Soar o alarme se os sensores de batimento card\u00edaco e o de press\u00e3o falharem. Nota\u00e7\u00e3o: nand , \u00ac( \u2227 ) _____ X = A nand B / X = A . B / X = \u00ac(A \u2227 B) Tabela Verdade: A B X = A nand B 0 0 1 0 1 1 1 0 1 1 1 0 Simbologia: nor / xor / xnor \u00b6 Para as demais portas l\u00f3gicas, consulte a refer\u00eancia: https://en.wikipedia.org/wiki/Logic_gate#Symbols Estudar as portas pois iremos precisar que voc\u00eas saibam. Check-Point \ufeffL\u00f3gica booleana 1 Quest\u00f5es b\u00e1sicas O que \u00e9 correto afirmar sobre bits? 1 AND 0 Se aplicarmos as entradas 1 e 0 a porta, a sa\u00edda ser\u00e1: 1 OR 0 Se aplicarmos as entradas 1 e 0 a porta, a sa\u00edda ser\u00e1: Progress Cheguei Aqui! Tabela Verdade \u00b6 Nessa tabela criamos colunas para cada vari\u00e1vel de entrada e de sa\u00edda e colocamos as situa\u00e7\u00f5es poss\u00edveis (resultado). Para construirmos uma tabela verdade basta seguir as regras a seguir (na sequ\u00eancia): Criar uma coluna para cada entrada do sistema (n) Criar uma coluna para cada sa\u00edda do sistema A tabela verdade vai ter 2^n n\u00fameros de linhas (onde n \u00e9 a quantidade de entradas) um sistema com 2 entradas possui 2\u00b2 = 4 linhas um sistema com 3 entradas possui 2\u00b3 = 8 linhas ... Preencher as entradas (com '1's e '0's ) de forma a cobrir todas as possibilidades. Para cada linha, analisar se a combina\u00e7\u00e3o de '1's e '0' torna a sa\u00edda '1' e '0' Check-Point L\u00f3gica booleana - Tabela Verdade Responda sobre tabela verdade \u00c9 correto afirmar sobre a tabela verdade: (pode existir mais de um item correto) Considerando um circuito de 4 entradas (A,B, C, D) quantas s\u00e3o as linhas da tabela verdade? \ufeffQual tabela verdade a seguir foi montada correta? Considerando a equa\u00e7\u00e3o: X = not(B) + A , e a tabela verdade da imagem, qual resposta est\u00e1 correta (na sequ\u00eancia da tabela)? Resposta na sequ\u00eancia: X0; X1; X2; X3 Progress Cheguei Aqui! Fun\u00e7\u00f5es geradas a partir de Tabelas Verdade \u00b6 \u00c9 poss\u00edvel a partir de uma tabela verdade obter uma equa\u00e7\u00e3o l\u00f3gica que a represente (caminho inverso), podemos fazer isso por duas t\u00e9cnicas diferentes (chamadas de forma can\u00f4nicas): Soma dos Produtos (SoP) Produto das Somas (PoS) Soma Dos Produtos \u00b6 Na soma dos produtos iremos encontrar uma equa\u00e7\u00e3o booleana que possui a seguinte forma: X = ( . . . ) + ( . . . ) + ... + ( . . . ) ----- | | = '1' Nesse m\u00e9todo, precisamos encontrar as linhas da tabela verdade que resultam em uma sa\u00edda '1' (Verdadeira) e invertendo (ou n\u00e3o) as entradas fazendo com que o termo ( . . . .) resulte em '1' para a linha em quest\u00e3o. Produto das somas \u00b6 X = ( + + + ) . ( + + + ) . ... . ( + + + ) ----- | | = '0' Nesse m\u00e9todo, precisamos encontrar as linhas da tabela verdade que resultam em uma sa\u00edda '0' e invertendo (ou n\u00e3o) as entradas fazendo com que o termo ( . . . .) resulte em '0' para a linha em quest\u00e3o. Example Check-Point \ufeffL\u00f3gica Booleana - Equa\u00e7\u00f5es Can\u00f4nicas Encontre a equa\u00e7\u00e3o correta dada a tabela verdade ou vice versa \ufeffQual forma \u00e9 a mais adequada? \ufeffQual forma \u00e9 a mais adequada? Qual equa\u00e7\u00e3o representa a tabela verdade? Qual equa\u00e7\u00e3o representa a tabela verdade? Quiz Maker - powered by Riddle Progress Cheguei Aqui! Simplifica\u00e7\u00e3o \u00b6 Existem duas formas bastante populares de simplificar uma equa\u00e7\u00e3o booleana: alg\u00e9brica ou via mapa de Karnaugh. Veremos as duas com mais detalhes. Simplifica\u00e7\u00e3o alg\u00e9brica \u00b6 Na simplifica\u00e7\u00e3o alg\u00e9brica iremos utilizar as seguintes propriedades de l\u00f3gica booleana para nos ajudar a simplificar uma equa\u00e7\u00e3o: Explica\u00e7\u00e3o da tabela Para essas simplifica\u00e7\u00f5es n\u00f3s usaremos as propriedades das opera\u00e7\u00f5es b\u00e1sicas de \u00e1lgebra booleana, representada na tabela anterior. As leis da identidade, comutatividade, associatividade e distributividade s\u00e3o bem similares ao que j\u00e1 fazemos normalmente em express\u00f5es matem\u00e1ticas. A idempot\u00eancia mostra que um AND ou OR com duas vari\u00e1veis \u00e9 exatamente a mesma vari\u00e1vel. A lei do complemento duplo mostra que se negarmos duas vezes uma vari\u00e1vel, teremos a mesma vari\u00e1vel. A lei da complementariedade j\u00e1 mostra que fazermos um AND com a nega\u00e7\u00e3o da mesma vari\u00e1vel acabaremos com zero, ou seja, 0 vezes 1 ou 1 vezes 0 sempre dar\u00e1 zero. J\u00e1 com o OR \u00e9 o oposto e sempre teremos 1 como resposta. Na lei da interse\u00e7\u00e3o temos que uma vari\u00e1vel vezes 1 \u00e9 sempre ela mesma, e se for vezes 0, acabara zerando o resultado. J\u00e1 a lei da uni\u00e3o diz que uma vari\u00e1vel mais um \u00e9 sempre um, e uma vari\u00e1vel mais zero \u00e9 a pr\u00f3pria vari\u00e1vel. O teorema de DeMorgam \u00e9 bem interessante, pois mostra uma propriedade bem peculiar da \u00e1lgebra booleana, no caso o conjunto de A vezes B negado, \u00e9 o mesmo que A negado, mais B negado, e da mesma forma A negado mais B negado \u00e9 igual ao A vezes B, e esse resultado negado. Para simplificarmos uma equa\u00e7\u00e3o, aplicamos as propriedades da tabela anterior a fim de encontrarmos uma equa\u00e7\u00e3o que: Tenha uma forma mais explicita de sua propriedade exe: \\(A . B + A . C\\) -> \\(A (B + C)\\) Minimize o uso de 'portas l\u00f3gicas' exe: \\((A . B) . C + A . B . D\\) -> \\((A . B)(C + D)\\) Elimine minimize as entradas necess\u00e1rias exe: \\(( (A + \\overline{A}).B)\\) -> \\(B\\) Progress Cheguei Aqui! Exemplos \u00b6 Exemplo 1 Exemplo 2 Exemplo 3 Tip O v\u00eddeo a seguir possui as resolu\u00e7\u00f5es de forma detalhada: Mapa de Karnaugh (MK) \u00b6 A simplifica\u00e7\u00e3o por mapa de Karnaugh \u00e9 uma t\u00e9cnica visual de encontrarmos uma equa\u00e7\u00e3o reduzida, por\u00e9m para isso precisamos primeiro: Gerar a tabela verdade Gerar o mapa de Karnaugh Criar os grupos Gerar as equa\u00e7\u00f5es 2. Criando o Mapa \u00b6 O mapa pode ser criado para N entradas, mas s\u00f3 iremos tratar nesse curso sistemas de 2 , 3 ou 4 vari\u00e1veis (entradas). A seguir exemplos do mapa para 2, 3 e 4 entradas: Para criar o mapa basta seguir a receitinha anterior, note que a sequ\u00eancia das entras: AB e CD \u00e9 da forma: __ _ _ AB AB AB AB ----------- AB \\ 00 01 11 10 e n\u00e3o: AB \\ 00 01 10 11 Como seria mais l\u00f3gico (j\u00e1 que em bin\u00e1rio: 00 = 0; 01 = 1; 10 = 2; 11 = 3 ). Por\u00e9m o mapa de Karnaugh assume que as vari\u00e1veis est\u00e3o ordenadas na forma de c\u00f3digo gray , onde um bit \u00e9 alterado por vez! Warning Colocar qualquer sequ\u00eancia na cria\u00e7\u00e3o do mapa \u00e9 um dos erros mais comuns dos anos anteriores! Tip Podemos come\u00e7ar a sequ\u00eancia com qualquer combina\u00e7\u00e3o, se seguirmos a ordem de s\u00f3 mudar um bit por vez, exemplo: AB \\ 11 10 00 01 AB \\ 01 11 10 00 Check-Point L\u00f3gica Booleana - Karnaugh 1 Encontre a montagem do mapa de Karnaugh correta. Qual mapa de K. foi montado certo? Qual mapa de K. foi montado certo? Quiz Maker - powered by Riddle Progress Cheguei Aqui! 3. Grupos \u00b6 No MK podemos agrupar '1's na quantidade de: \\(2^n\\) , onde n=0,1,2,3, ou seja, grupos de: 1, 2, 4, 8, ... , o agrupamento s\u00f3 pode ser feito na vertical ou horizontal, nunca na diagonal. Tip Os grupos podem se sobrepor! Agrupar sempre na maior quantidade poss\u00edvel (2, 4, 8, ...) Devemos agrupar sempre na maior quantidade poss\u00edvel! A seguir exemplos do que n\u00e3o deve ser feito! Note N\u00e3o agrupar na maior quantidade de uns poss\u00edvel impacta em n\u00e3o obter a equa\u00e7\u00e3o reduzida. Podemos pensar no MK n\u00e3o como sendo uma tabela plana , mas sim uma superf\u00edcie mapeada em uma esfera, logo as pontas est\u00e3o conectadas. Com isso podemos criar grupos nas situa\u00e7\u00f5es a seguir: Tip O agrupamento no mapa de Karnaugh s\u00f3 pode ser realizado quando juntamos uns que est\u00e3o a um bit de dist\u00e2ncia. Essa \u00e9 a raz\u00e3o de n\u00e3o podermos juntar na diagonal. AB 00 01 11 10 CD \\--------------------- 00 | 0000 0100 1100 1000 10 | 0010 0110 1110 1010 11 | 0011 0111 1111 1011 10 | 0010 0110 1110 1010 Note que no exemplo anterior se juntarmos duas possibilidades na horizontal (as duas primeira): --------- [0000 0100] --------- Apenas o bit referente a entrada B muda. Mas se considerarmos a diagonal: ---- [0000 0110] ---- Temos duas mudan\u00e7as de bit, a da entrada B e a da entrada C , isso n\u00e3o pode! O ultimo caso s\u00e3o os cantos, por exemplo: ---- ---- 0000] [1000 ---- ---- Nesse caso apenas o bit A muda, logo podemos juntar! Um caso que n\u00e3o pode juntar s\u00e3o as extremidades: ---- 0000] ---- ---- [1010 ---- Nesse caso A e C mudam! Check-Point [COPY] L\u00f3gica Booleana - Karnaugh 1 Encontre a montagem do mapa de Karnaugh correta. Qual mapa de K. foi montado certo? Qual mapa de K. foi montado certo? Progress Cheguei Aqui! 4. Gerando as equa\u00e7\u00f5es \u00b6 Gera-se uma equa\u00e7\u00e3o por agrupamento, cada grupo ir\u00e1 fornecer um componente na forma da equa\u00e7\u00e3o da Soma Dos Produtos: (. . . ) + (. . . ). O truque \u00e9 identificar no grupo quais s\u00e3o as vari\u00e1veis que assumem todas as possibilidades. Exemplo 1 Nesse caso, a vari\u00e1vel B pode assumir tanto 0 quanto 1 para A fixo em 0 , para o grupo em quest\u00e3o as entradas A e B s\u00e3o: AB: 00 AB: 01 A equa\u00e7\u00e3o feita via a tabela verdade seria: \\(\\bar{A}.B + \\bar{A} . \\bar{B}\\) que pode ser reduzida para \\(\\bar{A} (\\bar{B} + B)\\) e ent\u00e3o para: \\(\\bar{A}\\) O mapa de Karnaugh j\u00e1 nos fornece o resultado de forma direta! Exemplo 2 Nesse caso, a vari\u00e1vel A pode assumir tanto 0 quanto 1 para B fixo em 0 , ou seja, A n\u00e3o impacta nesse grupo. Exemplo 3 Aqui temos um caso particular, para todas as combina\u00e7\u00f5es de entrada A e B a sa\u00edda \u00e9 sempre 1 , logo essa equa\u00e7\u00e3o \u00e9 sempre verdadeira: \\(F = 1\\) . Exemplo 4 Nesse exemplo n\u00e3o foi poss\u00edvel agrupar uns em maior quantidade, logo, n\u00e3o iremos conseguir obter um resultado melhor que a tabela verdade. Nenhuma vari\u00e1vel \u00e9 descart\u00e1vel. Exemplo 5 Nesse caso criamos dois grupos um na horizontal outro na vertical. Cada grupo ir\u00e1 gerar um termo da equa\u00e7\u00e3o na forma da SoP. Casos extras","title":"\u00c1lgebra Booleana"},{"location":"Teoria-Algebra-Booleana/#algebra-booleana","text":"Conte\u00fado: Equa\u00e7\u00f5es; Opera\u00e7\u00f5es (portas l\u00f3gicas); Tabela Verdade; Sintetiza\u00e7\u00e3o de fun\u00e7\u00f5es; Soma dos Produtos; Produto das Somas; Simplifica\u00e7\u00e3o Alg\u00e9brica; Mapa de Karnaught. Estudando Bibliografia [Cap1. Cap2. NISAN, 2005] [Cap6. TOCCI, 2011] [Cap1. FLOYD, 2007] [LAING, 2004] V\u00eddeos (extra) Logic 101 (#11): Truth Tables Logic 101 (#12): Truth Table Practice Computer Science: Karnaugh Maps \u2013 Introduction Computer Science: Karnaugh Maps - 4 vars A \u00e1lgebra booleana foi desenvolvida por George Boole , um matem\u00e1tico brit\u00e2nico que desenvolveu os conceitos em 1847, base da computa\u00e7\u00e3o moderna. Muito tempo depois, nos anos 30, Claude Shannon, um importante engenheiro na hist\u00f3ria da computa\u00e7\u00e3o moderna, aplicou as ideias de Boole em circuitos el\u00e9tricos. Ele trabalhava no Analisador Diferencial de Vannevar Bush, e logo percebeu a rela\u00e7\u00e3o dos rel\u00e9s com \u00e1lgebra booleana. Ele fazia um rel\u00e9 acionar o outro usando usando uma l\u00f3gica bin\u00e1ria do rel\u00e9 fechado ou aberto. Sua disserta\u00e7\u00e3o e artigos, levaram outras pessoas a perceber os benef\u00edcios da \u00e1lgebra booleana em eletr\u00f4nica e consequentemente computa\u00e7\u00e3o. Em \u00c1lgebra Booleana as vari\u00e1veis s\u00f3 podem assumir dois valores. Desligado e ligado, ou falso e verdadeiro, 0 volt e 5 volts, branco e preto. Por\u00e9m normalmente na computa\u00e7\u00e3o usamos 0 e 1 pela conveni\u00eancia. Todos os computadores tem como sua menor unidade de dado, esse elemento. Em computa\u00e7\u00e3o chamamos isso de bit. que vem de d\u00edgito bin\u00e1rio (ou do ingl\u00eas binary digit). Note Bit \u00e9 a unidade mais simples de representa\u00e7\u00e3o de dados digitais, um bit \u00e9 uma unidade que pode assumir apenas dois valores: 0 ou 1 . Com um bit podemos representar o estado de uma luz na sala de aula, se uma cadeira est\u00e1 vazio ou n\u00e3o, .... n\u00e3o conseguimos representar com apenas um bit uma informa\u00e7\u00e3o que n\u00e3o seja bin\u00e1ria. Mas se combinarmos mais de um bit, criando um vetor de bits, somos capazes de representar quantos estados desejarmos. Progress Cheguei Aqui!","title":"\u00c1lgebra Booleana"},{"location":"Teoria-Algebra-Booleana/#equacoes","text":"Uma equa\u00e7\u00e3o de l\u00f3gica booleana pode possuir uma ou mais 'entradas' e apenas uma sa\u00edda, na equa\u00e7\u00e3o exemplo a seguir, X \u00e9 uma sa\u00edda (e pode assumir apenas valor 1 ou 0 ) e A e B s\u00e3o entradas tamb\u00e9m do tipo bin\u00e1ria. X(A,B) = A . B Note A opera\u00e7\u00e3o . \u00e9 chamada de E ( and ) que tamb\u00e9m pode ser representada pelo s\u00edmbolo: ^ X = A and B X = A . B X = A ^ B A opera\u00e7\u00e3o de and pode ser entendida como uma multiplica\u00e7\u00e3o: A sa\u00edda ( X ) s\u00f3 \u00e9 verdadeira se as entradas A e B forem verdadeiras: 1 . 1 = 1 . Como A e B s\u00e3o n\u00fameros bin\u00e1rios, \u00e9 poss\u00edvel encontrar uma tabela que relaciona o TODOS os valor da sa\u00edda X com todas as entradas possiveis: A e B Entrada A Entrada B Sa\u00edda X 0 0 0 0 1 0 1 0 0 1 1 1 Tabela Verdade Essa tabela que acabamos de construir chama tabela verdade , e ser\u00e1 muito utilizada ao longo do curso. Tamb\u00e9m podemos representar essa equa\u00e7\u00e3o X = A . B como sendo um circuito digital: Note Resolver fun\u00e7\u00f5es booleanas \u00e9 entender quando a sa\u00edda ser\u00e1 Verdadeira ou Falsa dado a combina\u00e7\u00e3o poss\u00edvel de entradas. Progress Cheguei Aqui!","title":"Equa\u00e7\u00f5es"},{"location":"Teoria-Algebra-Booleana/#operacoes","text":"O and utilizado no exemplo anterior \u00e9 um operador da l\u00f3gica booleana, operadores possuem uma ou mais entradas e geram uma sa\u00edda. Os operadores mais comuns s\u00e3o: not , and , or , nand , nor , xor .","title":"Opera\u00e7\u00f5es"},{"location":"Teoria-Algebra-Booleana/#not","text":"O operador not atua sobre uma vari\u00e1vel, tornando a sa\u00edda o inverso da entrada, ou seja, se a entrada do operador for 1 sua sa\u00edda ser\u00e1 0 e vice versa. Uso: a luz interna do carro ser\u00e1 acesa ('1') quando a porta estiver fechada ('0'). Nota\u00e7\u00e3o: not , - , ~ , \u00ac : X = not A / X = A / X = \u00c3 / X = \u00ac A Tabela Verdade: Entrada A X = not A 0 1 1 0 Simbologia:","title":"not"},{"location":"Teoria-Algebra-Booleana/#and","text":"O operador and atua sobre duas vari\u00e1vel, tornando a sa\u00edda verdadeira somente se as duas entradas forem verdadeiras , se uma das entradas forem falsa a sa\u00edda ser\u00e1 falsa . Uso: o cofre ser\u00e1 aberto somente quando as duas chaves de seguran\u00e7as forem inseridas. Nota\u00e7\u00e3o: and , . , ^ : X = A and B / X = A . B / X = A ^ B Tabela Verdade: A B X = A and B 0 0 0 0 1 0 1 0 0 1 1 1 Simbologia:","title":"and"},{"location":"Teoria-Algebra-Booleana/#or","text":"O operador or atua sobre duas vari\u00e1vel, tornando a sa\u00edda verdadeira sempre que uma das entradas forem verdadeira . Uso: O alarme de inc\u00eandio ser\u00e1 acionado caso alguns dois dois bot\u00f5es sejam pressionados. Nota\u00e7\u00e3o: or , + , v : X = A or B / X = A + B / X = A v B Tabela Verdade: A B X = A or B 0 0 0 0 1 1 1 0 1 1 1 1 Simbologia:","title":"or"},{"location":"Teoria-Algebra-Booleana/#nand","text":"Podemos come\u00e7ar a 'unir' operadores para formar novos comportamentos, o nand \u00e9 a invers\u00e3o ( not ) da porta l\u00f3gica and . Na porta nand a sa\u00edda s\u00f3 \u00e9 verdadeira quando as entradas s\u00e3o falsas . Uso: Soar o alarme se os sensores de batimento card\u00edaco e o de press\u00e3o falharem. Nota\u00e7\u00e3o: nand , \u00ac( \u2227 ) _____ X = A nand B / X = A . B / X = \u00ac(A \u2227 B) Tabela Verdade: A B X = A nand B 0 0 1 0 1 1 1 0 1 1 1 0 Simbologia:","title":"nand"},{"location":"Teoria-Algebra-Booleana/#nor-xor-xnor","text":"Para as demais portas l\u00f3gicas, consulte a refer\u00eancia: https://en.wikipedia.org/wiki/Logic_gate#Symbols Estudar as portas pois iremos precisar que voc\u00eas saibam. Check-Point","title":"nor / xor / xnor"},{"location":"Teoria-Algebra-Booleana/#tabela-verdade","text":"Nessa tabela criamos colunas para cada vari\u00e1vel de entrada e de sa\u00edda e colocamos as situa\u00e7\u00f5es poss\u00edveis (resultado). Para construirmos uma tabela verdade basta seguir as regras a seguir (na sequ\u00eancia): Criar uma coluna para cada entrada do sistema (n) Criar uma coluna para cada sa\u00edda do sistema A tabela verdade vai ter 2^n n\u00fameros de linhas (onde n \u00e9 a quantidade de entradas) um sistema com 2 entradas possui 2\u00b2 = 4 linhas um sistema com 3 entradas possui 2\u00b3 = 8 linhas ... Preencher as entradas (com '1's e '0's ) de forma a cobrir todas as possibilidades. Para cada linha, analisar se a combina\u00e7\u00e3o de '1's e '0' torna a sa\u00edda '1' e '0' Check-Point","title":"Tabela Verdade"},{"location":"Teoria-Algebra-Booleana/#funcoes-geradas-a-partir-de-tabelas-verdade","text":"\u00c9 poss\u00edvel a partir de uma tabela verdade obter uma equa\u00e7\u00e3o l\u00f3gica que a represente (caminho inverso), podemos fazer isso por duas t\u00e9cnicas diferentes (chamadas de forma can\u00f4nicas): Soma dos Produtos (SoP) Produto das Somas (PoS)","title":"Fun\u00e7\u00f5es geradas a partir de Tabelas Verdade"},{"location":"Teoria-Algebra-Booleana/#soma-dos-produtos","text":"Na soma dos produtos iremos encontrar uma equa\u00e7\u00e3o booleana que possui a seguinte forma: X = ( . . . ) + ( . . . ) + ... + ( . . . ) ----- | | = '1' Nesse m\u00e9todo, precisamos encontrar as linhas da tabela verdade que resultam em uma sa\u00edda '1' (Verdadeira) e invertendo (ou n\u00e3o) as entradas fazendo com que o termo ( . . . .) resulte em '1' para a linha em quest\u00e3o.","title":"Soma Dos Produtos"},{"location":"Teoria-Algebra-Booleana/#produto-das-somas","text":"X = ( + + + ) . ( + + + ) . ... . ( + + + ) ----- | | = '0' Nesse m\u00e9todo, precisamos encontrar as linhas da tabela verdade que resultam em uma sa\u00edda '0' e invertendo (ou n\u00e3o) as entradas fazendo com que o termo ( . . . .) resulte em '0' para a linha em quest\u00e3o. Example Check-Point","title":"Produto das somas"},{"location":"Teoria-Algebra-Booleana/#simplificacao","text":"Existem duas formas bastante populares de simplificar uma equa\u00e7\u00e3o booleana: alg\u00e9brica ou via mapa de Karnaugh. Veremos as duas com mais detalhes.","title":"Simplifica\u00e7\u00e3o"},{"location":"Teoria-Algebra-Booleana/#simplificacao-algebrica","text":"Na simplifica\u00e7\u00e3o alg\u00e9brica iremos utilizar as seguintes propriedades de l\u00f3gica booleana para nos ajudar a simplificar uma equa\u00e7\u00e3o: Explica\u00e7\u00e3o da tabela Para essas simplifica\u00e7\u00f5es n\u00f3s usaremos as propriedades das opera\u00e7\u00f5es b\u00e1sicas de \u00e1lgebra booleana, representada na tabela anterior. As leis da identidade, comutatividade, associatividade e distributividade s\u00e3o bem similares ao que j\u00e1 fazemos normalmente em express\u00f5es matem\u00e1ticas. A idempot\u00eancia mostra que um AND ou OR com duas vari\u00e1veis \u00e9 exatamente a mesma vari\u00e1vel. A lei do complemento duplo mostra que se negarmos duas vezes uma vari\u00e1vel, teremos a mesma vari\u00e1vel. A lei da complementariedade j\u00e1 mostra que fazermos um AND com a nega\u00e7\u00e3o da mesma vari\u00e1vel acabaremos com zero, ou seja, 0 vezes 1 ou 1 vezes 0 sempre dar\u00e1 zero. J\u00e1 com o OR \u00e9 o oposto e sempre teremos 1 como resposta. Na lei da interse\u00e7\u00e3o temos que uma vari\u00e1vel vezes 1 \u00e9 sempre ela mesma, e se for vezes 0, acabara zerando o resultado. J\u00e1 a lei da uni\u00e3o diz que uma vari\u00e1vel mais um \u00e9 sempre um, e uma vari\u00e1vel mais zero \u00e9 a pr\u00f3pria vari\u00e1vel. O teorema de DeMorgam \u00e9 bem interessante, pois mostra uma propriedade bem peculiar da \u00e1lgebra booleana, no caso o conjunto de A vezes B negado, \u00e9 o mesmo que A negado, mais B negado, e da mesma forma A negado mais B negado \u00e9 igual ao A vezes B, e esse resultado negado. Para simplificarmos uma equa\u00e7\u00e3o, aplicamos as propriedades da tabela anterior a fim de encontrarmos uma equa\u00e7\u00e3o que: Tenha uma forma mais explicita de sua propriedade exe: \\(A . B + A . C\\) -> \\(A (B + C)\\) Minimize o uso de 'portas l\u00f3gicas' exe: \\((A . B) . C + A . B . D\\) -> \\((A . B)(C + D)\\) Elimine minimize as entradas necess\u00e1rias exe: \\(( (A + \\overline{A}).B)\\) -> \\(B\\) Progress Cheguei Aqui!","title":"Simplifica\u00e7\u00e3o alg\u00e9brica"},{"location":"Teoria-Algebra-Booleana/#exemplos","text":"Exemplo 1 Exemplo 2 Exemplo 3 Tip O v\u00eddeo a seguir possui as resolu\u00e7\u00f5es de forma detalhada:","title":"Exemplos"},{"location":"Teoria-Algebra-Booleana/#mapa-de-karnaugh-mk","text":"A simplifica\u00e7\u00e3o por mapa de Karnaugh \u00e9 uma t\u00e9cnica visual de encontrarmos uma equa\u00e7\u00e3o reduzida, por\u00e9m para isso precisamos primeiro: Gerar a tabela verdade Gerar o mapa de Karnaugh Criar os grupos Gerar as equa\u00e7\u00f5es","title":"Mapa de Karnaugh (MK)"},{"location":"Teoria-Algebra-Booleana/#2-criando-o-mapa","text":"O mapa pode ser criado para N entradas, mas s\u00f3 iremos tratar nesse curso sistemas de 2 , 3 ou 4 vari\u00e1veis (entradas). A seguir exemplos do mapa para 2, 3 e 4 entradas: Para criar o mapa basta seguir a receitinha anterior, note que a sequ\u00eancia das entras: AB e CD \u00e9 da forma: __ _ _ AB AB AB AB ----------- AB \\ 00 01 11 10 e n\u00e3o: AB \\ 00 01 10 11 Como seria mais l\u00f3gico (j\u00e1 que em bin\u00e1rio: 00 = 0; 01 = 1; 10 = 2; 11 = 3 ). Por\u00e9m o mapa de Karnaugh assume que as vari\u00e1veis est\u00e3o ordenadas na forma de c\u00f3digo gray , onde um bit \u00e9 alterado por vez! Warning Colocar qualquer sequ\u00eancia na cria\u00e7\u00e3o do mapa \u00e9 um dos erros mais comuns dos anos anteriores! Tip Podemos come\u00e7ar a sequ\u00eancia com qualquer combina\u00e7\u00e3o, se seguirmos a ordem de s\u00f3 mudar um bit por vez, exemplo: AB \\ 11 10 00 01 AB \\ 01 11 10 00 Check-Point","title":"2. Criando o Mapa"},{"location":"Teoria-Algebra-Booleana/#3-grupos","text":"No MK podemos agrupar '1's na quantidade de: \\(2^n\\) , onde n=0,1,2,3, ou seja, grupos de: 1, 2, 4, 8, ... , o agrupamento s\u00f3 pode ser feito na vertical ou horizontal, nunca na diagonal. Tip Os grupos podem se sobrepor! Agrupar sempre na maior quantidade poss\u00edvel (2, 4, 8, ...) Devemos agrupar sempre na maior quantidade poss\u00edvel! A seguir exemplos do que n\u00e3o deve ser feito! Note N\u00e3o agrupar na maior quantidade de uns poss\u00edvel impacta em n\u00e3o obter a equa\u00e7\u00e3o reduzida. Podemos pensar no MK n\u00e3o como sendo uma tabela plana , mas sim uma superf\u00edcie mapeada em uma esfera, logo as pontas est\u00e3o conectadas. Com isso podemos criar grupos nas situa\u00e7\u00f5es a seguir: Tip O agrupamento no mapa de Karnaugh s\u00f3 pode ser realizado quando juntamos uns que est\u00e3o a um bit de dist\u00e2ncia. Essa \u00e9 a raz\u00e3o de n\u00e3o podermos juntar na diagonal. AB 00 01 11 10 CD \\--------------------- 00 | 0000 0100 1100 1000 10 | 0010 0110 1110 1010 11 | 0011 0111 1111 1011 10 | 0010 0110 1110 1010 Note que no exemplo anterior se juntarmos duas possibilidades na horizontal (as duas primeira): --------- [0000 0100] --------- Apenas o bit referente a entrada B muda. Mas se considerarmos a diagonal: ---- [0000 0110] ---- Temos duas mudan\u00e7as de bit, a da entrada B e a da entrada C , isso n\u00e3o pode! O ultimo caso s\u00e3o os cantos, por exemplo: ---- ---- 0000] [1000 ---- ---- Nesse caso apenas o bit A muda, logo podemos juntar! Um caso que n\u00e3o pode juntar s\u00e3o as extremidades: ---- 0000] ---- ---- [1010 ---- Nesse caso A e C mudam! Check-Point","title":"3. Grupos"},{"location":"Teoria-Algebra-Booleana/#4-gerando-as-equacoes","text":"Gera-se uma equa\u00e7\u00e3o por agrupamento, cada grupo ir\u00e1 fornecer um componente na forma da equa\u00e7\u00e3o da Soma Dos Produtos: (. . . ) + (. . . ). O truque \u00e9 identificar no grupo quais s\u00e3o as vari\u00e1veis que assumem todas as possibilidades. Exemplo 1 Nesse caso, a vari\u00e1vel B pode assumir tanto 0 quanto 1 para A fixo em 0 , para o grupo em quest\u00e3o as entradas A e B s\u00e3o: AB: 00 AB: 01 A equa\u00e7\u00e3o feita via a tabela verdade seria: \\(\\bar{A}.B + \\bar{A} . \\bar{B}\\) que pode ser reduzida para \\(\\bar{A} (\\bar{B} + B)\\) e ent\u00e3o para: \\(\\bar{A}\\) O mapa de Karnaugh j\u00e1 nos fornece o resultado de forma direta! Exemplo 2 Nesse caso, a vari\u00e1vel A pode assumir tanto 0 quanto 1 para B fixo em 0 , ou seja, A n\u00e3o impacta nesse grupo. Exemplo 3 Aqui temos um caso particular, para todas as combina\u00e7\u00f5es de entrada A e B a sa\u00edda \u00e9 sempre 1 , logo essa equa\u00e7\u00e3o \u00e9 sempre verdadeira: \\(F = 1\\) . Exemplo 4 Nesse exemplo n\u00e3o foi poss\u00edvel agrupar uns em maior quantidade, logo, n\u00e3o iremos conseguir obter um resultado melhor que a tabela verdade. Nenhuma vari\u00e1vel \u00e9 descart\u00e1vel. Exemplo 5 Nesse caso criamos dois grupos um na horizontal outro na vertical. Cada grupo ir\u00e1 gerar um termo da equa\u00e7\u00e3o na forma da SoP. Casos extras","title":"4. Gerando as equa\u00e7\u00f5es"},{"location":"Teoria-Aritmetica-Binaria-HW/","text":"Aritm\u00e9tica Bin\u00e1ria - HW \u00b6 Conte\u00fado: hald-adder/ full-adder/ somador Tip Esse conte\u00fado est\u00e1 no cap. 2 do livro texto da disciplina The Elements of Computing Systems . Precisamos lembrar que nosso objetivo principal \u00e9 a cria\u00e7\u00e3o de um hardware capaz de operar com n\u00fameros bin\u00e1rios. Nessa teoria iremos analisar algumas t\u00e9cnicas de realizar o hardware necess\u00e1rio para realizar opera\u00e7\u00e3o de soma bin\u00e1ria entre dois vetores. Para isso iremos definir dois componentes: Half-Adder e o Full-Adder. half-adder (HAD) \u00b6 Half-Adder (HAD) \u00e9 um circuito digital capaz de somar dois bits ( a e b ), tem como resultado o valor da soma e do carry , como ilustrado a seguir: ------ a -->| |--> Soma | HA | b -->| |--> Carry ------ O HAD possui a seguinte tabela verdade: a b Carry (out) Soma (out) 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 E \u00e9 implementado em hardware da seguinte maneira: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) full-adder (FAD) \u00b6 Full-adder \u00e9 um componente digital capaz de somar tr\u00eas vits ( a , b e c ) e possui como sa\u00edda o valor da soma e do carry resultante da opera\u00e7\u00e3o. A seguir um diagrama de blocos de um FAD : Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) O FAD possui a seguinte tabela verdade: a b c Carry (out) Soma (out) 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1 E \u00e9 implementado da seguinte maneira em portas l\u00f3gicas: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) Tip Voc\u00ea deve ser capaz de encontrar esses circuitos analisando a tabela verdade e simplificando via Mapa de K. Note que existem duas abordagens para representar o Carry_out: A.B+A.C+B.C e A.B+C(A xor B) Fonte: (2011) Fundamentals of Digital and Computer Design with VHDL, pg 199. Somador \u00b6 Tip Utilizando o FAD somos capazes de realizar um somador de dois vetores bin\u00e1rios. Para isso, teremos que utilizar um full-adder para cada bit desse nosso vetor. Por exemplo: se formos criar um Somador capaz de somar dois vetores de 4bits , necessitamos utilizar 4 FAD para isso com a liga\u00e7\u00e3o descrita a seguir: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) Nesse diagrama, estamos realizando a soma ente os vetores A(3 downto 0) e B(3 downto 0) que resulta em um outro vetor S(3 downto 0) e um carry C4 .","title":"Aritm\u00e9tica Bin\u00e1ria - HW"},{"location":"Teoria-Aritmetica-Binaria-HW/#aritmetica-binaria-hw","text":"Conte\u00fado: hald-adder/ full-adder/ somador Tip Esse conte\u00fado est\u00e1 no cap. 2 do livro texto da disciplina The Elements of Computing Systems . Precisamos lembrar que nosso objetivo principal \u00e9 a cria\u00e7\u00e3o de um hardware capaz de operar com n\u00fameros bin\u00e1rios. Nessa teoria iremos analisar algumas t\u00e9cnicas de realizar o hardware necess\u00e1rio para realizar opera\u00e7\u00e3o de soma bin\u00e1ria entre dois vetores. Para isso iremos definir dois componentes: Half-Adder e o Full-Adder.","title":"Aritm\u00e9tica Bin\u00e1ria - HW"},{"location":"Teoria-Aritmetica-Binaria-HW/#half-adder-had","text":"Half-Adder (HAD) \u00e9 um circuito digital capaz de somar dois bits ( a e b ), tem como resultado o valor da soma e do carry , como ilustrado a seguir: ------ a -->| |--> Soma | HA | b -->| |--> Carry ------ O HAD possui a seguinte tabela verdade: a b Carry (out) Soma (out) 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 E \u00e9 implementado em hardware da seguinte maneira: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics )","title":"half-adder (HAD)"},{"location":"Teoria-Aritmetica-Binaria-HW/#full-adder-fad","text":"Full-adder \u00e9 um componente digital capaz de somar tr\u00eas vits ( a , b e c ) e possui como sa\u00edda o valor da soma e do carry resultante da opera\u00e7\u00e3o. A seguir um diagrama de blocos de um FAD : Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) O FAD possui a seguinte tabela verdade: a b c Carry (out) Soma (out) 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1 E \u00e9 implementado da seguinte maneira em portas l\u00f3gicas: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) Tip Voc\u00ea deve ser capaz de encontrar esses circuitos analisando a tabela verdade e simplificando via Mapa de K. Note que existem duas abordagens para representar o Carry_out: A.B+A.C+B.C e A.B+C(A xor B) Fonte: (2011) Fundamentals of Digital and Computer Design with VHDL, pg 199.","title":"full-adder (FAD)"},{"location":"Teoria-Aritmetica-Binaria-HW/#somador","text":"Tip Utilizando o FAD somos capazes de realizar um somador de dois vetores bin\u00e1rios. Para isso, teremos que utilizar um full-adder para cada bit desse nosso vetor. Por exemplo: se formos criar um Somador capaz de somar dois vetores de 4bits , necessitamos utilizar 4 FAD para isso com a liga\u00e7\u00e3o descrita a seguir: Fonte: https://en.wikipedia.org/wiki/Adder_(electronics ) Nesse diagrama, estamos realizando a soma ente os vetores A(3 downto 0) e B(3 downto 0) que resulta em um outro vetor S(3 downto 0) e um carry C4 .","title":"Somador"},{"location":"Teoria-Aritmetica-Binaria/","text":"Aritm\u00e9tica Bin\u00e1ria \u00b6 2020-2 Material atualizado. Conte\u00fado: Complemento de um/ Complemento de dois/ Ponto fixo/ Soma bin\u00e1ria/ Podemos utilizar n\u00fameros bin\u00e1rios para codificar qualquer tipo de dado, como vimos na teoria de dados digitais. Mas ainda n\u00e3o sabemos como utilizar n\u00fameros bin\u00e1rios para representar: n\u00fameros inteiros que possam ser negativos e n\u00fameros reais fracionados (exemplo: -15 ; 1,032 ; -0,0001 ; 10001231231 ). Essa teoria ir\u00e1 tratar desses temas e tamb\u00e9m da parte referente a opera\u00e7\u00f5es com n\u00fameros bin\u00e1rios (soma e subtra\u00e7\u00e3o). Soma bin\u00e1ria \u00b6 A soma bin\u00e1ria \u00e9 realizada de maneira similar a soma de decimais, s\u00f3 que precisamos refor\u00e7ar que 1+1 em bin\u00e1rio ( esse + \u00e9 de soma n\u00e3o de OR ), resulta em 10 , o 1 do estouro e que passa para a pr\u00f3xima casa \u00e9 chamado de carry . Esse carry \u00e9 similar ao vai um em uma soma decimal, por exemplo: quando somamos em decimal 9 + 3 o resultado \u00e9 12 (10 + 2). Exemplos a seguir consideram Palavras bin\u00e1rias com 8 bits N\u00fameros inteiros positivos Tip 01 + 01 = 10 01 + 01 + 01 = 11 10 + 10 = 100 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) 0x2B + 0x57 = 0xFF 1 1 1 1 1 1 1 : Carry 0 0 1 0 1 0 1 1 : A 0 1 0 1 0 1 1 1 + : B --------------- 1 0 0 0 0 0 1 0 : Resultado (A+B) Precisamos entender que cada bit deve ser armazenado em hardware! Um sistema com 8 bits n\u00e3o consegue armazenar 9 bits, e se houver um estouro no \u00faltimo bit essa informa\u00e7\u00e3o ser\u00e1 perdida. Note Os bits s\u00e3o armazenados na mem\u00f3ria, as mem\u00f3rias armazenam vetores de bits. Computadores reais n\u00e3o possuem mem\u00f3ria infinita e nem largura de bits infinita. 0x80 + 0x80 = 0x100, mas resulta em 0x00 por conta do somador ser 8 bits: carry \u00e9 perdido x \\ 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 + --------------- 0 0 0 0 0 0 0 0 0x03 + 0x81 = 0x84 1 1 : carry (vai um) \\ 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 + --------------- 1 0 0 0 0 1 0 0 Complemento de um \u00b6 Warning Forma errada/ n\u00e3o usual de armazenar n\u00fameros sinalizados (+, -) Exemplos a seguir consideram Palavras bin\u00e1rias com 8 bits N\u00fameros inteiros positivos No complemento de um , utilizamos a casa/bit mais significativa de um vetor de bits para representar se o n\u00famero \u00e9 positivo ( 0 ) ou negativo ( 1 ). Exemplo (utilizando 8 bits): Valor +1 em bin\u00e1rio, com complemento de 1 00000001 ^ | indica que o valor \u00e9 positivo Valor -1 em bin\u00e1rio, com complemento de 1 10000001 ^ | indica que o valor \u00e9 negativo O problema do complemento de 1 \u00e9 que: Possu\u00edmos duas representa\u00e7\u00f5es para o valor 0: 00000000 e 10000000 Opera\u00e7\u00f5es de soma n\u00e3o funcionam corretamente entre os dois n\u00fameros codificados em complemento de um. Exemplo: 1 - 1 = -2 e n\u00e3o 0 1 : carry (vai um) \\ 0 0 0 0 0 0 0 1 : +1 1 0 0 0 0 0 0 1 + : -1 --------------- 1 0 0 0 0 0 1 0 : -2 e n\u00e3o 0 Tabela com 3 bits Decimal Bin\u00e1rio em complemento de 1 3 011 2 010 1 001 0 000 / 100 -1 101 -2 110 -3 111 Complemento de 2 \u00b6 O complemento de dois \u00e9 uma outra maneira de representar n\u00fameros sinalizados com bits, essa t\u00e9cnica possui alguams vantagens: Uma \u00fanica representa\u00e7\u00e3o para o valor 0: 0000 A opera\u00e7\u00e3o de soma/ subtra\u00e7\u00e3o funciona corretamente! O bit mais significativo indica se a palavra \u00e9 positiva ( 0 ) ou negativa ( 1 ). Para obter um n\u00famero positivo \u2194 negativo nessa nota\u00e7\u00e3o \u00e9 necess\u00e1rio seguir os seguintes passos: Escreva o valor em bin\u00e1rio (positivo) Inverter todos os bits (not bit a bit) da palavra original Somar o valor 1 a palavra invertida. Exemplo: -3 = 11111101 0 0 0 0 0 0 1 1 : 3 ----------------------- 1 1 1 1 1 1 0 0 : not bit a bit da palavra original 0 0 0 0 + 1 : Soma um a palavra invertida ----------------------- 1 1 1 1 1 1 0 1 <-- -3 em complemento de 2 Exemplo: -5 = 111111011 0 0 0 0 0 1 0 1 : 5 ----------------------- 1 1 1 1 1 0 1 0 : not bit a bit da palavra original 0 0 0 0 0 0 0 1 + : Soma um a palavra invertida ----------------------- 1 1 1 1 1 0 1 1 <-- -5 em complemento de 2 Exemplo (com 4 bits para simplificar): -9 (n\u00e3o funciona porque n\u00e3o cabe) (exemplo com 4 bits!) 1 0 0 1 : 9 0 1 1 0 : not bit a bit da palavra original + 1 : Soma um a palavra invertida 0 1 1 1 <-- 7 !! (n\u00e3o funcionou) ^ | n\u00e3o funcionou =( O exemplo anterior n\u00e3o funciona pois faltam bits para representar o valor -9 , para isso seria necess\u00e1rio 5 bits e n\u00e3o 4 como no exemplo. Tabela com 3 bits Decimal Bin\u00e1rio em complemento de dois 3 011 2 010 1 001 0 000 -1 111 -2 110 -3 101 -4 100 Multiplica\u00e7\u00e3o/ Divis\u00e3o por m\u00faltiplo de 2 \u00b6 Assumindo Um n\u00famero positivo Em bin\u00e1rio, para multiplicar uma palavra (positiva) por 2 basta rotacionar todos os bits uma casa para esquerda. Para dividir por 2 basta rotacionar todos os bits uma vez para direita (sempre colocando 0 no bit que entra e desaparecendo com o bit que sai). Exemplos a seguir: 2 x 1 ( 00000001 ) = 2 00000010 <-- 1x 00000001 => 00000010 2 x 4 ( 00000100 ) = 8 00001000 <-- 1x 00000100 => 00001000 9 ( 00001001 ) / 2 = 4 00000100 1x --> 00001001 => 00000100 Note A divis\u00e3o de 9/2 retorna um n\u00famero inteiro. Isso se d\u00e1 devido a t\u00e9cnica s\u00f3 funcionar com n\u00fameros inteiros. Essa t\u00e9cnica de rotacionar vale para m\u00faltiplos de 2, se deseja multiplicar/dividir por M , onde M \u00e9 um m\u00faltiplo de 2 ( M=Nx2 ), \u00e9 necess\u00e1rio rotacionar o vetor de bits N vezes: exemplo: 4 x 1 ( 00000001 ) = 00000100 <-- 2x 00000001 => 00000100 Ponto fixo \u00b6 Ponto fixo \u00e9 uma das t\u00e9cnicas de representa\u00e7\u00e3o de n\u00fameros fracionados em bin\u00e1rio, nessa nota\u00e7\u00e3o fixasse quantos bits ser\u00e3o utilizados para a parte inteira e quantos ser\u00e3o utilizados para a fra\u00e7\u00e3o. \u00c9 aplicado o mesmo conceito dos n\u00fameros decimais, as casas a direita do ponto possuem peso na ordem 2^-n . Vamos pegar como exemplo o valor 26.5 , e assumindo que estamos trabalhando com uma palavra de 8 bits onde o ponto est\u00e1 localizado no bit 3 : XXXXX.YYY . Nesse caso, cada casa bin\u00e1ria possui o peso a seguir: 2^5 2^4 2^3 2^2 2^1 2^0 2^-1 2^-2 2^-3 32 16 8 4 2 1 0.5 0.25 0.125 Para construirmos o valor 26.5 basta selecionarmos os bits que somados d\u00e3o esse valor: 011010100 : 0*32 + 1*16 + 1*8 + 0*4 + 1*2 + 0*1 + 1*0.5 + 0*0.025 + 0*0.125 = 26.5 A quest\u00e3o dessa nota\u00e7\u00e3o \u00e9 que uma vez escolhido onde o ponto vai estar localizado (projeto de hardware) n\u00e3o da para mudar depois, se o n\u00famero a ser armazenado \u00e9 apenas fra\u00e7\u00e3o, perdemos muitos bits sem uso com a parte inteira, o que faz possuirmos menor resolu\u00e7\u00e3o. A solu\u00e7\u00e3o para isso \u00e9 a nota\u00e7\u00e3o de ponto flutuante - IEEE 754 voc\u00eas v\u00e3o ver isso na disciplina de Sistemas Hardware Software do 5s). Ponto flutuante \u00b6 Ponto flutuante \u00e9 uma outra nota\u00e7\u00e3o na qual \u00e9 poss\u00edvel representar n\u00fameros racionais digitalmente (bin\u00e1rio), nessa t\u00e9cnica a v\u00edrgula n\u00e3o \u00e9 fixa, e a nota\u00e7\u00e3o pode se adequar para armazenar n\u00fameros muito trandes ou muito pequenos. No entanto, existe um custo computacional mais elevado envolvido nisso. Processadores modernos possuem um hardware (ULA) dedicada a realizar opera\u00e7\u00f5es em ponto flutuante, normalmente usando o padr\u00e3o IEEE 754 .","title":"Aritm\u00e9tica Bin\u00e1ria"},{"location":"Teoria-Aritmetica-Binaria/#aritmetica-binaria","text":"2020-2 Material atualizado. Conte\u00fado: Complemento de um/ Complemento de dois/ Ponto fixo/ Soma bin\u00e1ria/ Podemos utilizar n\u00fameros bin\u00e1rios para codificar qualquer tipo de dado, como vimos na teoria de dados digitais. Mas ainda n\u00e3o sabemos como utilizar n\u00fameros bin\u00e1rios para representar: n\u00fameros inteiros que possam ser negativos e n\u00fameros reais fracionados (exemplo: -15 ; 1,032 ; -0,0001 ; 10001231231 ). Essa teoria ir\u00e1 tratar desses temas e tamb\u00e9m da parte referente a opera\u00e7\u00f5es com n\u00fameros bin\u00e1rios (soma e subtra\u00e7\u00e3o).","title":"Aritm\u00e9tica Bin\u00e1ria"},{"location":"Teoria-Aritmetica-Binaria/#soma-binaria","text":"A soma bin\u00e1ria \u00e9 realizada de maneira similar a soma de decimais, s\u00f3 que precisamos refor\u00e7ar que 1+1 em bin\u00e1rio ( esse + \u00e9 de soma n\u00e3o de OR ), resulta em 10 , o 1 do estouro e que passa para a pr\u00f3xima casa \u00e9 chamado de carry . Esse carry \u00e9 similar ao vai um em uma soma decimal, por exemplo: quando somamos em decimal 9 + 3 o resultado \u00e9 12 (10 + 2). Exemplos a seguir consideram Palavras bin\u00e1rias com 8 bits N\u00fameros inteiros positivos Tip 01 + 01 = 10 01 + 01 + 01 = 11 10 + 10 = 100 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) 0x2B + 0x57 = 0xFF 1 1 1 1 1 1 1 : Carry 0 0 1 0 1 0 1 1 : A 0 1 0 1 0 1 1 1 + : B --------------- 1 0 0 0 0 0 1 0 : Resultado (A+B) Precisamos entender que cada bit deve ser armazenado em hardware! Um sistema com 8 bits n\u00e3o consegue armazenar 9 bits, e se houver um estouro no \u00faltimo bit essa informa\u00e7\u00e3o ser\u00e1 perdida. Note Os bits s\u00e3o armazenados na mem\u00f3ria, as mem\u00f3rias armazenam vetores de bits. Computadores reais n\u00e3o possuem mem\u00f3ria infinita e nem largura de bits infinita. 0x80 + 0x80 = 0x100, mas resulta em 0x00 por conta do somador ser 8 bits: carry \u00e9 perdido x \\ 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 + --------------- 0 0 0 0 0 0 0 0 0x03 + 0x81 = 0x84 1 1 : carry (vai um) \\ 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 + --------------- 1 0 0 0 0 1 0 0","title":"Soma bin\u00e1ria"},{"location":"Teoria-Aritmetica-Binaria/#complemento-de-um","text":"Warning Forma errada/ n\u00e3o usual de armazenar n\u00fameros sinalizados (+, -) Exemplos a seguir consideram Palavras bin\u00e1rias com 8 bits N\u00fameros inteiros positivos No complemento de um , utilizamos a casa/bit mais significativa de um vetor de bits para representar se o n\u00famero \u00e9 positivo ( 0 ) ou negativo ( 1 ). Exemplo (utilizando 8 bits): Valor +1 em bin\u00e1rio, com complemento de 1 00000001 ^ | indica que o valor \u00e9 positivo Valor -1 em bin\u00e1rio, com complemento de 1 10000001 ^ | indica que o valor \u00e9 negativo O problema do complemento de 1 \u00e9 que: Possu\u00edmos duas representa\u00e7\u00f5es para o valor 0: 00000000 e 10000000 Opera\u00e7\u00f5es de soma n\u00e3o funcionam corretamente entre os dois n\u00fameros codificados em complemento de um. Exemplo: 1 - 1 = -2 e n\u00e3o 0 1 : carry (vai um) \\ 0 0 0 0 0 0 0 1 : +1 1 0 0 0 0 0 0 1 + : -1 --------------- 1 0 0 0 0 0 1 0 : -2 e n\u00e3o 0 Tabela com 3 bits Decimal Bin\u00e1rio em complemento de 1 3 011 2 010 1 001 0 000 / 100 -1 101 -2 110 -3 111","title":"Complemento de um"},{"location":"Teoria-Aritmetica-Binaria/#complemento-de-2","text":"O complemento de dois \u00e9 uma outra maneira de representar n\u00fameros sinalizados com bits, essa t\u00e9cnica possui alguams vantagens: Uma \u00fanica representa\u00e7\u00e3o para o valor 0: 0000 A opera\u00e7\u00e3o de soma/ subtra\u00e7\u00e3o funciona corretamente! O bit mais significativo indica se a palavra \u00e9 positiva ( 0 ) ou negativa ( 1 ). Para obter um n\u00famero positivo \u2194 negativo nessa nota\u00e7\u00e3o \u00e9 necess\u00e1rio seguir os seguintes passos: Escreva o valor em bin\u00e1rio (positivo) Inverter todos os bits (not bit a bit) da palavra original Somar o valor 1 a palavra invertida. Exemplo: -3 = 11111101 0 0 0 0 0 0 1 1 : 3 ----------------------- 1 1 1 1 1 1 0 0 : not bit a bit da palavra original 0 0 0 0 + 1 : Soma um a palavra invertida ----------------------- 1 1 1 1 1 1 0 1 <-- -3 em complemento de 2 Exemplo: -5 = 111111011 0 0 0 0 0 1 0 1 : 5 ----------------------- 1 1 1 1 1 0 1 0 : not bit a bit da palavra original 0 0 0 0 0 0 0 1 + : Soma um a palavra invertida ----------------------- 1 1 1 1 1 0 1 1 <-- -5 em complemento de 2 Exemplo (com 4 bits para simplificar): -9 (n\u00e3o funciona porque n\u00e3o cabe) (exemplo com 4 bits!) 1 0 0 1 : 9 0 1 1 0 : not bit a bit da palavra original + 1 : Soma um a palavra invertida 0 1 1 1 <-- 7 !! (n\u00e3o funcionou) ^ | n\u00e3o funcionou =( O exemplo anterior n\u00e3o funciona pois faltam bits para representar o valor -9 , para isso seria necess\u00e1rio 5 bits e n\u00e3o 4 como no exemplo. Tabela com 3 bits Decimal Bin\u00e1rio em complemento de dois 3 011 2 010 1 001 0 000 -1 111 -2 110 -3 101 -4 100","title":"Complemento de 2"},{"location":"Teoria-Aritmetica-Binaria/#multiplicacao-divisao-por-multiplo-de-2","text":"Assumindo Um n\u00famero positivo Em bin\u00e1rio, para multiplicar uma palavra (positiva) por 2 basta rotacionar todos os bits uma casa para esquerda. Para dividir por 2 basta rotacionar todos os bits uma vez para direita (sempre colocando 0 no bit que entra e desaparecendo com o bit que sai). Exemplos a seguir: 2 x 1 ( 00000001 ) = 2 00000010 <-- 1x 00000001 => 00000010 2 x 4 ( 00000100 ) = 8 00001000 <-- 1x 00000100 => 00001000 9 ( 00001001 ) / 2 = 4 00000100 1x --> 00001001 => 00000100 Note A divis\u00e3o de 9/2 retorna um n\u00famero inteiro. Isso se d\u00e1 devido a t\u00e9cnica s\u00f3 funcionar com n\u00fameros inteiros. Essa t\u00e9cnica de rotacionar vale para m\u00faltiplos de 2, se deseja multiplicar/dividir por M , onde M \u00e9 um m\u00faltiplo de 2 ( M=Nx2 ), \u00e9 necess\u00e1rio rotacionar o vetor de bits N vezes: exemplo: 4 x 1 ( 00000001 ) = 00000100 <-- 2x 00000001 => 00000100","title":"Multiplica\u00e7\u00e3o/ Divis\u00e3o por m\u00faltiplo de 2"},{"location":"Teoria-Aritmetica-Binaria/#ponto-fixo","text":"Ponto fixo \u00e9 uma das t\u00e9cnicas de representa\u00e7\u00e3o de n\u00fameros fracionados em bin\u00e1rio, nessa nota\u00e7\u00e3o fixasse quantos bits ser\u00e3o utilizados para a parte inteira e quantos ser\u00e3o utilizados para a fra\u00e7\u00e3o. \u00c9 aplicado o mesmo conceito dos n\u00fameros decimais, as casas a direita do ponto possuem peso na ordem 2^-n . Vamos pegar como exemplo o valor 26.5 , e assumindo que estamos trabalhando com uma palavra de 8 bits onde o ponto est\u00e1 localizado no bit 3 : XXXXX.YYY . Nesse caso, cada casa bin\u00e1ria possui o peso a seguir: 2^5 2^4 2^3 2^2 2^1 2^0 2^-1 2^-2 2^-3 32 16 8 4 2 1 0.5 0.25 0.125 Para construirmos o valor 26.5 basta selecionarmos os bits que somados d\u00e3o esse valor: 011010100 : 0*32 + 1*16 + 1*8 + 0*4 + 1*2 + 0*1 + 1*0.5 + 0*0.025 + 0*0.125 = 26.5 A quest\u00e3o dessa nota\u00e7\u00e3o \u00e9 que uma vez escolhido onde o ponto vai estar localizado (projeto de hardware) n\u00e3o da para mudar depois, se o n\u00famero a ser armazenado \u00e9 apenas fra\u00e7\u00e3o, perdemos muitos bits sem uso com a parte inteira, o que faz possuirmos menor resolu\u00e7\u00e3o. A solu\u00e7\u00e3o para isso \u00e9 a nota\u00e7\u00e3o de ponto flutuante - IEEE 754 voc\u00eas v\u00e3o ver isso na disciplina de Sistemas Hardware Software do 5s).","title":"Ponto fixo"},{"location":"Teoria-Aritmetica-Binaria/#ponto-flutuante","text":"Ponto flutuante \u00e9 uma outra nota\u00e7\u00e3o na qual \u00e9 poss\u00edvel representar n\u00fameros racionais digitalmente (bin\u00e1rio), nessa t\u00e9cnica a v\u00edrgula n\u00e3o \u00e9 fixa, e a nota\u00e7\u00e3o pode se adequar para armazenar n\u00fameros muito trandes ou muito pequenos. No entanto, existe um custo computacional mais elevado envolvido nisso. Processadores modernos possuem um hardware (ULA) dedicada a realizar opera\u00e7\u00f5es em ponto flutuante, normalmente usando o padr\u00e3o IEEE 754 .","title":"Ponto flutuante"},{"location":"Teoria-Assembler/","text":"Assembler \u00b6 EDSAC O EDSAC (Electronic Delay Storage Automatic Calculator) \u00e9 creditado como um dos primeiros computadores a utilizar um Assembler. https://people.cs.clemson.edu/~mark/edsac.html Grace Hopper Foi uma das primeiras pessoas a programar os computadores Mark I, Mark II, Mark III, UNIVAC I e UNIVAC II o que tornou ela uma das grandes pioneiras da computa\u00e7\u00e3o e seus trabalhos influenciaram futuras gera\u00e7\u00f5es. Ela desenvolveu compiladores como o A-O e B-O que levaram ao desenvolvimento do COBOL, que foi usada durante muito tempo em diversos sistemas computacionais e ainda hoje, possui uso em sistemas cr\u00edticos de governos e institui\u00e7\u00f5es financeiras ao redor do mundo. Tamb\u00e9m um fato curioso, \u00e9 que o primeiro bug de computadores se atribui a ela, no caso ela encontrou uma mariposa preso a um relay do Mark II que interrompeu uma execu\u00e7\u00e3o de um programa dela. https://en.wikipedia.org/wiki/Grace_Hopper Linguagens Assembly s\u00e3o as representa\u00e7\u00f5es simb\u00f3licas dos comandos bin\u00e1rios do computador (linguagem de m\u00e1quina), facilitando o desenvolvimento de programas. Essa \u00e9 uma linguagem que chamamos de baixo n\u00edvel, ou seja, ela n\u00e3o \u00e9 t\u00e3o sofisticada como uma linguagem Java onde os comandos abstraem o hardware, e n\u00e3o possuem uma rela\u00e7\u00e3o direta com o hardware. Em geral instru\u00e7\u00f5es Assembly s\u00e3o convertidas diretamente para uma instru\u00e7\u00e3o de linguagem de m\u00e1quina. Podemos dizer que \u00e9 um mapeamento um para um, assim cada instru\u00e7\u00e3o Assembly vira uma instru\u00e7\u00e3o de m\u00e1quina. O que um assembler faz? \u00b6 Assembler Em portugu\u00eas \u00e9 conhecido como montador . As CPUs tem suas linguagens m\u00e1quinas, que s\u00e3o descritas pelas sequ\u00eancias de bits, ou seja, seus 0 s e 1 s. O assembly \u00e9 um formalismo que permite a cria\u00e7\u00e3o dos programas em uma linguagem mais humanamente trat\u00e1vel, por\u00e9m os computadores n\u00e3o conseguem executar diretamente esse tipo de instru\u00e7\u00e3o, uma s\u00e9rie de tratamentos e convers\u00f5es s\u00e3o necess\u00e1rias e o que o Assembler faz \u00e9 justamente traduzir essa linguagem de mnem\u00f4nicos para os c\u00f3digos bin\u00e1rios da arquitetura em quest\u00e3o, ou seja, os 0 s e 1 s que o computador consegue diretamente executar. Tip Os Assemblers presentes nos sistemas operacionais dispon\u00edveis s\u00e3o normalmente o NASM para a sintaxe intel e o GAS para a sintaxe AT&T, mas podem haver varia\u00e7\u00f5es. http://www.ibm.com/developerworks/library/l-gas-nasm/ Etapas de montagem \u00b6 O montador proposto nesse curso tem as seguintes etapas: Abrir arquivo An\u00e1lise sint\u00e1tica Parsing (Tabela de S\u00edmbolos) Gera\u00e7\u00e3o de c\u00f3digo (code) An\u00e1lise Sint\u00e1tica \u00b6 O assemble faz a an\u00e1lise sint\u00e1tica (parsing) dos arquivos, identificando cada sequencia de caracteres, e posteriormente gerando os c\u00f3digos bin\u00e1rios para uma determinada arquitetura. Fazer o Parsing significa detectar cada s\u00edmbolo para determinar a estrutura sint\u00e1tica de uma express\u00e3o, que \u00e9 escrita de acordo com as regras de uma determinada gram\u00e1tica. Para analisar essa express\u00e3o, voc\u00ea tem que dividi-la no que chamamos de tokens: S\u00edmbolos \u00b6 Uma das dificuldades em se programar em Assembly est\u00e1 relacionada ao gerenciamento de mem\u00f3ria, ou seja, como saber em que endere\u00e7o de mem\u00f3ria devemos armazenar um valor ou para qual endere\u00e7o realizar um salto, ou seja, um JUMP, ou Branching. Para isso podemos usar refer\u00eancias simb\u00f3licas nos programas para endere\u00e7ar mem\u00f3rias f\u00edsicas no computador. Usamos uma vari\u00e1vel como em linguagens de alto n\u00edvel e esses s\u00edmbolos s\u00e3o posteriormente convertidos em n\u00fameros pelo Assembler. leaw $ END , % A Para as vari\u00e1veis de valores podemos escolher endere\u00e7os seguindo alguma regra, que posteriormente podem ser recuperados e armazenados em uma tabela que relaciona o nome ao valor. leaw $ var1 , % A movw % D , ( % A ) J\u00e1 para os saltos, como a tradu\u00e7\u00e3o do Assembly \u00e9 direta, ou seja, as instru\u00e7\u00f5es em Assembly se mapeiam em instru\u00e7\u00f5es em linguagem de m\u00e1quina como uma fun\u00e7\u00e3o bijetora, A tabela de s\u00edmbolos pode ser usada para localizar onde est\u00e3o marcados os marcadores que vamos chamar aqui de Labels e tamb\u00e9m armazenar na mem\u00f3ria. Finalmente vale ressaltar que a tabela de s\u00edmbolos muitas vezes vem com uma s\u00e9rie de s\u00edmbolos pr\u00e9 definidos, que podem acessar posi\u00e7\u00f5es de mem\u00f3ria padronizadas para algo espec\u00edfico da arquitetura. leaw $ R0 , % A leaw $ LED , % A O programa assembler varre o c\u00f3digo em busca desses s\u00edmbolos e cria uma tabela relacionando o seu nome a um valor que pode ser convertido em bin\u00e1rio: Sempre que o assembler encontrar um s\u00edmbolo, ele consulta essa tabela em busca do valor associado a ele. Gera\u00e7\u00e3o de c\u00f3digo \u00b6 O assembler necessita ler os opcodes e transformar em linguagem de m\u00e1quina. \u00c9 essa etapa que ir\u00e1 realmente criar uma sa\u00edda bin\u00e1ria. A gera\u00e7\u00e3o de c\u00f3digo deve identificar o tipo do comando que est\u00e1 sendo executado, os seus par\u00e2metros e s\u00edmbolos e ent\u00e3o gerar a sa\u00edda bin\u00e1ria com base no instruction set de refer\u00eancia. Ferramental do curso \u00b6 Desenvolvemos no projeto E-Assembly uma s\u00e9rie de programas escritos em nasm, mas voc\u00ea j\u00e1 parou para pensar como esses programas s\u00e3o montados? Quando voc\u00eas executam o script ./testeAssembly.py algumas coisas acontecem: O script abre o arquivo de configura\u00e7\u00f5es de teste: config.txt e busca quais m\u00f3dulos nasm deve compilar Para cada arquivo .nasm encontrado \u00e9 chamado um programa em java que \u00e9 o assembler, exemplo: $ java -jar ~/Z01-Tools/jar/Z01-Assembler.jar -i ./src/add.nasm -o /bin/add.hack Tip Experimente voc\u00ea rodar esse comando e ver o que ele gera de output. O programa em Java est\u00e1 dentro da pasta Z01-Tools/jar na raiz do usu\u00e1rio de voc\u00eas no linux. Esse programa em Java implementa o Assembler, e gera para cada nasm passado um execut\u00e1vel. O script de teste n\u00e3o para por a\u00ed, ele precisa agora pegar esse execut\u00e1vel, junto com os testes e jogar no Hardware, executar e pegar o resultado.","title":"Assembler"},{"location":"Teoria-Assembler/#assembler","text":"EDSAC O EDSAC (Electronic Delay Storage Automatic Calculator) \u00e9 creditado como um dos primeiros computadores a utilizar um Assembler. https://people.cs.clemson.edu/~mark/edsac.html Grace Hopper Foi uma das primeiras pessoas a programar os computadores Mark I, Mark II, Mark III, UNIVAC I e UNIVAC II o que tornou ela uma das grandes pioneiras da computa\u00e7\u00e3o e seus trabalhos influenciaram futuras gera\u00e7\u00f5es. Ela desenvolveu compiladores como o A-O e B-O que levaram ao desenvolvimento do COBOL, que foi usada durante muito tempo em diversos sistemas computacionais e ainda hoje, possui uso em sistemas cr\u00edticos de governos e institui\u00e7\u00f5es financeiras ao redor do mundo. Tamb\u00e9m um fato curioso, \u00e9 que o primeiro bug de computadores se atribui a ela, no caso ela encontrou uma mariposa preso a um relay do Mark II que interrompeu uma execu\u00e7\u00e3o de um programa dela. https://en.wikipedia.org/wiki/Grace_Hopper Linguagens Assembly s\u00e3o as representa\u00e7\u00f5es simb\u00f3licas dos comandos bin\u00e1rios do computador (linguagem de m\u00e1quina), facilitando o desenvolvimento de programas. Essa \u00e9 uma linguagem que chamamos de baixo n\u00edvel, ou seja, ela n\u00e3o \u00e9 t\u00e3o sofisticada como uma linguagem Java onde os comandos abstraem o hardware, e n\u00e3o possuem uma rela\u00e7\u00e3o direta com o hardware. Em geral instru\u00e7\u00f5es Assembly s\u00e3o convertidas diretamente para uma instru\u00e7\u00e3o de linguagem de m\u00e1quina. Podemos dizer que \u00e9 um mapeamento um para um, assim cada instru\u00e7\u00e3o Assembly vira uma instru\u00e7\u00e3o de m\u00e1quina.","title":"Assembler"},{"location":"Teoria-Assembler/#o-que-um-assembler-faz","text":"Assembler Em portugu\u00eas \u00e9 conhecido como montador . As CPUs tem suas linguagens m\u00e1quinas, que s\u00e3o descritas pelas sequ\u00eancias de bits, ou seja, seus 0 s e 1 s. O assembly \u00e9 um formalismo que permite a cria\u00e7\u00e3o dos programas em uma linguagem mais humanamente trat\u00e1vel, por\u00e9m os computadores n\u00e3o conseguem executar diretamente esse tipo de instru\u00e7\u00e3o, uma s\u00e9rie de tratamentos e convers\u00f5es s\u00e3o necess\u00e1rias e o que o Assembler faz \u00e9 justamente traduzir essa linguagem de mnem\u00f4nicos para os c\u00f3digos bin\u00e1rios da arquitetura em quest\u00e3o, ou seja, os 0 s e 1 s que o computador consegue diretamente executar. Tip Os Assemblers presentes nos sistemas operacionais dispon\u00edveis s\u00e3o normalmente o NASM para a sintaxe intel e o GAS para a sintaxe AT&T, mas podem haver varia\u00e7\u00f5es. http://www.ibm.com/developerworks/library/l-gas-nasm/","title":"O que um assembler faz?"},{"location":"Teoria-Assembler/#etapas-de-montagem","text":"O montador proposto nesse curso tem as seguintes etapas: Abrir arquivo An\u00e1lise sint\u00e1tica Parsing (Tabela de S\u00edmbolos) Gera\u00e7\u00e3o de c\u00f3digo (code)","title":"Etapas de montagem"},{"location":"Teoria-Assembler/#analise-sintatica","text":"O assemble faz a an\u00e1lise sint\u00e1tica (parsing) dos arquivos, identificando cada sequencia de caracteres, e posteriormente gerando os c\u00f3digos bin\u00e1rios para uma determinada arquitetura. Fazer o Parsing significa detectar cada s\u00edmbolo para determinar a estrutura sint\u00e1tica de uma express\u00e3o, que \u00e9 escrita de acordo com as regras de uma determinada gram\u00e1tica. Para analisar essa express\u00e3o, voc\u00ea tem que dividi-la no que chamamos de tokens:","title":"An\u00e1lise Sint\u00e1tica"},{"location":"Teoria-Assembler/#simbolos","text":"Uma das dificuldades em se programar em Assembly est\u00e1 relacionada ao gerenciamento de mem\u00f3ria, ou seja, como saber em que endere\u00e7o de mem\u00f3ria devemos armazenar um valor ou para qual endere\u00e7o realizar um salto, ou seja, um JUMP, ou Branching. Para isso podemos usar refer\u00eancias simb\u00f3licas nos programas para endere\u00e7ar mem\u00f3rias f\u00edsicas no computador. Usamos uma vari\u00e1vel como em linguagens de alto n\u00edvel e esses s\u00edmbolos s\u00e3o posteriormente convertidos em n\u00fameros pelo Assembler. leaw $ END , % A Para as vari\u00e1veis de valores podemos escolher endere\u00e7os seguindo alguma regra, que posteriormente podem ser recuperados e armazenados em uma tabela que relaciona o nome ao valor. leaw $ var1 , % A movw % D , ( % A ) J\u00e1 para os saltos, como a tradu\u00e7\u00e3o do Assembly \u00e9 direta, ou seja, as instru\u00e7\u00f5es em Assembly se mapeiam em instru\u00e7\u00f5es em linguagem de m\u00e1quina como uma fun\u00e7\u00e3o bijetora, A tabela de s\u00edmbolos pode ser usada para localizar onde est\u00e3o marcados os marcadores que vamos chamar aqui de Labels e tamb\u00e9m armazenar na mem\u00f3ria. Finalmente vale ressaltar que a tabela de s\u00edmbolos muitas vezes vem com uma s\u00e9rie de s\u00edmbolos pr\u00e9 definidos, que podem acessar posi\u00e7\u00f5es de mem\u00f3ria padronizadas para algo espec\u00edfico da arquitetura. leaw $ R0 , % A leaw $ LED , % A O programa assembler varre o c\u00f3digo em busca desses s\u00edmbolos e cria uma tabela relacionando o seu nome a um valor que pode ser convertido em bin\u00e1rio: Sempre que o assembler encontrar um s\u00edmbolo, ele consulta essa tabela em busca do valor associado a ele.","title":"S\u00edmbolos"},{"location":"Teoria-Assembler/#geracao-de-codigo","text":"O assembler necessita ler os opcodes e transformar em linguagem de m\u00e1quina. \u00c9 essa etapa que ir\u00e1 realmente criar uma sa\u00edda bin\u00e1ria. A gera\u00e7\u00e3o de c\u00f3digo deve identificar o tipo do comando que est\u00e1 sendo executado, os seus par\u00e2metros e s\u00edmbolos e ent\u00e3o gerar a sa\u00edda bin\u00e1ria com base no instruction set de refer\u00eancia.","title":"Gera\u00e7\u00e3o de c\u00f3digo"},{"location":"Teoria-Assembler/#ferramental-do-curso","text":"Desenvolvemos no projeto E-Assembly uma s\u00e9rie de programas escritos em nasm, mas voc\u00ea j\u00e1 parou para pensar como esses programas s\u00e3o montados? Quando voc\u00eas executam o script ./testeAssembly.py algumas coisas acontecem: O script abre o arquivo de configura\u00e7\u00f5es de teste: config.txt e busca quais m\u00f3dulos nasm deve compilar Para cada arquivo .nasm encontrado \u00e9 chamado um programa em java que \u00e9 o assembler, exemplo: $ java -jar ~/Z01-Tools/jar/Z01-Assembler.jar -i ./src/add.nasm -o /bin/add.hack Tip Experimente voc\u00ea rodar esse comando e ver o que ele gera de output. O programa em Java est\u00e1 dentro da pasta Z01-Tools/jar na raiz do usu\u00e1rio de voc\u00eas no linux. Esse programa em Java implementa o Assembler, e gera para cada nasm passado um execut\u00e1vel. O script de teste n\u00e3o para por a\u00ed, ele precisa agora pegar esse execut\u00e1vel, junto com os testes e jogar no Hardware, executar e pegar o resultado.","title":"Ferramental do curso"},{"location":"Teoria-Assembly/","text":"ASM - Assembly \u00b6 2020-2 Material atualizado. Assembly \u00e9 a linguagem de programa\u00e7\u00e3o mais pr\u00f3xima do hardware, nela cada linha de c\u00f3digo \u00e9 traduzida diretamente para um linha do execut\u00e1vel (c\u00f3digo bin\u00e1rio). Para mais informa\u00e7\u00f5es sobre o assembly utilizado no curso acesse a p\u00e1gina: Z01 Resumo Assembly . Exemplo: INICIO: leaw $ 0 , % A movw % A , % D ; Carrega 0 em S ADD: ; Label para saltar incw % D ; Incrementa S leaw $ ADD , % A ; Carrega endere\u00e7o do label ADD ; (3 no caso) jmp ; Salto incondicional nop ; No-Operation ; (necess\u00e1rio ap\u00f3s jump)","title":"ASM - Assembly"},{"location":"Teoria-Assembly/#asm-assembly","text":"2020-2 Material atualizado. Assembly \u00e9 a linguagem de programa\u00e7\u00e3o mais pr\u00f3xima do hardware, nela cada linha de c\u00f3digo \u00e9 traduzida diretamente para um linha do execut\u00e1vel (c\u00f3digo bin\u00e1rio). Para mais informa\u00e7\u00f5es sobre o assembly utilizado no curso acesse a p\u00e1gina: Z01 Resumo Assembly . Exemplo: INICIO: leaw $ 0 , % A movw % A , % D ; Carrega 0 em S ADD: ; Label para saltar incw % D ; Incrementa S leaw $ ADD , % A ; Carrega endere\u00e7o do label ADD ; (3 no caso) jmp ; Salto incondicional nop ; No-Operation ; (necess\u00e1rio ap\u00f3s jump)","title":"ASM - Assembly"},{"location":"Teoria-CMOS/","text":"L\u00f3gica CMOS (Complementary Metal\u2013Oxide\u2013Semiconductor) \u00b6 Conte\u00fado: CMOS Estudando Bibliografia [Cap7. FLOYD, 2005] [Cap8. TOCCI, 2011] Tip Mais informa\u00e7\u00f5es em: https://en.wikipedia.org/wiki/CMOS Transistores MOS \u00b6 Os transistores MOSFET (Metal-Oxide-Semiconductor Field-Effect-Transistor) s\u00e3o os mais utilizados nos circuitos integrados anal\u00f3gicos e digitais, sendo que seu princ\u00edpio b\u00e1sico foi proposto por Julius Edgar Lilienfeld em 1926. Mas, foi s\u00f3 em 1960 que esse transistor foi produzido. Seu princ\u00edpio de funcionamento de baseia na presen\u00e7a de um capacitor MOS (Metal-Oxide-Semiconductor) que controla a quantidade de cargas na regi\u00e3o semicondutora, chamada de canal. Os transistores MOS podem ser classificados de acordo com o portador de cargas: transistor nMOS onde a corrente \u00e9 conduzida por el\u00e9trons e transistor pMOS onde a corrente \u00e9 conduzida por lacunas. Para que esses dispositivos operem como chave, \u00e9 necess\u00e1ria a aplica\u00e7\u00e3o de uma tens\u00e3o de forma a atrair os portadores de corrente. Assim, no nMOS uma tens\u00e3o positiva entre porta e fonte atrai el\u00e9trons para o canal, enquanto que no pMOS uma tens\u00e3o negativa entre porta e fonte deve ser aplicada para atrair cargas positivas para a regi\u00e3o do canal. Tecnologia CMOS \u00b6 A tecnologia CMOS (Complementary MOS) \u00e9 um tipo de processo de fabrica\u00e7\u00e3o criado na d\u00e9cada de 60, que utiliza pares sim\u00e9tricos e complementares de nMOS e pMOS para realizar fun\u00e7\u00f5es l\u00f3gicas. Para a an\u00e1lise dos circuitos l\u00f3gicos CMOS, pode-se considerar que quando a tens\u00e3o na porta de um nMOS foi positiva, ele se comporta como uma chave fechada e, quando a tens\u00e3o for nula, se comporta como uma chave aberta. Para o pMOS, o comportamento \u00e9 oposto: se comporta como chave fechada para a tens\u00e3o nula e aberta para a tens\u00e3o positiva. L\u00f3gica NOT \u00b6 Quando ambos os transistores est\u00e3o ligados em s\u00e9rie como apresentado na figura, ao se aplicar uma tens\u00e3o de entrada positiva, o nMOS (transistor inferior) se comporta como chave fechada enquanto o pMOS (transistor superior) se comporta como chave aberta. Assim, a tens\u00e3o na sa\u00edda ser\u00e1 nula. Ao se aplicar uma tens\u00e3o de entrada nula, o nMOS passa a se comportar como chave aberta enquanto o pMOS se comporta como chave fechada. Assim, a tens\u00e3o na sa\u00edda ser\u00e1 positiva. Pode-se observar que o circuito opera como um inversor. L\u00f3gica NAND \u00b6 Para formar a porta l\u00f3gica NAND, dois transistores nMOS s\u00e3o ligados em s\u00e9rie enquanto que dois pMOS s\u00e3o ligados em paralelo. A an\u00e1lise pode ser feita de mesma forma que para o circuito inversor. L\u00f3gica NOR \u00b6 Para formar a porta l\u00f3gica NOR, dois transistores pMOS s\u00e3o ligados em s\u00e9rie enquanto que dois nMOS s\u00e3o ligados em paralelo. A an\u00e1lise pode ser feita de mesma forma que para o circuito inversor. As demais porta l\u00f3gicas podem ser criadas a partir dessas fundamentais.","title":"L\u00f3gica CMOS (Complementary Metal\u2013Oxide\u2013Semiconductor)"},{"location":"Teoria-CMOS/#logica-cmos-complementary-metaloxidesemiconductor","text":"Conte\u00fado: CMOS Estudando Bibliografia [Cap7. FLOYD, 2005] [Cap8. TOCCI, 2011] Tip Mais informa\u00e7\u00f5es em: https://en.wikipedia.org/wiki/CMOS","title":"L\u00f3gica CMOS (Complementary Metal\u2013Oxide\u2013Semiconductor)"},{"location":"Teoria-CMOS/#transistores-mos","text":"Os transistores MOSFET (Metal-Oxide-Semiconductor Field-Effect-Transistor) s\u00e3o os mais utilizados nos circuitos integrados anal\u00f3gicos e digitais, sendo que seu princ\u00edpio b\u00e1sico foi proposto por Julius Edgar Lilienfeld em 1926. Mas, foi s\u00f3 em 1960 que esse transistor foi produzido. Seu princ\u00edpio de funcionamento de baseia na presen\u00e7a de um capacitor MOS (Metal-Oxide-Semiconductor) que controla a quantidade de cargas na regi\u00e3o semicondutora, chamada de canal. Os transistores MOS podem ser classificados de acordo com o portador de cargas: transistor nMOS onde a corrente \u00e9 conduzida por el\u00e9trons e transistor pMOS onde a corrente \u00e9 conduzida por lacunas. Para que esses dispositivos operem como chave, \u00e9 necess\u00e1ria a aplica\u00e7\u00e3o de uma tens\u00e3o de forma a atrair os portadores de corrente. Assim, no nMOS uma tens\u00e3o positiva entre porta e fonte atrai el\u00e9trons para o canal, enquanto que no pMOS uma tens\u00e3o negativa entre porta e fonte deve ser aplicada para atrair cargas positivas para a regi\u00e3o do canal.","title":"Transistores MOS"},{"location":"Teoria-CMOS/#tecnologia-cmos","text":"A tecnologia CMOS (Complementary MOS) \u00e9 um tipo de processo de fabrica\u00e7\u00e3o criado na d\u00e9cada de 60, que utiliza pares sim\u00e9tricos e complementares de nMOS e pMOS para realizar fun\u00e7\u00f5es l\u00f3gicas. Para a an\u00e1lise dos circuitos l\u00f3gicos CMOS, pode-se considerar que quando a tens\u00e3o na porta de um nMOS foi positiva, ele se comporta como uma chave fechada e, quando a tens\u00e3o for nula, se comporta como uma chave aberta. Para o pMOS, o comportamento \u00e9 oposto: se comporta como chave fechada para a tens\u00e3o nula e aberta para a tens\u00e3o positiva.","title":"Tecnologia CMOS"},{"location":"Teoria-CMOS/#logica-not","text":"Quando ambos os transistores est\u00e3o ligados em s\u00e9rie como apresentado na figura, ao se aplicar uma tens\u00e3o de entrada positiva, o nMOS (transistor inferior) se comporta como chave fechada enquanto o pMOS (transistor superior) se comporta como chave aberta. Assim, a tens\u00e3o na sa\u00edda ser\u00e1 nula. Ao se aplicar uma tens\u00e3o de entrada nula, o nMOS passa a se comportar como chave aberta enquanto o pMOS se comporta como chave fechada. Assim, a tens\u00e3o na sa\u00edda ser\u00e1 positiva. Pode-se observar que o circuito opera como um inversor.","title":"L\u00f3gica NOT"},{"location":"Teoria-CMOS/#logica-nand","text":"Para formar a porta l\u00f3gica NAND, dois transistores nMOS s\u00e3o ligados em s\u00e9rie enquanto que dois pMOS s\u00e3o ligados em paralelo. A an\u00e1lise pode ser feita de mesma forma que para o circuito inversor.","title":"L\u00f3gica NAND"},{"location":"Teoria-CMOS/#logica-nor","text":"Para formar a porta l\u00f3gica NOR, dois transistores pMOS s\u00e3o ligados em s\u00e9rie enquanto que dois nMOS s\u00e3o ligados em paralelo. A an\u00e1lise pode ser feita de mesma forma que para o circuito inversor. As demais porta l\u00f3gicas podem ser criadas a partir dessas fundamentais.","title":"L\u00f3gica NOR"},{"location":"Teoria-Componentes/","text":"Componentes Digitais \u00b6 2022-1 Material atualizado. Aqui iremos alguns dos in\u00fameros componentes combinacionais (n\u00e3o precisam de clock) que s\u00e3o utilizados no desenvolvimento de circuitos digitais e que ser\u00e3o usados na disciplina. portas l\u00f3gicas \u00b6 S <= A and B; S <= A nand B; S <= not (A and B) S <= A or B; S <= A nor B; S <= not (A or B); S <= A xor B; S <= (not A); and nand or nor xor not Multiplexado (mux) \u00b6 fonte wikipedia : Schematic of a 2-to-1 Multiplexer. It can be equated to a controlled switch. entity mux is port ( in0 : in std_logic ; in1 : in std_logic ; sel : in std_logic ; o : out std_logic ); end entity ; O mux como \u00e9 chamado o Multiplexador \u00e9 um componente que possui n entradas e uma sa\u00edda q , um sinal chamado de seletor sel seleciona qual entrada ir\u00e1 ser copiada para a sa\u00edda. As entradas n e a sa\u00edda q podem ser bin\u00e1rias ou vetor de tamanho m . A seguir uma tabela verdade para um mux de 2 entradas: in 0 in 1 Sel out 1 X 0 1 X 0 1 0 0 X 0 0 X 1 1 1 Note A tabela verdade do mux de 2 entradas possuir 2^3 linhas (o seletor conta como entrada), totalizando 8 linhas. Por\u00e9m para simplificar, utilizamos o X que significa tanto faz ( 0 ou 1 ), logo cada linha que possui X seria expandida para duas linhas. Tip O tamanho do seletor deve ser um numero inteiro: \\(log2(size(n))\\) . Quantidade de entras Tamanho do seletor 2 1 3 2 4 2 5 3 8 3 Demutiplexador (demux) \u00b6 \u00c9 similar com o mux s\u00f3 que possui uma entrada in e n sa\u00eddas q , o demux conecta a entrada a alguma das sa\u00eddas, sendo controlado pelo seletor. fonte wikipedia : Schematic of a 1-to-2 Demultiplexer. Like a multiplexer, it can be equated to a controlled switch. entity demux is port ( in0 : in std_logic ; sel : in std_logic ; out0 : out std_logic ; out1 : out std_logic ); end entity ; A entrada in e a sa\u00edda q podem ser bin\u00e1rias ou de vetorer de tamanho m . A seguir uma tabela verdade para um demux de 2 sa\u00eddas: in Sel out 0 out 1 1 0 1 0 1 1 0 1 0 1 0 0 0 0 0 0 Enconders \u00b6 Enconders s\u00e3o componentes que codificam uma entrada em uma sa\u00edda de outro formato, algum exemplos s\u00e3o: BCD Gray code SevenSeg Priority Encoder BCD \u00b6 Binary-coded decimal (BCD) \u00e9 uma forma de codifica\u00e7\u00e3o de n\u00fameros inteiros em bin\u00e1rio na qual utiliza-se para cada d\u00edgito de um n\u00famero inteiro, 4 bits em bin\u00e1rio. Decimal Number BCD 8421 Code 0 0000 0000 01 0000 0001 02 0000 0010 03 0000 0011 04 0000 0100 05 0000 0101 06 0000 0110 07 0000 0111 08 0000 1000 09 0000 1001 10 (1+0) 0001 0000 11 (1+1) 0001 0001 12 (1+2) 0001 0010 continua em blocos de 4 |-----------| | | out1[3..0] x[n..0] | Binary |-----/--------> ----/------>| to | .... | BCD | outm[3..0] | |-----/--------> |-----------| entity binaryToBCD is port ( x : in std_logic ( 4 downto 0 ); out0 : out std_logic_vector ( 3 downto 0 ); -- Unidade out1 : out std_logic_vector ( 3 downto 0 ) -- Dezena ); end entity ; Tip O maior valor que um bloco de 4 bits do BCD assume \u00e9 o 1001 que \u00e9 referente ao n\u00famero inteiro 9. O BCD \u00e9 bastante utilizado para o controle de displays de 7 segmentos, como demonstrado na figura a seguir que usa o chip fonte electronics-tutorials C\u00f3digo Gray \u00b6 O c\u00f3digo gray \u00e9 uma forma de codificar n\u00fameros bin\u00e1rios, nessa codifica\u00e7\u00e3o apenas um bit muda por vez. C\u00f3digo decimal C\u00f3digo Bin\u00e1rio C\u00f3digo Gray 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 8 1000 1100 9 1001 1101 10 1010 1111 11 1011 1110 12 1100 1010 13 1101 1011 14 1110 1001 15 1111 1000 Note Esse sistema era muito utilizado antigamente quando rel\u00e9s eram utilizados no lugar de transistor, em um contador bin\u00e1rio comum ocorre de muitos bits mudarem de uma \u00fanica vez (0111 -> 1000) isso gerava um pico de corrente el\u00e9trica e muito ru\u00eddo. Tip Utilizamos o c\u00f3digo Gray para montar o Mapa de Karnaugh Comparador \u00b6 Comparadores s\u00e3o componentes que podem possuir diversos atributos, tais como comparar: se duas entradas s\u00e3o iguais se a entrada A \u00e9 maior que entrada B se entrada A \u00e9 igual a zero ... A seguir um exemplo de um comparador que possui apenas uma entrada x[1..0] e compara se essa entrada \u00e9 igual a zero ( x == 0 ), ou maior que zero ( x > 0 ). x (inteiro) x bin\u00e1rio eq gt 0 00 1 0 1 01 0 1 -1 11 0 0 -2 10 0 0 |-----------| | | eq x[1..0] | |----------> ----/------>| comparador| | | gt | |----------> |-----------| entity COMPARADOR is port ( x : in std_logic_vector ( 1 downto 0 ); eq : out std_logic ; gt : out std_logic ); end entity ; Somadores \u00b6 Os somadores s\u00e3o componentes que realizam a soma de dois n\u00fameros bin\u00e1rios, eles podem ser constru\u00eddos de diversas maneiras. in0[1..0] |-----------| ----/------>| | | | out[2..0] | ADDER |-----/-----> in1[1..0] | | ----/------>| | |-----------| entity ADDER is port ( in0 : in std_logic ( 1 downto 0 ); in1 : in std_logic ( 1 downto 0 ); o : out std_logic_vector ( 2 downto 0 ) ); end entity ; Um somador de dois vetores de dois bits cada possui o seguinte comportamento: in0 in1 out 00 00 000 00 01 001 01 01 010 10 01 011 10 11 101 11 11 110","title":"Componentes Digitais"},{"location":"Teoria-Componentes/#componentes-digitais","text":"2022-1 Material atualizado. Aqui iremos alguns dos in\u00fameros componentes combinacionais (n\u00e3o precisam de clock) que s\u00e3o utilizados no desenvolvimento de circuitos digitais e que ser\u00e3o usados na disciplina.","title":"Componentes Digitais"},{"location":"Teoria-Componentes/#portas-logicas","text":"S <= A and B; S <= A nand B; S <= not (A and B) S <= A or B; S <= A nor B; S <= not (A or B); S <= A xor B; S <= (not A); and nand or nor xor not","title":"portas l\u00f3gicas"},{"location":"Teoria-Componentes/#multiplexado-mux","text":"fonte wikipedia : Schematic of a 2-to-1 Multiplexer. It can be equated to a controlled switch. entity mux is port ( in0 : in std_logic ; in1 : in std_logic ; sel : in std_logic ; o : out std_logic ); end entity ; O mux como \u00e9 chamado o Multiplexador \u00e9 um componente que possui n entradas e uma sa\u00edda q , um sinal chamado de seletor sel seleciona qual entrada ir\u00e1 ser copiada para a sa\u00edda. As entradas n e a sa\u00edda q podem ser bin\u00e1rias ou vetor de tamanho m . A seguir uma tabela verdade para um mux de 2 entradas: in 0 in 1 Sel out 1 X 0 1 X 0 1 0 0 X 0 0 X 1 1 1 Note A tabela verdade do mux de 2 entradas possuir 2^3 linhas (o seletor conta como entrada), totalizando 8 linhas. Por\u00e9m para simplificar, utilizamos o X que significa tanto faz ( 0 ou 1 ), logo cada linha que possui X seria expandida para duas linhas. Tip O tamanho do seletor deve ser um numero inteiro: \\(log2(size(n))\\) . Quantidade de entras Tamanho do seletor 2 1 3 2 4 2 5 3 8 3","title":"Multiplexado (mux)"},{"location":"Teoria-Componentes/#demutiplexador-demux","text":"\u00c9 similar com o mux s\u00f3 que possui uma entrada in e n sa\u00eddas q , o demux conecta a entrada a alguma das sa\u00eddas, sendo controlado pelo seletor. fonte wikipedia : Schematic of a 1-to-2 Demultiplexer. Like a multiplexer, it can be equated to a controlled switch. entity demux is port ( in0 : in std_logic ; sel : in std_logic ; out0 : out std_logic ; out1 : out std_logic ); end entity ; A entrada in e a sa\u00edda q podem ser bin\u00e1rias ou de vetorer de tamanho m . A seguir uma tabela verdade para um demux de 2 sa\u00eddas: in Sel out 0 out 1 1 0 1 0 1 1 0 1 0 1 0 0 0 0 0 0","title":"Demutiplexador  (demux)"},{"location":"Teoria-Componentes/#enconders","text":"Enconders s\u00e3o componentes que codificam uma entrada em uma sa\u00edda de outro formato, algum exemplos s\u00e3o: BCD Gray code SevenSeg Priority Encoder","title":"Enconders"},{"location":"Teoria-Componentes/#bcd","text":"Binary-coded decimal (BCD) \u00e9 uma forma de codifica\u00e7\u00e3o de n\u00fameros inteiros em bin\u00e1rio na qual utiliza-se para cada d\u00edgito de um n\u00famero inteiro, 4 bits em bin\u00e1rio. Decimal Number BCD 8421 Code 0 0000 0000 01 0000 0001 02 0000 0010 03 0000 0011 04 0000 0100 05 0000 0101 06 0000 0110 07 0000 0111 08 0000 1000 09 0000 1001 10 (1+0) 0001 0000 11 (1+1) 0001 0001 12 (1+2) 0001 0010 continua em blocos de 4 |-----------| | | out1[3..0] x[n..0] | Binary |-----/--------> ----/------>| to | .... | BCD | outm[3..0] | |-----/--------> |-----------| entity binaryToBCD is port ( x : in std_logic ( 4 downto 0 ); out0 : out std_logic_vector ( 3 downto 0 ); -- Unidade out1 : out std_logic_vector ( 3 downto 0 ) -- Dezena ); end entity ; Tip O maior valor que um bloco de 4 bits do BCD assume \u00e9 o 1001 que \u00e9 referente ao n\u00famero inteiro 9. O BCD \u00e9 bastante utilizado para o controle de displays de 7 segmentos, como demonstrado na figura a seguir que usa o chip fonte electronics-tutorials","title":"BCD"},{"location":"Teoria-Componentes/#codigo-gray","text":"O c\u00f3digo gray \u00e9 uma forma de codificar n\u00fameros bin\u00e1rios, nessa codifica\u00e7\u00e3o apenas um bit muda por vez. C\u00f3digo decimal C\u00f3digo Bin\u00e1rio C\u00f3digo Gray 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 8 1000 1100 9 1001 1101 10 1010 1111 11 1011 1110 12 1100 1010 13 1101 1011 14 1110 1001 15 1111 1000 Note Esse sistema era muito utilizado antigamente quando rel\u00e9s eram utilizados no lugar de transistor, em um contador bin\u00e1rio comum ocorre de muitos bits mudarem de uma \u00fanica vez (0111 -> 1000) isso gerava um pico de corrente el\u00e9trica e muito ru\u00eddo. Tip Utilizamos o c\u00f3digo Gray para montar o Mapa de Karnaugh","title":"C\u00f3digo Gray"},{"location":"Teoria-Componentes/#comparador","text":"Comparadores s\u00e3o componentes que podem possuir diversos atributos, tais como comparar: se duas entradas s\u00e3o iguais se a entrada A \u00e9 maior que entrada B se entrada A \u00e9 igual a zero ... A seguir um exemplo de um comparador que possui apenas uma entrada x[1..0] e compara se essa entrada \u00e9 igual a zero ( x == 0 ), ou maior que zero ( x > 0 ). x (inteiro) x bin\u00e1rio eq gt 0 00 1 0 1 01 0 1 -1 11 0 0 -2 10 0 0 |-----------| | | eq x[1..0] | |----------> ----/------>| comparador| | | gt | |----------> |-----------| entity COMPARADOR is port ( x : in std_logic_vector ( 1 downto 0 ); eq : out std_logic ; gt : out std_logic ); end entity ;","title":"Comparador"},{"location":"Teoria-Componentes/#somadores","text":"Os somadores s\u00e3o componentes que realizam a soma de dois n\u00fameros bin\u00e1rios, eles podem ser constru\u00eddos de diversas maneiras. in0[1..0] |-----------| ----/------>| | | | out[2..0] | ADDER |-----/-----> in1[1..0] | | ----/------>| | |-----------| entity ADDER is port ( in0 : in std_logic ( 1 downto 0 ); in1 : in std_logic ( 1 downto 0 ); o : out std_logic_vector ( 2 downto 0 ) ); end entity ; Um somador de dois vetores de dois bits cada possui o seguinte comportamento: in0 in1 out 00 00 000 00 01 001 01 01 010 10 01 011 10 11 101 11 11 110","title":"Somadores"},{"location":"Teoria-Dados/","text":"Dados Digitais \u00b6 Estudando Bibliografia [Cap 3,5. NISAN, 2005] [Cap 8,11,12. FLOYD, 2011] [Cap 7 TOCCI] Leitura extra: Introduction to Digital Systems - Cap. 1 Introduction to Digital Systems - Cap. 2 V\u00eddeos (extra) KhanAcademy Why Do Computers Use 1s and 0s? Binary and Transistors Explained. Primeiras M\u00e1quinas de Calcular Wilhelm Schickard (1592\u20131635) construiu em 1623 uma calculadora para seu amigo astr\u00f4nomo Johannes Kepler. Esta \u00e9 a mais antiga calculadora mec\u00e2nica conhecida de quatro fun\u00e7\u00f5es, que foi descoberta por esbo\u00e7os da sua cria\u00e7\u00e3o. Fonte: http://people.idsia.ch/~juergen/schickard.html Hist\u00f3ria Blaise Pascal (1623-1662) inventou e produziu em 1642 a Pascaline. Ela s\u00f3 podia fazer adi\u00e7\u00e3o e subtra\u00e7\u00e3o, manipulando os n\u00fameros inscritos em seus mostradores. Ele construiu 50 deles ao longo de 10 anos, embora s\u00f3 tenha vendido 15. Fonte: http://www.computerhistory.org/revolution/calculators/1/47 Primeiras M\u00e1quinas de Calcular Gottfried Wilhelm von Leibniz (1646-1716) \u00e9 creditado como um dos inventores do c\u00e1lculo diferencial e integral. Por\u00e9m, foi o primeiro a documentar e estudar profundamente o sistema bin\u00e1rio de numera\u00e7\u00e3o (base 2). Em 1672 Leibniz come\u00e7ou a inventar uma m\u00e1quina capaz de fazer as 4 opera\u00e7\u00f5es aritm\u00e9ticas, o Staffelwalze. Fonte: https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz Sistemas num\u00e9ricos \u00e9 a maneira como os seres humanos representam n\u00fameros, ao decorrer da hist\u00f3ria as civiliza\u00e7\u00f5es assumiam maneiras diferentes de representar n\u00fameros, muitas vezes possuindo diferentes maneiras de codificar oralmente/escrito. O sistema decimal \u00e9 o mais utilizado pelas civiliza\u00e7\u00f5es modernas, nele utilizamos 10 s\u00edmbolos: 0 , 1 ... 9 para representar qualquer n\u00famero, essa nota\u00e7\u00e3o remonta do fato de possuirmos 10 dedos em nossas m\u00e3os. Nesse sistema, cada digito possui um peso da ordem \\(10^n\\) : Algarismos indo-ar\u00e1bicos O sistema de numera\u00e7\u00e3o hindu como a conhecemos hoje, pode ser atribu\u00eddo a dois homens: o astr\u00f4nomo Ariabata (\u0906\u0930\u094d\u092f\u092d\u091f) e seu pupilo Bh\u0101skara I, durante 499-522 ac. Eles inventaram um sistema que se baseia na utiliza\u00e7\u00e3o da combina\u00e7\u00e3o de s\u00edlabas para formar os n\u00fameros, em um sistema incluindo a nota\u00e7\u00e3o do zero. Fonte: https://kids.britannica.com/kids/assembly/view/89478 Base 2 \u00b6 No sistema de base 2 possu\u00edmos apenas duas op\u00e7\u00f5es de s\u00edmbolo: 0 e 1 . Nessa base, cada posi\u00e7\u00e3o possui um peso da ordem \\(2^n\\) : Dessa maneira podemos construir o valor que desejarmos de decimal ( \\(m\\) ) em bin\u00e1rio, para isso ser\u00e1 necess\u00e1rio ocupar \\(ceil(log2(m))\\) bits para armazenar o valor. A tabela a seguir ilustra algumas situa\u00e7\u00f5es: ceil : arredondar para cima Valor decimal Bits necess\u00e1rio \\(0 .. 1\\) 1 \\(0 .. 3\\) ceil(log2(4)) = 2 \\(0 .. 4\\) 2 \\(0 .. 6\\) 3 \\(0 .. 7\\) 3 \\(0 .. 15\\) 4 \\(0 .. 31\\) 5 \\(0 .. 63\\) 6 \\(0 .. 127\\) 7 Supondo que possu\u00edmos um bin\u00e1rio de tr\u00eas d\u00edgitos, um contador de 0 a 7 em decimal seria em bin\u00e1rio: 000 -> 001 -> 010 -> 011 -> 100 -> 101 -> 110 -> 111 ... . O n\u00famero 45 em bin\u00e1rio \u00e9 0b101101 : 5 4 3 2 1 0 posi\u00e7\u00e3o 2^5 2^4 2^3 2^2 2^1 2^0 peso 32 16 8 4 2 1 valor 1 0 1 1 0 1 n\u00famero bin\u00e1rio Tip N\u00e3o tem muito segredo, para interpretar n\u00fameros bin\u00e1rios facilmente \u00e9 necess\u00e1ria pr\u00e1tica! Tip Para saber qual o valor m\u00e1ximo de decimal que \u00e9 poss\u00edvel armazenar com \\(n\\) bits: \\(0 .. 2^n-1\\) Nomenclatura Iremos utilizar os prefixos: : Para indicar um n\u00famero em decimal 0b : Para indicar um n\u00famero em bin\u00e1rio 0x : Para indicar um n\u00famero em hexadecimal Exemplo: hex bin dec 0x100 != 0b100 != 100 Exercise Quanto que \u00e9 0b00110 em decimal? Answer 6 Pergunta Converta 15 de decimal para bin\u00e1rio: 0015 1111 1110 1101 Answer 0b1111 Defini\u00e7\u00f5es \u00b6 Em muitas linguagens de programa\u00e7\u00e3o \u00e9 necess\u00e1rio definirmos o tamanho da vari\u00e1vel que iremos armazenar um dado, para facilitar o entendimento damos nome a quantidade de bits que ela ir\u00e1 ocupar: 4 bits: nibble 8 bits: byte 16 bits: halfword 32 bits: word Convers\u00e3o Decimal <-> Bin\u00e1rio \u00b6 Existem diversas t\u00e9cnicas de convers\u00e3o bin\u00e1rio decimal, a seguir detalhes de como realizar essas convers\u00f5es, o segredo \u00e9 entender os pesos de cada casa de um bit no sistema bin\u00e1rio e ent\u00e3o fazer a conta inversa. Base 16 \u00b6 A base 16, ou hexadecimal, \u00e9 outra maneira de representarmos n\u00fameros utilizando n\u00e3o s\u00f3 2 ou 10 s\u00edmbolos como acabamos de ver, mas 16 s\u00edmbolos! \u00c9 como se conseguimos representar o valor 10 com um \u00fanico car\u00e1cter, no caso iremos utilizar o A . Nessa base, cada unidade possui um peso na forma \\(2^{16}\\) : Um contador no formato hexadecimal possui a seguinte forma: Decimal Bin\u00e1rio Hexadecimal 0 0000 0 1 0001 1 2 0010 2 3 0011 3 4 0100 4 5 0101 5 6 0110 6 7 0111 7 8 1000 8 9 1001 9 10 1010 A 11 1011 B 12 1100 C 13 1101 D 14 1110 E 15 1111 F 16 0001 0000 10 Base 16 \u2194 Base 2 \u00b6 A convers\u00e3o de n\u00famero na base 16 para a base 2 e vice-versa acontece de forma trivial. Da base 2 para a base 16 basta separar os bits da palavra em unidades de 4 casas e ent\u00e3o realizar a convers\u00e3o de cada grupo de 4 bits para o seu equivalente em Hexa. Para a convers\u00e3o de hexa para bin\u00e1rio, basta converter cada s\u00edmbolo de hexa para o seu equivalente em bin\u00e1rio (4 d\u00edgitos), seguindo a tabela anterior. Exemplos: a) 0xA01 para bin\u00e1rio: A 0 1 | \\ \\ | \\ \\ 1010 0000 0001 -> 0b1010_0000_0001 b) 0b1111_0101_1000 para hexa: 1111 0101 1000 | | | | | | F 5 8 -> 0xF58 Base 16 \u2194 Base 10 \u00b6 Para converter de Hexa para Decimal basta aplicar os pesos em cada um das unidades, como demonstrado a seguir: a) 0xA01 para decimal: A 0 1 | | | | | | A.16^2 0.16^1 1.16^0 -> 10.256 + 0.16 + 1.1 = 2561 Para alterar a base de Decimal para Hexa, uma das solu\u00e7\u00f5es mais triviais \u00e9 a de converter primeiro para bin\u00e1rio e ent\u00e3o agrupar os bits de 4 em 4 e converter para hexa: Decimal -> Bin\u00e1rio -> Hexa b) 42 -> 0x ??? 32 + 8 + 2 = 42 \\ | / --------------- \\ | / | | \\ | / | v 42 -> 0b101010 -> 0010 1010 -> 0x2A | ^ | | ---------- ----|---- | Blocos de 4 bits Base 8 \u00b6 Similar as outras bases de n\u00famero, o sistema octal \u00e9 composto por 8 s\u00edmbolos: 0 .. 7 , e nele cada posi\u00e7\u00e3o possui valor na forma de: \\(8^n\\) . Veja o exemplo a seguir: a) 137 em octal para decimal: \\(1.8^2 + 3.8^1 + 7.8^0=95\\) 2 1 0 posi\u00e7\u00e3o 8^2 8^1 8^0 peso 64 8 1 peso 1 3 7 valor octal 1*64 3*8 7*1 \\(64+24+7=95\\) Para representarmos um valor octal em bin\u00e1rio, \u00e9 necess\u00e1rio reservarmos 3 bits para cada s\u00edmbolo do n\u00famero octal, a convers\u00e3o \u00e9 feita como no sistema hexadecimal, por\u00e9m aqui separando blocos de 3 bits: b) 137 para bin\u00e1rio: 001 011 111 O sistema octal \u00e9 utilizado no Linux para permiss\u00f5es de arquivos onde s\u00e3o necess\u00e1rios 3 bits para controlar se um usu\u00e1rio possui: acesso de leitura, escrita e/ou execu\u00e7\u00e3o de um determinado arquivo: Permission rwx Binary octal read, write and execute rwx 111 7 read and write rw- 110 6 read and execute r-x 101 5 read only r-- 100 4 write and execute -wx 011 3 write only -w- 010 2 execute only --x 001 1 none --- 000 0 Para modificar a permiss\u00e3o de um arquivo no linux \u00e9 necess\u00e1rio fornecer a informa\u00e7\u00e3o para tr\u00eas grupos diferentes: usu\u00e1rio , grupos na qual o usu\u00e1rio faz parte e qualquer outro user. Para isso basta escrever no terminal: / others / $ chmod 754 FILE | \\ | \\ group user Isso da permiss\u00e3o de: user: read/write/execute group: read/execute others: read Povos Alguns povos da Am\u00e9rica do Norte, M\u00e9xico e Europa utilizam o sistema octal, pois consideram a quantidade dos v\u00e3os dos dedos e n\u00e3o os dedos propriamente. Fonte: https://en.wikipedia.org/wiki/Octal#By_Native_Americans In\u00edcio da computa\u00e7\u00e3o Para que serve o sistema octal? No come\u00e7o da computa\u00e7\u00e3o a IBM possu\u00eda mem\u00f3rias com: 6-bit, 12-bit, 24-bit e 36-bit. Sendo todas as unidades divis\u00edveis por 3, o que facilita a interpreta\u00e7\u00e3o em um sistema octal. Outros sistemas \u00b6 Existem in\u00fameras maneiras de codifica\u00e7\u00e3o de n\u00fameros e/ou caracteres diversos, as mais utilizadas s\u00e3o: BCD ASCII UTF-8 BCD \u00b6 No sistema Binary-coded decimal (BCD) cada unidade de um sistema decimal \u00e9 convertido para 4 bits , muito parecido com a convers\u00e3o para Hexadecimal. Ele \u00e9 muito utilizado em rel\u00f3gios e quando h\u00e1 a necessidade de exibi\u00e7\u00e3o do valor em decimal em bin\u00e1rio (Display de 7 segmentos). Exemplo, 356 em BCD: 3 5 6 : Decimal 0011 0101 0110 : BCD ASCII \u00b6 ASCII (do ingl\u00eas American Standard Code for Information Interchange; \"C\u00f3digo Padr\u00e3o Americano para o Interc\u00e2mbio de Informa\u00e7\u00e3o\") \u00e9 uma maneira de codificar em bin\u00e1rio (8 bits) 95 sinais gr\u00e1ficos (letras, s\u00edmbolos e n\u00fameros) e alguns sinais de controle. \u00c9 muito utilizada pelos programas para armazenarem 'caracteres' e 'strings'. Fonte: www.asciitable.com Por exemplo, a palavra Insper convertido para ASCII fica da seguinte maneira (em decimal):","title":"Dados Digitais"},{"location":"Teoria-Dados/#dados-digitais","text":"Estudando Bibliografia [Cap 3,5. NISAN, 2005] [Cap 8,11,12. FLOYD, 2011] [Cap 7 TOCCI] Leitura extra: Introduction to Digital Systems - Cap. 1 Introduction to Digital Systems - Cap. 2 V\u00eddeos (extra) KhanAcademy Why Do Computers Use 1s and 0s? Binary and Transistors Explained. Primeiras M\u00e1quinas de Calcular Wilhelm Schickard (1592\u20131635) construiu em 1623 uma calculadora para seu amigo astr\u00f4nomo Johannes Kepler. Esta \u00e9 a mais antiga calculadora mec\u00e2nica conhecida de quatro fun\u00e7\u00f5es, que foi descoberta por esbo\u00e7os da sua cria\u00e7\u00e3o. Fonte: http://people.idsia.ch/~juergen/schickard.html Hist\u00f3ria Blaise Pascal (1623-1662) inventou e produziu em 1642 a Pascaline. Ela s\u00f3 podia fazer adi\u00e7\u00e3o e subtra\u00e7\u00e3o, manipulando os n\u00fameros inscritos em seus mostradores. Ele construiu 50 deles ao longo de 10 anos, embora s\u00f3 tenha vendido 15. Fonte: http://www.computerhistory.org/revolution/calculators/1/47 Primeiras M\u00e1quinas de Calcular Gottfried Wilhelm von Leibniz (1646-1716) \u00e9 creditado como um dos inventores do c\u00e1lculo diferencial e integral. Por\u00e9m, foi o primeiro a documentar e estudar profundamente o sistema bin\u00e1rio de numera\u00e7\u00e3o (base 2). Em 1672 Leibniz come\u00e7ou a inventar uma m\u00e1quina capaz de fazer as 4 opera\u00e7\u00f5es aritm\u00e9ticas, o Staffelwalze. Fonte: https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz Sistemas num\u00e9ricos \u00e9 a maneira como os seres humanos representam n\u00fameros, ao decorrer da hist\u00f3ria as civiliza\u00e7\u00f5es assumiam maneiras diferentes de representar n\u00fameros, muitas vezes possuindo diferentes maneiras de codificar oralmente/escrito. O sistema decimal \u00e9 o mais utilizado pelas civiliza\u00e7\u00f5es modernas, nele utilizamos 10 s\u00edmbolos: 0 , 1 ... 9 para representar qualquer n\u00famero, essa nota\u00e7\u00e3o remonta do fato de possuirmos 10 dedos em nossas m\u00e3os. Nesse sistema, cada digito possui um peso da ordem \\(10^n\\) : Algarismos indo-ar\u00e1bicos O sistema de numera\u00e7\u00e3o hindu como a conhecemos hoje, pode ser atribu\u00eddo a dois homens: o astr\u00f4nomo Ariabata (\u0906\u0930\u094d\u092f\u092d\u091f) e seu pupilo Bh\u0101skara I, durante 499-522 ac. Eles inventaram um sistema que se baseia na utiliza\u00e7\u00e3o da combina\u00e7\u00e3o de s\u00edlabas para formar os n\u00fameros, em um sistema incluindo a nota\u00e7\u00e3o do zero. Fonte: https://kids.britannica.com/kids/assembly/view/89478","title":"Dados Digitais"},{"location":"Teoria-Dados/#base-2","text":"No sistema de base 2 possu\u00edmos apenas duas op\u00e7\u00f5es de s\u00edmbolo: 0 e 1 . Nessa base, cada posi\u00e7\u00e3o possui um peso da ordem \\(2^n\\) : Dessa maneira podemos construir o valor que desejarmos de decimal ( \\(m\\) ) em bin\u00e1rio, para isso ser\u00e1 necess\u00e1rio ocupar \\(ceil(log2(m))\\) bits para armazenar o valor. A tabela a seguir ilustra algumas situa\u00e7\u00f5es: ceil : arredondar para cima Valor decimal Bits necess\u00e1rio \\(0 .. 1\\) 1 \\(0 .. 3\\) ceil(log2(4)) = 2 \\(0 .. 4\\) 2 \\(0 .. 6\\) 3 \\(0 .. 7\\) 3 \\(0 .. 15\\) 4 \\(0 .. 31\\) 5 \\(0 .. 63\\) 6 \\(0 .. 127\\) 7 Supondo que possu\u00edmos um bin\u00e1rio de tr\u00eas d\u00edgitos, um contador de 0 a 7 em decimal seria em bin\u00e1rio: 000 -> 001 -> 010 -> 011 -> 100 -> 101 -> 110 -> 111 ... . O n\u00famero 45 em bin\u00e1rio \u00e9 0b101101 : 5 4 3 2 1 0 posi\u00e7\u00e3o 2^5 2^4 2^3 2^2 2^1 2^0 peso 32 16 8 4 2 1 valor 1 0 1 1 0 1 n\u00famero bin\u00e1rio Tip N\u00e3o tem muito segredo, para interpretar n\u00fameros bin\u00e1rios facilmente \u00e9 necess\u00e1ria pr\u00e1tica! Tip Para saber qual o valor m\u00e1ximo de decimal que \u00e9 poss\u00edvel armazenar com \\(n\\) bits: \\(0 .. 2^n-1\\) Nomenclatura Iremos utilizar os prefixos: : Para indicar um n\u00famero em decimal 0b : Para indicar um n\u00famero em bin\u00e1rio 0x : Para indicar um n\u00famero em hexadecimal Exemplo: hex bin dec 0x100 != 0b100 != 100 Exercise Quanto que \u00e9 0b00110 em decimal? Answer 6 Pergunta Converta 15 de decimal para bin\u00e1rio: 0015 1111 1110 1101 Answer 0b1111","title":"Base 2"},{"location":"Teoria-Dados/#definicoes","text":"Em muitas linguagens de programa\u00e7\u00e3o \u00e9 necess\u00e1rio definirmos o tamanho da vari\u00e1vel que iremos armazenar um dado, para facilitar o entendimento damos nome a quantidade de bits que ela ir\u00e1 ocupar: 4 bits: nibble 8 bits: byte 16 bits: halfword 32 bits: word","title":"Defini\u00e7\u00f5es"},{"location":"Teoria-Dados/#conversao-decimal-binario","text":"Existem diversas t\u00e9cnicas de convers\u00e3o bin\u00e1rio decimal, a seguir detalhes de como realizar essas convers\u00f5es, o segredo \u00e9 entender os pesos de cada casa de um bit no sistema bin\u00e1rio e ent\u00e3o fazer a conta inversa.","title":"Convers\u00e3o Decimal &lt;-&gt; Bin\u00e1rio"},{"location":"Teoria-Dados/#base-16","text":"A base 16, ou hexadecimal, \u00e9 outra maneira de representarmos n\u00fameros utilizando n\u00e3o s\u00f3 2 ou 10 s\u00edmbolos como acabamos de ver, mas 16 s\u00edmbolos! \u00c9 como se conseguimos representar o valor 10 com um \u00fanico car\u00e1cter, no caso iremos utilizar o A . Nessa base, cada unidade possui um peso na forma \\(2^{16}\\) : Um contador no formato hexadecimal possui a seguinte forma: Decimal Bin\u00e1rio Hexadecimal 0 0000 0 1 0001 1 2 0010 2 3 0011 3 4 0100 4 5 0101 5 6 0110 6 7 0111 7 8 1000 8 9 1001 9 10 1010 A 11 1011 B 12 1100 C 13 1101 D 14 1110 E 15 1111 F 16 0001 0000 10","title":"Base 16"},{"location":"Teoria-Dados/#base-16-base-2","text":"A convers\u00e3o de n\u00famero na base 16 para a base 2 e vice-versa acontece de forma trivial. Da base 2 para a base 16 basta separar os bits da palavra em unidades de 4 casas e ent\u00e3o realizar a convers\u00e3o de cada grupo de 4 bits para o seu equivalente em Hexa. Para a convers\u00e3o de hexa para bin\u00e1rio, basta converter cada s\u00edmbolo de hexa para o seu equivalente em bin\u00e1rio (4 d\u00edgitos), seguindo a tabela anterior. Exemplos: a) 0xA01 para bin\u00e1rio: A 0 1 | \\ \\ | \\ \\ 1010 0000 0001 -> 0b1010_0000_0001 b) 0b1111_0101_1000 para hexa: 1111 0101 1000 | | | | | | F 5 8 -> 0xF58","title":"Base 16 &lt;--&gt; Base 2"},{"location":"Teoria-Dados/#base-16-base-10","text":"Para converter de Hexa para Decimal basta aplicar os pesos em cada um das unidades, como demonstrado a seguir: a) 0xA01 para decimal: A 0 1 | | | | | | A.16^2 0.16^1 1.16^0 -> 10.256 + 0.16 + 1.1 = 2561 Para alterar a base de Decimal para Hexa, uma das solu\u00e7\u00f5es mais triviais \u00e9 a de converter primeiro para bin\u00e1rio e ent\u00e3o agrupar os bits de 4 em 4 e converter para hexa: Decimal -> Bin\u00e1rio -> Hexa b) 42 -> 0x ??? 32 + 8 + 2 = 42 \\ | / --------------- \\ | / | | \\ | / | v 42 -> 0b101010 -> 0010 1010 -> 0x2A | ^ | | ---------- ----|---- | Blocos de 4 bits","title":"Base 16 &lt;--&gt; Base 10"},{"location":"Teoria-Dados/#base-8","text":"Similar as outras bases de n\u00famero, o sistema octal \u00e9 composto por 8 s\u00edmbolos: 0 .. 7 , e nele cada posi\u00e7\u00e3o possui valor na forma de: \\(8^n\\) . Veja o exemplo a seguir: a) 137 em octal para decimal: \\(1.8^2 + 3.8^1 + 7.8^0=95\\) 2 1 0 posi\u00e7\u00e3o 8^2 8^1 8^0 peso 64 8 1 peso 1 3 7 valor octal 1*64 3*8 7*1 \\(64+24+7=95\\) Para representarmos um valor octal em bin\u00e1rio, \u00e9 necess\u00e1rio reservarmos 3 bits para cada s\u00edmbolo do n\u00famero octal, a convers\u00e3o \u00e9 feita como no sistema hexadecimal, por\u00e9m aqui separando blocos de 3 bits: b) 137 para bin\u00e1rio: 001 011 111 O sistema octal \u00e9 utilizado no Linux para permiss\u00f5es de arquivos onde s\u00e3o necess\u00e1rios 3 bits para controlar se um usu\u00e1rio possui: acesso de leitura, escrita e/ou execu\u00e7\u00e3o de um determinado arquivo: Permission rwx Binary octal read, write and execute rwx 111 7 read and write rw- 110 6 read and execute r-x 101 5 read only r-- 100 4 write and execute -wx 011 3 write only -w- 010 2 execute only --x 001 1 none --- 000 0 Para modificar a permiss\u00e3o de um arquivo no linux \u00e9 necess\u00e1rio fornecer a informa\u00e7\u00e3o para tr\u00eas grupos diferentes: usu\u00e1rio , grupos na qual o usu\u00e1rio faz parte e qualquer outro user. Para isso basta escrever no terminal: / others / $ chmod 754 FILE | \\ | \\ group user Isso da permiss\u00e3o de: user: read/write/execute group: read/execute others: read Povos Alguns povos da Am\u00e9rica do Norte, M\u00e9xico e Europa utilizam o sistema octal, pois consideram a quantidade dos v\u00e3os dos dedos e n\u00e3o os dedos propriamente. Fonte: https://en.wikipedia.org/wiki/Octal#By_Native_Americans In\u00edcio da computa\u00e7\u00e3o Para que serve o sistema octal? No come\u00e7o da computa\u00e7\u00e3o a IBM possu\u00eda mem\u00f3rias com: 6-bit, 12-bit, 24-bit e 36-bit. Sendo todas as unidades divis\u00edveis por 3, o que facilita a interpreta\u00e7\u00e3o em um sistema octal.","title":"Base 8"},{"location":"Teoria-Dados/#outros-sistemas","text":"Existem in\u00fameras maneiras de codifica\u00e7\u00e3o de n\u00fameros e/ou caracteres diversos, as mais utilizadas s\u00e3o: BCD ASCII UTF-8","title":"Outros sistemas"},{"location":"Teoria-Dados/#bcd","text":"No sistema Binary-coded decimal (BCD) cada unidade de um sistema decimal \u00e9 convertido para 4 bits , muito parecido com a convers\u00e3o para Hexadecimal. Ele \u00e9 muito utilizado em rel\u00f3gios e quando h\u00e1 a necessidade de exibi\u00e7\u00e3o do valor em decimal em bin\u00e1rio (Display de 7 segmentos). Exemplo, 356 em BCD: 3 5 6 : Decimal 0011 0101 0110 : BCD","title":"BCD"},{"location":"Teoria-Dados/#ascii","text":"ASCII (do ingl\u00eas American Standard Code for Information Interchange; \"C\u00f3digo Padr\u00e3o Americano para o Interc\u00e2mbio de Informa\u00e7\u00e3o\") \u00e9 uma maneira de codificar em bin\u00e1rio (8 bits) 95 sinais gr\u00e1ficos (letras, s\u00edmbolos e n\u00fameros) e alguns sinais de controle. \u00c9 muito utilizada pelos programas para armazenarem 'caracteres' e 'strings'. Fonte: www.asciitable.com Por exemplo, a palavra Insper convertido para ASCII fica da seguinte maneira (em decimal):","title":"ASCII"},{"location":"Teoria-Linguagem-de-Maquina/","text":"Linguagem de m\u00e1quina \u00b6 Um programa em c\u00f3digo de m\u00e1quina consiste em uma sequ\u00eancia de bytes que correspondem a instru\u00e7\u00f5es que ser\u00e3o executadas pelo processador. As instru\u00e7\u00f5es do processador, chamadas de opcodes, s\u00e3o representadas por valores em hexadecimal. Fonte: https://pt.wikipedia.org/wiki/C%C3%B3digo_de_m%C3%A1quina \u00c9 o que efetivamente ser\u00e1 convertido em bin\u00e1rio e gravado na mem\u00f3ria de programa para ser lido e interpretado pela CPU. Essa convers\u00e3o \u00e9 realizada normalmente um por software chamado de Assembler ou Montador. Ele \u00e9 respons\u00e1vel por converter os OPCODES ( leaw ) no c\u00f3digo de m\u00e1quina ( 000000101010 ). Uma linguagem de m\u00e1quina \u00e9 espec\u00edfica para um Conjunto de instru\u00e7\u00f5es ( instruction set ), que define os recursos de hardware que uma determinada CPU oferece (uso de registradores, opera\u00e7\u00f5es aritm\u00e9ticas, opera\u00e7\u00f5es l\u00f3gicas, ...). Fabricantes de chips tendem a modificar o instruction set melhorando o HW entre gera\u00e7\u00f5es, essas mudan\u00e7as tem que ser feito de modo que permita que c\u00f3digos antigos executem em hardwares mais modernos (retrocompatibilidade). Defeito de ponto flutuante Em 1994, a Intel cometeu um erro no projeto do primeiro processador Pentium que causou um preju\u00edzo devido a um recall de US$ 450.000.000, esse bug de hardware fazia com que raramente uma conta de ponto flutuante tivesse resultado errado. Para saber mais a respeito: https://pt.wikipedia.org/wiki/Defeito_de_ponto_flutuante Pentium F00F bug \u00c9 um bug descoberto em 1997 que quando uma instru\u00e7\u00e3o espec\u00edfica: F0 0F C7 C8 fosse executada no hardawre, o mesmo travava e s\u00f3 voltava ao normal com um reset. Para saber mais a respeito: https://en.wikipedia.org/wiki/Pentium_F00F_bug Z01 \u00b6 A linguagem de m\u00e1quina utilizada no curso \u00e9 adaptada do livro Texto com umas pequenas mudan\u00e7as, ela possui 18 bits de largura e cada bit possui uma a\u00e7\u00e3o direta sobre a CPU, esse tipo de linguagem de m\u00e1quina \u00e9 chamado de microcode . Note CPUs mais complexas n\u00e3o possuem essa rela\u00e7\u00e3o de que cada bit da instru\u00e7\u00e3o controla algum funcionamento direto (sinal) da CPU. A seguir a defini\u00e7\u00e3o da linguagem de m\u00e1quina da nossa CPU: Instru\u00e7\u00f5es do tipo A \u00b6 Instru\u00e7\u00f5es do tipo A s\u00e3o aquelas que possibilitam o carregamento efetivo de um dado salvo no programa (ROM) para dentro da CPU. \u00c9 a maneira que possu\u00edmos de carregar uma constante no nosso hardware. Essas instru\u00e7\u00f5es s\u00e3o definidas pelo bit17 = 0 . No vers\u00e3o atual da CPU s\u00f3 possu\u00edmos uma instru\u00e7\u00e3o nessa categoria, a leaw . exemplo leaw $3, %A 000000000000000011 Instru\u00e7\u00f5es do tipo C \u00b6 Instru\u00e7\u00f5es do tipo C s\u00e3o aquelas que computam alguma coisa (n\u00famerico ou l\u00f3gico), movem dados, ou realizam mudan\u00e7as no Program Counter (salto / jump condicional ou n\u00e3o-condicional). Essas instru\u00e7\u00f5es s\u00e3o definidas pelo bit17 = 1 . Example addw %A, %D, %D 100000000100010000","title":"Linguagem de m\u00e1quina"},{"location":"Teoria-Linguagem-de-Maquina/#linguagem-de-maquina","text":"Um programa em c\u00f3digo de m\u00e1quina consiste em uma sequ\u00eancia de bytes que correspondem a instru\u00e7\u00f5es que ser\u00e3o executadas pelo processador. As instru\u00e7\u00f5es do processador, chamadas de opcodes, s\u00e3o representadas por valores em hexadecimal. Fonte: https://pt.wikipedia.org/wiki/C%C3%B3digo_de_m%C3%A1quina \u00c9 o que efetivamente ser\u00e1 convertido em bin\u00e1rio e gravado na mem\u00f3ria de programa para ser lido e interpretado pela CPU. Essa convers\u00e3o \u00e9 realizada normalmente um por software chamado de Assembler ou Montador. Ele \u00e9 respons\u00e1vel por converter os OPCODES ( leaw ) no c\u00f3digo de m\u00e1quina ( 000000101010 ). Uma linguagem de m\u00e1quina \u00e9 espec\u00edfica para um Conjunto de instru\u00e7\u00f5es ( instruction set ), que define os recursos de hardware que uma determinada CPU oferece (uso de registradores, opera\u00e7\u00f5es aritm\u00e9ticas, opera\u00e7\u00f5es l\u00f3gicas, ...). Fabricantes de chips tendem a modificar o instruction set melhorando o HW entre gera\u00e7\u00f5es, essas mudan\u00e7as tem que ser feito de modo que permita que c\u00f3digos antigos executem em hardwares mais modernos (retrocompatibilidade). Defeito de ponto flutuante Em 1994, a Intel cometeu um erro no projeto do primeiro processador Pentium que causou um preju\u00edzo devido a um recall de US$ 450.000.000, esse bug de hardware fazia com que raramente uma conta de ponto flutuante tivesse resultado errado. Para saber mais a respeito: https://pt.wikipedia.org/wiki/Defeito_de_ponto_flutuante Pentium F00F bug \u00c9 um bug descoberto em 1997 que quando uma instru\u00e7\u00e3o espec\u00edfica: F0 0F C7 C8 fosse executada no hardawre, o mesmo travava e s\u00f3 voltava ao normal com um reset. Para saber mais a respeito: https://en.wikipedia.org/wiki/Pentium_F00F_bug","title":"Linguagem de m\u00e1quina"},{"location":"Teoria-Linguagem-de-Maquina/#z01","text":"A linguagem de m\u00e1quina utilizada no curso \u00e9 adaptada do livro Texto com umas pequenas mudan\u00e7as, ela possui 18 bits de largura e cada bit possui uma a\u00e7\u00e3o direta sobre a CPU, esse tipo de linguagem de m\u00e1quina \u00e9 chamado de microcode . Note CPUs mais complexas n\u00e3o possuem essa rela\u00e7\u00e3o de que cada bit da instru\u00e7\u00e3o controla algum funcionamento direto (sinal) da CPU. A seguir a defini\u00e7\u00e3o da linguagem de m\u00e1quina da nossa CPU:","title":"Z01"},{"location":"Teoria-Linguagem-de-Maquina/#instrucoes-do-tipo-a","text":"Instru\u00e7\u00f5es do tipo A s\u00e3o aquelas que possibilitam o carregamento efetivo de um dado salvo no programa (ROM) para dentro da CPU. \u00c9 a maneira que possu\u00edmos de carregar uma constante no nosso hardware. Essas instru\u00e7\u00f5es s\u00e3o definidas pelo bit17 = 0 . No vers\u00e3o atual da CPU s\u00f3 possu\u00edmos uma instru\u00e7\u00e3o nessa categoria, a leaw . exemplo leaw $3, %A 000000000000000011","title":"Instru\u00e7\u00f5es do tipo A"},{"location":"Teoria-Linguagem-de-Maquina/#instrucoes-do-tipo-c","text":"Instru\u00e7\u00f5es do tipo C s\u00e3o aquelas que computam alguma coisa (n\u00famerico ou l\u00f3gico), movem dados, ou realizam mudan\u00e7as no Program Counter (salto / jump condicional ou n\u00e3o-condicional). Essas instru\u00e7\u00f5es s\u00e3o definidas pelo bit17 = 1 . Example addw %A, %D, %D 100000000100010000","title":"Instru\u00e7\u00f5es do tipo C"},{"location":"Teoria-Logica-Sequencial/","text":"L\u00f3gica Sequencial \u00b6 2022-2 Material atualizado. Colossus O Colossus foi um computador Brit\u00e2nico de 1700 v\u00e1lvulas, feito em 1943 para decifrar c\u00f3digos nazistas durante a segunda guerra mundial. O computador e planos foram destru\u00eddos para manter o projeto em segredo. Uma caracter\u00edsta importante desse computador \u00e9 que ele podia ser programado e reprogramado para decifrar as mensagens nazistas. Essa flexibilidade de programa\u00e7\u00e3o foi revolucion\u00e1ria. O computador usava um mecanismo de mem\u00f3ria chamado de flip-flops, que foi desenvolvido muitos anos antes pelos professores http://www.britannica.com/technology/computer/images-videos/The-Colossus-computer-at-Bletchley-Park-Buckinghamshire-England-1943/19626 http://www.computerhistory.org/revolution/digital-logic/12/269 https://en.wikipedia.org/wiki/Flip-flop_(electronics ) At\u00e9 este momento do curso s\u00f3 usamos circuitos criados com l\u00f3gica combinacional, por\u00e9m nem todos os tipos de l\u00f3gica digital podem ser enquadrados nessa categoria. Nessa l\u00f3gica uma tabela verdade define bem a sa\u00edda de um circuito. Nesses casos, podemos dizer que ao colocar os sinais nas entradas de uma unidade l\u00f3gica aritm\u00e9tica temos quase que instantaneamente uma sa\u00edda v\u00e1lida independente dos sinais que estavam anteriormente no circuito. J\u00e1 na l\u00f3gica sequencial o estado anterior das entradas influencia na sa\u00edda, ou seja, essa l\u00f3gica possui uma mem\u00f3ria. E \u00e9 justamente essa caracter\u00edstica de mem\u00f3ria de estados anteriores que nos interessa. Podemos por exemplo armazenar valores para uso futuro, ou tomar uma decis\u00e3o com base no estado anterior/atual. http://www.inf.pucrs.br/~emoreno/undergraduate/SI/orgarq/class_files/Aula06.pdf http://www.ee.surrey.ac.uk/Projects/CAL/seq-switching/General_seq_circ.htm Sistemas sequ\u00eancias s\u00e3o em sua grande maioria combinados com sistema s\u00edncrono, onde todos o circuito digital opera em um determinado ritmo, esse sinal \u00e9 conhecido como clock do sistema. Circuitos biest\u00e1veis \u00b6 Um dos circuitos sequenciais mais simples existentes s\u00e3o os circuitos biest\u00e1veis, que s\u00e3o chamados assim pois permanecem em um dos dois estados bin\u00e1rios ( 0 ou 1 ) enquanto estiver energizado. Eles s\u00e3o usados para armazenar e recuperar os estados dos bits dos computadores. http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/nandlatch.html#c1 O latch SR \u00e9 um circuito biest\u00e1vel composto de duas portas NOR que armazenam um valor simples. Fonte: WikiBook Neste circuito normalmente as entradas S e R , conhecidas como Set e Reset, ficam em n\u00edvel baixo. Enquanto estiverem assim o valor das sa\u00eddas Q e \\(\\bar{Q}\\) , que \u00e9 sempre o inverso do Q , se mantem inalterados. Se o n\u00edvel do S subir ( 1 ) a sa\u00edda Q fica em n\u00edvel alto, ou podemos dizer 1 , j\u00e1 se o n\u00edvel do R , Q fica em n\u00edvel l\u00f3gico baixo, ou seja 0 . A tabela a seguir ilustra o texto: \\(S\\) \\(R\\) \\(Q\\) \\(\\bar{Q}\\) 0 0 Armazenado !Armazenado 1 0 1 0 0 1 0 1 1 1 metaest\u00e1vel metaest\u00e1vel Metaest\u00e1vel Oxford Languages: capaz de perder a estabilidade atrav\u00e9s de pequenas perturba\u00e7\u00f5es (diz-se de sistema f\u00edsico). No circuito anterior mestaest\u00e1vel indica que a sa\u00edda pode ser 0 ou 1 , e que n\u00e3o podemos prever qual ser\u00e1. Um outro circuito biest\u00e1vel \u00e9 o latch tipo D, nesse caso o circuito mantem o valor da entrada de Dados D enquanto a entrada de Enable E estiver em n\u00edvel alto, se o sinal E for para n\u00edvel baixo o circuito n\u00e3o muda de estado. Esse componente possui a tabela verdade a seguir: \\(E\\) \\(D\\) \\(Q\\) \\(\\bar{Q}\\) 0 0 Armazenado !Armazenado 0 1 Armazenado !Armazenado 1 0 Copia Entrada D : 0 Copia Entrad D negada: 1 1 1 Copia Entrada D : 1 Copia Entrada D negada: 0 Clock \u00b6 Em sistemas digitais, precisamos considerar que cada porta l\u00f3gica possui um tempo de propaga\u00e7\u00e3o do resultado, a resposta de uma porta AND n\u00e3o \u00e9 imediata, leva alguns ns para que o resultado da opera\u00e7\u00e3o a and b estabilize na sa\u00edda. Cada porta possui tempos de propaga\u00e7\u00e3o distintos (at\u00e9 uma mesma porta AND possui diferen\u00e7a de tempo entre elas). Imagine um sistema com centenas de milhares de portas l\u00f3gicas onde um sinal pode percorrer por diversos caminhos diferentes, mas precisa chegar na sa\u00edda ao mesmo tempo. Em hardware isso \u00e9 muito dif\u00edcil de prever/ controlar. A solu\u00e7\u00e3o utilizada nesses casos \u00e9 a de sincronizar os sinais com diferentes tempos de propaga\u00e7\u00e3o. Podemos fazer analogia com uma banda que possui um saxofonista muito virtuoso chamado de Nand-Parker e um pianista mais calmo chamado de Or-Brubeck, o que aconteceria se cada um tocasse em seu tempo? O resultado com certeza n\u00e3o serial bom! Para isso cada m\u00fasica possui um ritmo/ batida, na qual os m\u00fasicos por mais 'velozes/lentos' que sejam, precisam seguir. Em um sistema digital, esse \u00e9 um dos papeis do clock! fazer com que todos executem ao mesmo tempo. O clock \u00e9 um sinal el\u00e9trico peri\u00f3dico utilizado para sincronizar sistemas digitais, utilizado em todo circuito s\u00edncrono, serve como o 'baterista' da banda, dando o ritmo de execu\u00e7\u00e3o para a eletr\u00f4nica. A cada novo clock (instante que ocorre uma mudan\u00e7a no sinal 0 -> 1 ), o sistema come\u00e7a uma nova opera\u00e7\u00e3o. O sinal do clock \u00e9 geralmente peri\u00f3dico e de modula\u00e7\u00e3o 50% (50% em alto e 50% em baixo): Frequ\u00eancia F=1/L Clock de 3Ghz S\u00e3o 3 bilh\u00f5es 3_000_000_000 de bordas ( 0 -> 1 ) em um segundo!! Imagine que a cada borda, uma opera\u00e7\u00e3o \u00e9 realizada no computador, s\u00e3o 3 bilh\u00f5es de opera\u00e7\u00f5es em um \u00fanico segundo.... Overclock? Muitos de voc\u00eas j\u00e1 ouviram falar overclock? Nessa t\u00e9cnica, aumentasse o clock para uma frequ\u00eancia na qual o sistema n\u00e3o foi projetado para operar, consequ\u00eancias disso s\u00e3o: Poss\u00edveis erros de processamento (dado que parte do circuito pode ser mais lento que o 1/f) Superaquecimento do chip, j\u00e1 que a tecnologia atual utilizada para fabrica\u00e7\u00e3o de componentes eletr\u00f4nicos (MOSFET) 'gasta' energia a cada clock. Com um aumento no clock, mais energia \u00e9 gasta por segundo. Borda Nem todo sistema digital trabalha com borda de subida ( rising_edge ) ( 0 -> 1 ), outras op\u00e7\u00f5es s\u00e3o: borda de descida ( falling_edge ): 1 -> 0 . double data rate (DDR): Uma nova mudan\u00e7a a cada borda, subida e descida. ( Dai que vem o nome da mem\u00f3ria DDR4 do seu computador! ) http://slideplayer.com.br/slide/370185/ http://www.plantation-productions.com/Webster/www.artofasm.com/Linux/HTML/SystemOrganizationa4.html http://www.gitam.edu/eresource/comp/gvr/6.1.htm Flip-Flop \u00b6 Flip-Flop (FF) \u00e9 um circuito similar ao LATCH por\u00e9m s\u00edncrono, ou seja, a mudan\u00e7a na sa\u00edda ( Q ) s\u00f3 ocorre na borda do clock. Tip FF s\u00e3o usados por diversas raz\u00f5es, nesse curso vamos explorar o uso do FF para a cria\u00e7\u00e3o de uma unidade de armazenamento de bits. Note Sabe o CI 555? Aquele usado em acionamentos para gerar o PWM? Internamente ele possui um FF do tipo D: Fonte: https://www.electronics-tutorials.ws/waveforms/555_timer.html Existem diversos tipos de FF, mas vamos explorar apenas o FF do tipo D. FF tipo D \u00b6 O FF tipo D possui as seguintes portas: \\(D\\) entrada do de Dado \\(Q\\) sa\u00edda do dado copiado \\(\\bar{Q}\\) sa\u00edda do dado copiado \\(CLK\\) entrada do clock Toda vez que o ocorre uma borda de subina no clock , o sinal que est\u00e1 na entrada D \u00e9 copiado para a sa\u00edda Q , conforme diagrama a seguir: A tabela verdade desse componente \u00e9 representada da seguinte maneira: \\(D\\) (in) \\(clk\\) (in) \\(Q\\) (out) 0 0 Q* 1 1 Q* 0 ^ 0 1 ^ 1 ^ : borda de subida Q* : Q armazenado anteriormente Clear e Preset \u00b6 FF do tipo D podem possuir mais dois sinais de controle: clear e preset . O sinal clear faz com que a sa\u00edda Q v\u00e1 para 0 independe da entada D e do clock . O sinal preset faz com que a sa\u00edda Q v\u00e1 para 1 independente da entrada D e do clock . A tabela verdade com esses sinais a mais fica: \\(D\\) (in) \\(clr\\) \\(set\\) \\(clk\\) (in) \\(Q\\) (out) x 0 0 x Q* x 1 0 x 0 x 0 1 x 1 0 0 0 ^ 0 1 0 0 ^ 1","title":"L\u00f3gica Sequencial"},{"location":"Teoria-Logica-Sequencial/#logica-sequencial","text":"2022-2 Material atualizado. Colossus O Colossus foi um computador Brit\u00e2nico de 1700 v\u00e1lvulas, feito em 1943 para decifrar c\u00f3digos nazistas durante a segunda guerra mundial. O computador e planos foram destru\u00eddos para manter o projeto em segredo. Uma caracter\u00edsta importante desse computador \u00e9 que ele podia ser programado e reprogramado para decifrar as mensagens nazistas. Essa flexibilidade de programa\u00e7\u00e3o foi revolucion\u00e1ria. O computador usava um mecanismo de mem\u00f3ria chamado de flip-flops, que foi desenvolvido muitos anos antes pelos professores http://www.britannica.com/technology/computer/images-videos/The-Colossus-computer-at-Bletchley-Park-Buckinghamshire-England-1943/19626 http://www.computerhistory.org/revolution/digital-logic/12/269 https://en.wikipedia.org/wiki/Flip-flop_(electronics ) At\u00e9 este momento do curso s\u00f3 usamos circuitos criados com l\u00f3gica combinacional, por\u00e9m nem todos os tipos de l\u00f3gica digital podem ser enquadrados nessa categoria. Nessa l\u00f3gica uma tabela verdade define bem a sa\u00edda de um circuito. Nesses casos, podemos dizer que ao colocar os sinais nas entradas de uma unidade l\u00f3gica aritm\u00e9tica temos quase que instantaneamente uma sa\u00edda v\u00e1lida independente dos sinais que estavam anteriormente no circuito. J\u00e1 na l\u00f3gica sequencial o estado anterior das entradas influencia na sa\u00edda, ou seja, essa l\u00f3gica possui uma mem\u00f3ria. E \u00e9 justamente essa caracter\u00edstica de mem\u00f3ria de estados anteriores que nos interessa. Podemos por exemplo armazenar valores para uso futuro, ou tomar uma decis\u00e3o com base no estado anterior/atual. http://www.inf.pucrs.br/~emoreno/undergraduate/SI/orgarq/class_files/Aula06.pdf http://www.ee.surrey.ac.uk/Projects/CAL/seq-switching/General_seq_circ.htm Sistemas sequ\u00eancias s\u00e3o em sua grande maioria combinados com sistema s\u00edncrono, onde todos o circuito digital opera em um determinado ritmo, esse sinal \u00e9 conhecido como clock do sistema.","title":"L\u00f3gica Sequencial"},{"location":"Teoria-Logica-Sequencial/#circuitos-biestaveis","text":"Um dos circuitos sequenciais mais simples existentes s\u00e3o os circuitos biest\u00e1veis, que s\u00e3o chamados assim pois permanecem em um dos dois estados bin\u00e1rios ( 0 ou 1 ) enquanto estiver energizado. Eles s\u00e3o usados para armazenar e recuperar os estados dos bits dos computadores. http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/nandlatch.html#c1 O latch SR \u00e9 um circuito biest\u00e1vel composto de duas portas NOR que armazenam um valor simples. Fonte: WikiBook Neste circuito normalmente as entradas S e R , conhecidas como Set e Reset, ficam em n\u00edvel baixo. Enquanto estiverem assim o valor das sa\u00eddas Q e \\(\\bar{Q}\\) , que \u00e9 sempre o inverso do Q , se mantem inalterados. Se o n\u00edvel do S subir ( 1 ) a sa\u00edda Q fica em n\u00edvel alto, ou podemos dizer 1 , j\u00e1 se o n\u00edvel do R , Q fica em n\u00edvel l\u00f3gico baixo, ou seja 0 . A tabela a seguir ilustra o texto: \\(S\\) \\(R\\) \\(Q\\) \\(\\bar{Q}\\) 0 0 Armazenado !Armazenado 1 0 1 0 0 1 0 1 1 1 metaest\u00e1vel metaest\u00e1vel Metaest\u00e1vel Oxford Languages: capaz de perder a estabilidade atrav\u00e9s de pequenas perturba\u00e7\u00f5es (diz-se de sistema f\u00edsico). No circuito anterior mestaest\u00e1vel indica que a sa\u00edda pode ser 0 ou 1 , e que n\u00e3o podemos prever qual ser\u00e1. Um outro circuito biest\u00e1vel \u00e9 o latch tipo D, nesse caso o circuito mantem o valor da entrada de Dados D enquanto a entrada de Enable E estiver em n\u00edvel alto, se o sinal E for para n\u00edvel baixo o circuito n\u00e3o muda de estado. Esse componente possui a tabela verdade a seguir: \\(E\\) \\(D\\) \\(Q\\) \\(\\bar{Q}\\) 0 0 Armazenado !Armazenado 0 1 Armazenado !Armazenado 1 0 Copia Entrada D : 0 Copia Entrad D negada: 1 1 1 Copia Entrada D : 1 Copia Entrada D negada: 0","title":"Circuitos biest\u00e1veis"},{"location":"Teoria-Logica-Sequencial/#clock","text":"Em sistemas digitais, precisamos considerar que cada porta l\u00f3gica possui um tempo de propaga\u00e7\u00e3o do resultado, a resposta de uma porta AND n\u00e3o \u00e9 imediata, leva alguns ns para que o resultado da opera\u00e7\u00e3o a and b estabilize na sa\u00edda. Cada porta possui tempos de propaga\u00e7\u00e3o distintos (at\u00e9 uma mesma porta AND possui diferen\u00e7a de tempo entre elas). Imagine um sistema com centenas de milhares de portas l\u00f3gicas onde um sinal pode percorrer por diversos caminhos diferentes, mas precisa chegar na sa\u00edda ao mesmo tempo. Em hardware isso \u00e9 muito dif\u00edcil de prever/ controlar. A solu\u00e7\u00e3o utilizada nesses casos \u00e9 a de sincronizar os sinais com diferentes tempos de propaga\u00e7\u00e3o. Podemos fazer analogia com uma banda que possui um saxofonista muito virtuoso chamado de Nand-Parker e um pianista mais calmo chamado de Or-Brubeck, o que aconteceria se cada um tocasse em seu tempo? O resultado com certeza n\u00e3o serial bom! Para isso cada m\u00fasica possui um ritmo/ batida, na qual os m\u00fasicos por mais 'velozes/lentos' que sejam, precisam seguir. Em um sistema digital, esse \u00e9 um dos papeis do clock! fazer com que todos executem ao mesmo tempo. O clock \u00e9 um sinal el\u00e9trico peri\u00f3dico utilizado para sincronizar sistemas digitais, utilizado em todo circuito s\u00edncrono, serve como o 'baterista' da banda, dando o ritmo de execu\u00e7\u00e3o para a eletr\u00f4nica. A cada novo clock (instante que ocorre uma mudan\u00e7a no sinal 0 -> 1 ), o sistema come\u00e7a uma nova opera\u00e7\u00e3o. O sinal do clock \u00e9 geralmente peri\u00f3dico e de modula\u00e7\u00e3o 50% (50% em alto e 50% em baixo): Frequ\u00eancia F=1/L Clock de 3Ghz S\u00e3o 3 bilh\u00f5es 3_000_000_000 de bordas ( 0 -> 1 ) em um segundo!! Imagine que a cada borda, uma opera\u00e7\u00e3o \u00e9 realizada no computador, s\u00e3o 3 bilh\u00f5es de opera\u00e7\u00f5es em um \u00fanico segundo.... Overclock? Muitos de voc\u00eas j\u00e1 ouviram falar overclock? Nessa t\u00e9cnica, aumentasse o clock para uma frequ\u00eancia na qual o sistema n\u00e3o foi projetado para operar, consequ\u00eancias disso s\u00e3o: Poss\u00edveis erros de processamento (dado que parte do circuito pode ser mais lento que o 1/f) Superaquecimento do chip, j\u00e1 que a tecnologia atual utilizada para fabrica\u00e7\u00e3o de componentes eletr\u00f4nicos (MOSFET) 'gasta' energia a cada clock. Com um aumento no clock, mais energia \u00e9 gasta por segundo. Borda Nem todo sistema digital trabalha com borda de subida ( rising_edge ) ( 0 -> 1 ), outras op\u00e7\u00f5es s\u00e3o: borda de descida ( falling_edge ): 1 -> 0 . double data rate (DDR): Uma nova mudan\u00e7a a cada borda, subida e descida. ( Dai que vem o nome da mem\u00f3ria DDR4 do seu computador! ) http://slideplayer.com.br/slide/370185/ http://www.plantation-productions.com/Webster/www.artofasm.com/Linux/HTML/SystemOrganizationa4.html http://www.gitam.edu/eresource/comp/gvr/6.1.htm","title":"Clock"},{"location":"Teoria-Logica-Sequencial/#flip-flop","text":"Flip-Flop (FF) \u00e9 um circuito similar ao LATCH por\u00e9m s\u00edncrono, ou seja, a mudan\u00e7a na sa\u00edda ( Q ) s\u00f3 ocorre na borda do clock. Tip FF s\u00e3o usados por diversas raz\u00f5es, nesse curso vamos explorar o uso do FF para a cria\u00e7\u00e3o de uma unidade de armazenamento de bits. Note Sabe o CI 555? Aquele usado em acionamentos para gerar o PWM? Internamente ele possui um FF do tipo D: Fonte: https://www.electronics-tutorials.ws/waveforms/555_timer.html Existem diversos tipos de FF, mas vamos explorar apenas o FF do tipo D.","title":"Flip-Flop"},{"location":"Teoria-Logica-Sequencial/#ff-tipo-d","text":"O FF tipo D possui as seguintes portas: \\(D\\) entrada do de Dado \\(Q\\) sa\u00edda do dado copiado \\(\\bar{Q}\\) sa\u00edda do dado copiado \\(CLK\\) entrada do clock Toda vez que o ocorre uma borda de subina no clock , o sinal que est\u00e1 na entrada D \u00e9 copiado para a sa\u00edda Q , conforme diagrama a seguir: A tabela verdade desse componente \u00e9 representada da seguinte maneira: \\(D\\) (in) \\(clk\\) (in) \\(Q\\) (out) 0 0 Q* 1 1 Q* 0 ^ 0 1 ^ 1 ^ : borda de subida Q* : Q armazenado anteriormente","title":"FF tipo D"},{"location":"Teoria-Logica-Sequencial/#clear-e-preset","text":"FF do tipo D podem possuir mais dois sinais de controle: clear e preset . O sinal clear faz com que a sa\u00edda Q v\u00e1 para 0 independe da entada D e do clock . O sinal preset faz com que a sa\u00edda Q v\u00e1 para 1 independente da entrada D e do clock . A tabela verdade com esses sinais a mais fica: \\(D\\) (in) \\(clr\\) \\(set\\) \\(clk\\) (in) \\(Q\\) (out) x 0 0 x Q* x 1 0 x 0 x 0 1 x 1 0 0 0 ^ 0 1 0 0 ^ 1","title":"Clear e Preset"},{"location":"Teoria-Numeros-Binarios/","text":"N\u00fameros bin\u00e1rios \u00b6 Conte\u00fado: Complemento de um/ Complemento de dois/ Ponto fixo/ Soma bin\u00e1ria/ Podemos utilizar n\u00fameros bin\u00e1rios para codificar qualquer tipo de dado, como vimos na teoria de dados digitais. Mas ainda n\u00e3o sabemos como utilizar n\u00fameros bin\u00e1rios para representar: n\u00fameros inteiros que possam ser negativos e n\u00fameros reais (exe: 1,032 ). Essa teoria ir\u00e1 tratar desses temas e tamb\u00e9m da parte referente a opera\u00e7\u00f5es com n\u00fameros bin\u00e1rios (soma e subtra\u00e7\u00e3o). Soma bin\u00e1ria \u00b6 A soma bin\u00e1ria \u00e9 realizada de maneira similar a soma de decimais, s\u00f3 que precisamos notar que 1 + 1 em bin\u00e1rio ( esse um \u00e9 de soma n\u00e3o de OR ), resulta em 10 , esse 1 do estouro e que passa para a pr\u00f3xima casa \u00e9 chamado de carry . Esse carry \u00e9 similar ao vai um em uma soma decimal, no caso quando somamos 9 + 3 o resultado \u00e9 12 . Exemplos consideram Somador de 8 bits N\u00fameros inteiros n\u00e3o sinalizados 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) Precisamos perceber que cada bit \u00e9 armazenado 'real', um sistema com 8 bits n\u00e3o consegue armazenar 9 bits, e se houver um estouro no \u00faltimo bit essa informa\u00e7\u00e3o ser\u00e1 perdida. 0x80 + 0x80 = 0x100, mas resulta em 0x00 por conta do somador ser 8 bits: carry \u00e9 perdido 1 \\ 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 + --------------- 0 0 0 0 0 0 0 0 0x03 + 0x81 = 0x84 1 1 : carry (vai um) \\ 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 + --------------- 1 0 0 0 0 1 0 0 complemento de 1 \u00b6 Warning Forma 'errada' de armazenar n\u00fameros sinalizados (+, -) No complemento de 1, utilizamos a casa mais significativa de um vetor de bits para representar se o n\u00famero \u00e9 positivo ( 0 ) ou negativo ( 1 ). Exemplo (utilizando 4 bits): Valor +1 em bin\u00e1rio, com complemento de 1 0001 ^ | indica que o valor \u00e9 positivo Valor -1 em bin\u00e1rio, com complemento de 1 1001 ^ | indica que o valor \u00e9 negativo O problema do complemento de 1 \u00e9 que: Possu\u00edmos duas representa\u00e7\u00f5es para o valor 0: 0000 e 1000 Opera\u00e7\u00f5es de soma n\u00e3o funcionam corretamente entre os dois n\u00fameros codificados em complemento de 1. Complemento de 2 \u00b6 O complemento de dois \u00e9 uma outra maneira de representar n\u00fameros sinalizados com bits, para obter um n\u00famero positivo <-> negativo nessa nota\u00e7\u00e3o \u00e9 necess\u00e1rio seguir os seguintes passos: Inverter todos os bits (not bit a bit) da palavra original Somar um a palavra invertida","title":"N\u00fameros bin\u00e1rios"},{"location":"Teoria-Numeros-Binarios/#numeros-binarios","text":"Conte\u00fado: Complemento de um/ Complemento de dois/ Ponto fixo/ Soma bin\u00e1ria/ Podemos utilizar n\u00fameros bin\u00e1rios para codificar qualquer tipo de dado, como vimos na teoria de dados digitais. Mas ainda n\u00e3o sabemos como utilizar n\u00fameros bin\u00e1rios para representar: n\u00fameros inteiros que possam ser negativos e n\u00fameros reais (exe: 1,032 ). Essa teoria ir\u00e1 tratar desses temas e tamb\u00e9m da parte referente a opera\u00e7\u00f5es com n\u00fameros bin\u00e1rios (soma e subtra\u00e7\u00e3o).","title":"N\u00fameros bin\u00e1rios"},{"location":"Teoria-Numeros-Binarios/#soma-binaria","text":"A soma bin\u00e1ria \u00e9 realizada de maneira similar a soma de decimais, s\u00f3 que precisamos notar que 1 + 1 em bin\u00e1rio ( esse um \u00e9 de soma n\u00e3o de OR ), resulta em 10 , esse 1 do estouro e que passa para a pr\u00f3xima casa \u00e9 chamado de carry . Esse carry \u00e9 similar ao vai um em uma soma decimal, no caso quando somamos 9 + 3 o resultado \u00e9 12 . Exemplos consideram Somador de 8 bits N\u00fameros inteiros n\u00e3o sinalizados 0xAA + 0x55 = 0xFF : Carry 1 0 1 0 1 0 1 0 : A 0 1 0 1 0 1 0 1 + : B --------------- 1 1 1 1 1 1 1 1 : Resultado (A+B) Precisamos perceber que cada bit \u00e9 armazenado 'real', um sistema com 8 bits n\u00e3o consegue armazenar 9 bits, e se houver um estouro no \u00faltimo bit essa informa\u00e7\u00e3o ser\u00e1 perdida. 0x80 + 0x80 = 0x100, mas resulta em 0x00 por conta do somador ser 8 bits: carry \u00e9 perdido 1 \\ 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 + --------------- 0 0 0 0 0 0 0 0 0x03 + 0x81 = 0x84 1 1 : carry (vai um) \\ 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 + --------------- 1 0 0 0 0 1 0 0","title":"Soma bin\u00e1ria"},{"location":"Teoria-Numeros-Binarios/#complemento-de-1","text":"Warning Forma 'errada' de armazenar n\u00fameros sinalizados (+, -) No complemento de 1, utilizamos a casa mais significativa de um vetor de bits para representar se o n\u00famero \u00e9 positivo ( 0 ) ou negativo ( 1 ). Exemplo (utilizando 4 bits): Valor +1 em bin\u00e1rio, com complemento de 1 0001 ^ | indica que o valor \u00e9 positivo Valor -1 em bin\u00e1rio, com complemento de 1 1001 ^ | indica que o valor \u00e9 negativo O problema do complemento de 1 \u00e9 que: Possu\u00edmos duas representa\u00e7\u00f5es para o valor 0: 0000 e 1000 Opera\u00e7\u00f5es de soma n\u00e3o funcionam corretamente entre os dois n\u00fameros codificados em complemento de 1.","title":"complemento de 1"},{"location":"Teoria-Numeros-Binarios/#complemento-de-2","text":"O complemento de dois \u00e9 uma outra maneira de representar n\u00fameros sinalizados com bits, para obter um n\u00famero positivo <-> negativo nessa nota\u00e7\u00e3o \u00e9 necess\u00e1rio seguir os seguintes passos: Inverter todos os bits (not bit a bit) da palavra original Somar um a palavra invertida","title":"Complemento de 2"},{"location":"Teoria-RTL/","text":"Resistor-Transistor Logic (RTL) \u00b6 Conte\u00fado: RTL Estudando Bibliografia [Cap7. FLOYD, 2005] [Cap8. TOCCI, 2011] Leitura das p\u00e1ginas 1 - 13 (ler somente at\u00e9 buffer) do livro: RTL (Resistor-Transistor Logic) Cookbook by Don Lancaster. O livro est\u00e1 dispon\u00edvel em: https://archive.org/details/RTL_Resistor-Transistor_Logic_Cookbook/mode/2up Tip Mais informa\u00e7\u00f5es em: https://en.wikipedia.org/wiki/Resistor%E2%80%93transistor_logic Usando Transistores para recriar portas l\u00f3gicas \u00b6 O uso de transistores para cria\u00e7\u00e3o de portas l\u00f3gicas depende de seu uso como chave controlada eletronicamente. No transistor tipo BJT, quando o diodo na base-emissor est\u00e1 conduzindo, o transistor \u00e9 levado a satura\u00e7\u00e3o e a tens\u00e3o entre coletor e emissor se aproxima de zero. L\u00f3gica E - AND \u00b6 Para a l\u00f3gica E (AND), ambos transistores est\u00e3o em s\u00e9rie e ambos devem estar conduzindo para que a sa\u00edda (OUT) esteja em n\u00edvel ALTO. L\u00f3gica OU - OR \u00b6 Para a l\u00f3gica OU (OR), ambos transistores est\u00e3o em paralelo e enquanto pelo menos um deles estiver conduzindo, a sa\u00edda (OUT) ficara em n\u00edvel ALTO. L\u00f3gica N\u00c3O E - NAND \u00b6 Para a l\u00f3gica N\u00c3O E (NAND), ambos transistores est\u00e3o em s\u00e9rie e a sa\u00edda est\u00e1 acima deles, a sa\u00edda ser\u00e1 n\u00edvel ALTO a n\u00e3o ser que ambas entradas sejam colocadas em ALTO, no qual far\u00e1 que os transistores conduzam e levem a sa\u00edda para n\u00edvel BAIXO. L\u00f3gica N\u00c3O OU - NOR \u00b6 Para a l\u00f3gica N\u00c3O OU (NOR), ambos transistores est\u00e3o em s\u00e9rie e a sa\u00edda est\u00e1 acima deles, a sa\u00edda ser\u00e1 n\u00edvel BAIXO desde que um deles esteja conduzindo. Usando dois resistores no controle da base do transistor, \u00e9 poss\u00edvel recriar a porta NOR com apenas um transistor.","title":"Resistor-Transistor Logic (RTL)"},{"location":"Teoria-RTL/#resistor-transistor-logic-rtl","text":"Conte\u00fado: RTL Estudando Bibliografia [Cap7. FLOYD, 2005] [Cap8. TOCCI, 2011] Leitura das p\u00e1ginas 1 - 13 (ler somente at\u00e9 buffer) do livro: RTL (Resistor-Transistor Logic) Cookbook by Don Lancaster. O livro est\u00e1 dispon\u00edvel em: https://archive.org/details/RTL_Resistor-Transistor_Logic_Cookbook/mode/2up Tip Mais informa\u00e7\u00f5es em: https://en.wikipedia.org/wiki/Resistor%E2%80%93transistor_logic","title":"Resistor-Transistor Logic (RTL)"},{"location":"Teoria-RTL/#usando-transistores-para-recriar-portas-logicas","text":"O uso de transistores para cria\u00e7\u00e3o de portas l\u00f3gicas depende de seu uso como chave controlada eletronicamente. No transistor tipo BJT, quando o diodo na base-emissor est\u00e1 conduzindo, o transistor \u00e9 levado a satura\u00e7\u00e3o e a tens\u00e3o entre coletor e emissor se aproxima de zero.","title":"Usando Transistores para recriar portas l\u00f3gicas"},{"location":"Teoria-RTL/#logica-e-and","text":"Para a l\u00f3gica E (AND), ambos transistores est\u00e3o em s\u00e9rie e ambos devem estar conduzindo para que a sa\u00edda (OUT) esteja em n\u00edvel ALTO.","title":"L\u00f3gica E - AND"},{"location":"Teoria-RTL/#logica-ou-or","text":"Para a l\u00f3gica OU (OR), ambos transistores est\u00e3o em paralelo e enquanto pelo menos um deles estiver conduzindo, a sa\u00edda (OUT) ficara em n\u00edvel ALTO.","title":"L\u00f3gica OU - OR"},{"location":"Teoria-RTL/#logica-nao-e-nand","text":"Para a l\u00f3gica N\u00c3O E (NAND), ambos transistores est\u00e3o em s\u00e9rie e a sa\u00edda est\u00e1 acima deles, a sa\u00edda ser\u00e1 n\u00edvel ALTO a n\u00e3o ser que ambas entradas sejam colocadas em ALTO, no qual far\u00e1 que os transistores conduzam e levem a sa\u00edda para n\u00edvel BAIXO.","title":"L\u00f3gica N\u00c3O E - NAND"},{"location":"Teoria-RTL/#logica-nao-ou-nor","text":"Para a l\u00f3gica N\u00c3O OU (NOR), ambos transistores est\u00e3o em s\u00e9rie e a sa\u00edda est\u00e1 acima deles, a sa\u00edda ser\u00e1 n\u00edvel BAIXO desde que um deles esteja conduzindo. Usando dois resistores no controle da base do transistor, \u00e9 poss\u00edvel recriar a porta NOR com apenas um transistor.","title":"L\u00f3gica N\u00c3O OU - NOR"},{"location":"Teoria-Sequencial-Componentes/","text":"Componentes S\u00edncronos \u00b6 Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 3 Binary digit - bits \u00b6 Criado com um FlipFlop tipo D, esse componente (que vamos chamar de bit ) \u00e9 capaz de armazenar um bit e ser\u00e1 usado na constru\u00e7\u00e3o das unidades de mem\u00f3ria utilizadas na CPU. DFF = FlipFlop do tipo D Esse componente funciona da seguinte maneira: load = '0' FF \u00e9 realimentando e mant\u00e9m o valor que foi armazenado. load = '1' , na subida do clock o componente 'captura' o valor da entrada in. Pseudo c\u00f3digo que descreve o funcionamento do bit \u00e9: if load = '1' then : q = d d = d Registrador \u00b6 O registrador \u00e9 um componente formado por v\u00e1rios bits e \u00e9 capaz de armazenar um vetore de bits: 8 bits; 16 bits; 32 bits; ... . Pseudo c\u00f3digo que descreve o funcionamento do register e if load = '1' then : q [ 7 : 0 ] = d [ 7 : 0 ] d [ 7 : 0 ] = d [ 7 : 0 ] Internamente o register \u00e9 formado por diversos bits , um para cada index do vetor de bits de entrada: Ele \u00e9 utilizado geralmente dentro da CPU, como uma mem\u00f3ria do tipo 'r\u00e1pida'. Note Podemos utilizar registradores de largura w para construir registradores de largura m* w : -------------------------------- | ------------- ------------- | | | reg_8 | | reg_8 | | | ------------- ------------- | -------------------------------- reg_16 uso Na nossa CPU do lab 10, o registrador \u00e9 o HW que armazena a sa\u00edda da ULA, nesse caso ele possui 16 bits de largura! Mem\u00f3ria RAM \u00b6 Uma mem\u00f3ria \u00e9 um array de registradores, ela funciona como uma tabela, onde conseguimos armazenar um vetor de bits em algum endere\u00e7o (linha), a RAM possui as seguintes portas: in clk: entrada de clock in d: entrada do dado a ser armazenado (vetor de bits) in address: endere\u00e7o onde o word ser\u00e1 armazenado in load load = '0' : n\u00e3o armazena word load = '1' : armazena nova word out q: sa\u00edda do valor armazenado no endere\u00e7o address O sinal load funciona como um controle se a opera\u00e7\u00e3o a ser realizada na mem\u00f3ria \u00e9 a de gravar ( load = 1 ) ou apenas ler o que j\u00e1 foi salvo ( load = 0 ). Pseudo c\u00f3digo que descreve o funcionamento da mem\u00f3ria RAM if load = '1' then : ram [ address ] = d else : q = ram [ address ]","title":"Componentes S\u00edncronos"},{"location":"Teoria-Sequencial-Componentes/#componentes-sincronos","text":"Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 3","title":"Componentes S\u00edncronos"},{"location":"Teoria-Sequencial-Componentes/#binary-digit-bits","text":"Criado com um FlipFlop tipo D, esse componente (que vamos chamar de bit ) \u00e9 capaz de armazenar um bit e ser\u00e1 usado na constru\u00e7\u00e3o das unidades de mem\u00f3ria utilizadas na CPU. DFF = FlipFlop do tipo D Esse componente funciona da seguinte maneira: load = '0' FF \u00e9 realimentando e mant\u00e9m o valor que foi armazenado. load = '1' , na subida do clock o componente 'captura' o valor da entrada in. Pseudo c\u00f3digo que descreve o funcionamento do bit \u00e9: if load = '1' then : q = d d = d","title":"Binary digit - bits"},{"location":"Teoria-Sequencial-Componentes/#registrador","text":"O registrador \u00e9 um componente formado por v\u00e1rios bits e \u00e9 capaz de armazenar um vetore de bits: 8 bits; 16 bits; 32 bits; ... . Pseudo c\u00f3digo que descreve o funcionamento do register e if load = '1' then : q [ 7 : 0 ] = d [ 7 : 0 ] d [ 7 : 0 ] = d [ 7 : 0 ] Internamente o register \u00e9 formado por diversos bits , um para cada index do vetor de bits de entrada: Ele \u00e9 utilizado geralmente dentro da CPU, como uma mem\u00f3ria do tipo 'r\u00e1pida'. Note Podemos utilizar registradores de largura w para construir registradores de largura m* w : -------------------------------- | ------------- ------------- | | | reg_8 | | reg_8 | | | ------------- ------------- | -------------------------------- reg_16 uso Na nossa CPU do lab 10, o registrador \u00e9 o HW que armazena a sa\u00edda da ULA, nesse caso ele possui 16 bits de largura!","title":"Registrador"},{"location":"Teoria-Sequencial-Componentes/#memoria-ram","text":"Uma mem\u00f3ria \u00e9 um array de registradores, ela funciona como uma tabela, onde conseguimos armazenar um vetor de bits em algum endere\u00e7o (linha), a RAM possui as seguintes portas: in clk: entrada de clock in d: entrada do dado a ser armazenado (vetor de bits) in address: endere\u00e7o onde o word ser\u00e1 armazenado in load load = '0' : n\u00e3o armazena word load = '1' : armazena nova word out q: sa\u00edda do valor armazenado no endere\u00e7o address O sinal load funciona como um controle se a opera\u00e7\u00e3o a ser realizada na mem\u00f3ria \u00e9 a de gravar ( load = 1 ) ou apenas ler o que j\u00e1 foi salvo ( load = 0 ). Pseudo c\u00f3digo que descreve o funcionamento da mem\u00f3ria RAM if load = '1' then : ram [ address ] = d else : q = ram [ address ]","title":"Mem\u00f3ria RAM"},{"location":"Teoria-ULA/","text":"ULA \u00b6 2020-2 Material atualizado. Unidade L\u00f3gica Aritm\u00e9tica (ULA) \u00e9 a parte da Unidade de Processamento (CPU) respons\u00e1vel por realizar opera\u00e7\u00f5es bin\u00e1rias. Nesse hardware Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 2. Warning Estudar pelo livro, o restante dessa teoria \u00e9 apenas um resumo e algumas notas. Tip No coursera temos os autores do livro dando uma aula sobre esse t\u00f3pico. https://www.coursera.org/lecture/build-a-computer/unit-2-4-arithmetic-logic-unit-6ZS46 Arquitetura \u00b6 A ULA utilizada no curso tem a seguinte arquitetura interna: Opera\u00e7\u00f5es \u00b6 zx nx zy ny f no out 1 0 1 0 1 0 0 1 1 1 1 1 1 1 1 1 1 0 1 0 -1 0 0 1 1 0 0 x 1 1 0 0 0 0 y 0 0 1 1 0 1 !x 1 1 0 0 0 1 !y 0 0 1 1 1 1 -x 1 1 0 0 1 1 -y 0 1 1 1 1 1 x+1 1 1 0 1 1 1 y+1 0 0 1 1 1 0 x-1 1 1 0 0 1 0 y-1 0 0 0 0 1 0 x+y 0 1 0 0 1 1 x-y 0 0 0 1 1 1 y-x 0 0 0 0 0 0 x&y 0 1 0 1 0 1 x or y Opera\u00e7\u00e3o n\u00e3o trivial \u00b6 A maioria das opera\u00e7\u00f5es da nossa ULA s\u00e3o imediatas, a menos imediata de entender \u00e9 a opera\u00e7\u00e3o y-x , nesse caso, se olharmos a opera\u00e7\u00e3o que \u00e9 realizada na ULA para executar isso notamos que: \\(y-x=\\overline{x+\\bar{y}}\\) esse + \u00e9 de opera\u00e7\u00e3o de soma, n\u00e3o OR! Precisamos fazer um truque, note que: \\(\\bar{y}=-y-1\\) Substituindo: \\(\\overline{x+ (-y -1)}\\) Podemos chamar: \\(x+ (-y -1) = z\\) \\(\\overline{z}\\) , aplicando a mesma substitui\u00e7\u00e3o que 2. \\(\\overline{z}=-z-1\\) , recuperando z \\(-y-x=-(x -y -1)-1\\) \\(y-x=-x+y\\)","title":"ULA"},{"location":"Teoria-ULA/#ula","text":"2020-2 Material atualizado. Unidade L\u00f3gica Aritm\u00e9tica (ULA) \u00e9 a parte da Unidade de Processamento (CPU) respons\u00e1vel por realizar opera\u00e7\u00f5es bin\u00e1rias. Nesse hardware Leitura necess\u00e1ria The Elements of Computing Systems (Livro texto do curso), cap 2. Warning Estudar pelo livro, o restante dessa teoria \u00e9 apenas um resumo e algumas notas. Tip No coursera temos os autores do livro dando uma aula sobre esse t\u00f3pico. https://www.coursera.org/lecture/build-a-computer/unit-2-4-arithmetic-logic-unit-6ZS46","title":"ULA"},{"location":"Teoria-ULA/#arquitetura","text":"A ULA utilizada no curso tem a seguinte arquitetura interna:","title":"Arquitetura"},{"location":"Teoria-ULA/#operacoes","text":"zx nx zy ny f no out 1 0 1 0 1 0 0 1 1 1 1 1 1 1 1 1 1 0 1 0 -1 0 0 1 1 0 0 x 1 1 0 0 0 0 y 0 0 1 1 0 1 !x 1 1 0 0 0 1 !y 0 0 1 1 1 1 -x 1 1 0 0 1 1 -y 0 1 1 1 1 1 x+1 1 1 0 1 1 1 y+1 0 0 1 1 1 0 x-1 1 1 0 0 1 0 y-1 0 0 0 0 1 0 x+y 0 1 0 0 1 1 x-y 0 0 0 1 1 1 y-x 0 0 0 0 0 0 x&y 0 1 0 1 0 1 x or y","title":"Opera\u00e7\u00f5es"},{"location":"Teoria-ULA/#operacao-nao-trivial","text":"A maioria das opera\u00e7\u00f5es da nossa ULA s\u00e3o imediatas, a menos imediata de entender \u00e9 a opera\u00e7\u00e3o y-x , nesse caso, se olharmos a opera\u00e7\u00e3o que \u00e9 realizada na ULA para executar isso notamos que: \\(y-x=\\overline{x+\\bar{y}}\\) esse + \u00e9 de opera\u00e7\u00e3o de soma, n\u00e3o OR! Precisamos fazer um truque, note que: \\(\\bar{y}=-y-1\\) Substituindo: \\(\\overline{x+ (-y -1)}\\) Podemos chamar: \\(x+ (-y -1) = z\\) \\(\\overline{z}\\) , aplicando a mesma substitui\u00e7\u00e3o que 2. \\(\\overline{z}=-z-1\\) , recuperando z \\(-y-x=-(x -y -1)-1\\) \\(y-x=-x+y\\)","title":"Opera\u00e7\u00e3o n\u00e3o trivial"},{"location":"Teoria-Z01-mapadeMemoria/","text":"ASM - Mapa de mem\u00f3ria \u00b6 2020-2 Material atualizado. A forma na qual a maioria das CPUs acessam perif\u00e9ricos (teclado/ mouse/ USB/ tela/ ...) \u00e9 a do perif\u00e9rico mapeado em mem\u00f3ria. Essa t\u00e9cnica utiliza da capacidade do computador de escrever e ler da mem\u00f3ria RAM, fazendo com que regi\u00f5es de endere\u00e7os da mem\u00f3ria n\u00e3o sejam uma 'mem\u00f3ria' f\u00edsica, mas sim um perif\u00e9rico do computador. Vamos trabalhar com o exemplo do nosso Z01, a mem\u00f3ria \u00e9 composta de: RAM LCD Chaves LEDs Nesse nosso hardware a mem\u00f3ria que \u00e9 vis\u00edvel pela CPU \u00e9 organizada da seguinte maneira: Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 0 - 16383 RAM r/w 16384 - 21183 LCD w 21184 LED w 21185 SW r RAM \u00b6 Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 0 - 16383 RAM r/w A mem\u00f3ria RAM \u00e9 um componente do computador que permite guardar dados vol\u00e1teis (que v\u00e3o se perder ap\u00f3s o reset do computador). \u00c9 nela que guardamos as vari\u00e1veis do programa. Note Nossa mem\u00f3ria RAM possui 16 bits de largura. A princ\u00edpio podemos utilizar qualquer endere\u00e7o da mem\u00f3ria RAM para armazenar dados tempor\u00e1rios, isso n\u00e3o ser\u00e1 verdade mais para frente do curso, onde iremos organizar nossa mem\u00f3ria RAM em sec\u00e7\u00f5es. Tip Iremos dar alguns nomes para os endere\u00e7os espec\u00edficos da mem\u00f3ria RAM: endere\u00e7o label / nome 0 SP 1 LCL 2 ARG 3 THIS 4 THAT Example Vamos fazer um exemplo que l\u00ea um dado na RAM[3] o incrementa e salva novamente no mesmo endere\u00e7o de mem\u00f3ria: c\u00f3digo leaw $ 3 , % A ; faz %A = 3 (%A aponta para RAM[3]) movw ( % A ), % D ; move o valor de RAM[%A] para %D incw % D ; incrementa o valor de D (D = D + 1, D = RAM[3] + 1) movw % D , ( % A ) ; move o valor incrementado de volta para a RAM[3] Podemos tamb\u00e9m usar o label ARG para referencia o endere\u00e7o 3 da mem\u00f3ria RAM: leaw $ ARG , % A ; faz %A = 3 (%A aponta para RAM[ARG]) simulador hardware Tip Execute voc\u00ea esse c\u00f3digo no simulador! E analise o resultado. Warning \u00c9 necess\u00e1rio notar que a mem\u00f3ria RAM n\u00e3o \u00e9 um registrador e possui uma grande limita\u00e7\u00e3o , n\u00e3o podemos realizar uma a\u00e7\u00e3o de ESCRITA E LEITURA no mesmo ciclo! O que impossibilita de fazermos o seguinte: leaw $ 3 , % A incw ( % A ) ; N\u00e3o funciona no nosso hardware!! addw ( % A ), % D , ( % A ) ; Nao funciona no nosso hardware!! O assembly permite que voc\u00eas escrevam essas opera\u00e7\u00f5es, por\u00e9m quando forem executar no hardware o resultado n\u00e3o vai ser o esperado. LEDs \u00b6 Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 21184 LED w Os LEDs da FPGA s\u00e3o mapeados no endere\u00e7o de mem\u00f3ria 21184 onde cada bit (9..0) representa um LED, se o bit espec\u00edfico estiver valor 1 o LED est\u00e1 aceso e 0 apagado. Example Como isso \u00e9 traduzido para c\u00f3digo? Imagine que desejamos acender um LED que nosso computador controla, para isso devemos fazer com que o registrador %A aponte para o endere\u00e7o de mem\u00f3ria na qual o LED est\u00e1 associado e ent\u00e3o escreva nele: c\u00f3digo leaw $ 21184 , % A ; endere\u00e7o do LED movw $ 1 , ( % A ) ; move valor 1 para ele simulador Tip Execute voc\u00ea esse c\u00f3digo no simulador! Tip Note que usamos movw $1, (%A) , nossa ULA \u00e9 capaz de gerar os valores 1 , -1 e 0 , mas outros valores n\u00e3o! SW \u00b6 Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 21185 SW r Os chaves (SW) da FPGA s\u00e3o mapeados no endere\u00e7o de mem\u00f3ria 21185 onde cada bit (9..0) representa uma chave, se o bit espec\u00edfico estiver valor 1 indica que a chave est\u00e1 ligada (on) e 0 desligada. Example O exemplo a seguir copia o valor das chaves para os LEDs: c\u00f3digo leaw $ 21185 , % A ; endere\u00e7o da chave movw ( % A ), % D ; copia valor das chaves para %D leaw $ 21184 , % A ; endere\u00e7o do LED movw % D , ( % A ) ; move valor das chaves para %D simulador Tip Execute voc\u00ea esse c\u00f3digo no simulador! LCD \u00b6 Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 16384 - 21183 LCD w O nosso LCD \u00e9 um dispositivo de 320x240 pixels. Cada linha do endere\u00e7o de mem\u00f3ria do LCD representa 16 pixels do dispositivo, conforme figura anterior. Para acender um pixel, basta colocar 1 ou 0 para apagar.- endere\u00e7os do LCD Como nosso LCD possui 320px na horizontal, e como cada endere\u00e7o de mem\u00f3ria acessa 16px por vez, uma linha \u00e9 acess\u00edvel por: 320/16 = 20 endere\u00e7os. Ou seja, para acessar os primeiros px de cada linha devemos escrever endere\u00e7o de mem\u00f3ria: Primeira linha: 16384 + 0 vezes 20 : 16384 Segunda linha: 16384 + 1 vezes 20 : 16404 Terceira linha: 16384 + 2 vezes 20 : 16424 ... \u00daltima linha: 16384 + 239 vezes 20 : 21164 LCD Vamos desenhar px no meio do LCD que, para isso precisamos carregar o valor 0x 0001 no endere\u00e7o 18242 leaw $ 18242 , % A movw $ 1 , ( % A ) Tip Execute voc\u00ea esse c\u00f3digo no simulador!","title":"ASM - Mapa de mem\u00f3ria"},{"location":"Teoria-Z01-mapadeMemoria/#asm-mapa-de-memoria","text":"2020-2 Material atualizado. A forma na qual a maioria das CPUs acessam perif\u00e9ricos (teclado/ mouse/ USB/ tela/ ...) \u00e9 a do perif\u00e9rico mapeado em mem\u00f3ria. Essa t\u00e9cnica utiliza da capacidade do computador de escrever e ler da mem\u00f3ria RAM, fazendo com que regi\u00f5es de endere\u00e7os da mem\u00f3ria n\u00e3o sejam uma 'mem\u00f3ria' f\u00edsica, mas sim um perif\u00e9rico do computador. Vamos trabalhar com o exemplo do nosso Z01, a mem\u00f3ria \u00e9 composta de: RAM LCD Chaves LEDs Nesse nosso hardware a mem\u00f3ria que \u00e9 vis\u00edvel pela CPU \u00e9 organizada da seguinte maneira: Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 0 - 16383 RAM r/w 16384 - 21183 LCD w 21184 LED w 21185 SW r","title":"ASM - Mapa de mem\u00f3ria"},{"location":"Teoria-Z01-mapadeMemoria/#ram","text":"Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 0 - 16383 RAM r/w A mem\u00f3ria RAM \u00e9 um componente do computador que permite guardar dados vol\u00e1teis (que v\u00e3o se perder ap\u00f3s o reset do computador). \u00c9 nela que guardamos as vari\u00e1veis do programa. Note Nossa mem\u00f3ria RAM possui 16 bits de largura. A princ\u00edpio podemos utilizar qualquer endere\u00e7o da mem\u00f3ria RAM para armazenar dados tempor\u00e1rios, isso n\u00e3o ser\u00e1 verdade mais para frente do curso, onde iremos organizar nossa mem\u00f3ria RAM em sec\u00e7\u00f5es. Tip Iremos dar alguns nomes para os endere\u00e7os espec\u00edficos da mem\u00f3ria RAM: endere\u00e7o label / nome 0 SP 1 LCL 2 ARG 3 THIS 4 THAT Example Vamos fazer um exemplo que l\u00ea um dado na RAM[3] o incrementa e salva novamente no mesmo endere\u00e7o de mem\u00f3ria: c\u00f3digo leaw $ 3 , % A ; faz %A = 3 (%A aponta para RAM[3]) movw ( % A ), % D ; move o valor de RAM[%A] para %D incw % D ; incrementa o valor de D (D = D + 1, D = RAM[3] + 1) movw % D , ( % A ) ; move o valor incrementado de volta para a RAM[3] Podemos tamb\u00e9m usar o label ARG para referencia o endere\u00e7o 3 da mem\u00f3ria RAM: leaw $ ARG , % A ; faz %A = 3 (%A aponta para RAM[ARG]) simulador hardware Tip Execute voc\u00ea esse c\u00f3digo no simulador! E analise o resultado. Warning \u00c9 necess\u00e1rio notar que a mem\u00f3ria RAM n\u00e3o \u00e9 um registrador e possui uma grande limita\u00e7\u00e3o , n\u00e3o podemos realizar uma a\u00e7\u00e3o de ESCRITA E LEITURA no mesmo ciclo! O que impossibilita de fazermos o seguinte: leaw $ 3 , % A incw ( % A ) ; N\u00e3o funciona no nosso hardware!! addw ( % A ), % D , ( % A ) ; Nao funciona no nosso hardware!! O assembly permite que voc\u00eas escrevam essas opera\u00e7\u00f5es, por\u00e9m quando forem executar no hardware o resultado n\u00e3o vai ser o esperado.","title":"RAM"},{"location":"Teoria-Z01-mapadeMemoria/#leds","text":"Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 21184 LED w Os LEDs da FPGA s\u00e3o mapeados no endere\u00e7o de mem\u00f3ria 21184 onde cada bit (9..0) representa um LED, se o bit espec\u00edfico estiver valor 1 o LED est\u00e1 aceso e 0 apagado. Example Como isso \u00e9 traduzido para c\u00f3digo? Imagine que desejamos acender um LED que nosso computador controla, para isso devemos fazer com que o registrador %A aponte para o endere\u00e7o de mem\u00f3ria na qual o LED est\u00e1 associado e ent\u00e3o escreva nele: c\u00f3digo leaw $ 21184 , % A ; endere\u00e7o do LED movw $ 1 , ( % A ) ; move valor 1 para ele simulador Tip Execute voc\u00ea esse c\u00f3digo no simulador! Tip Note que usamos movw $1, (%A) , nossa ULA \u00e9 capaz de gerar os valores 1 , -1 e 0 , mas outros valores n\u00e3o!","title":"LEDs"},{"location":"Teoria-Z01-mapadeMemoria/#sw","text":"Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 21185 SW r Os chaves (SW) da FPGA s\u00e3o mapeados no endere\u00e7o de mem\u00f3ria 21185 onde cada bit (9..0) representa uma chave, se o bit espec\u00edfico estiver valor 1 indica que a chave est\u00e1 ligada (on) e 0 desligada. Example O exemplo a seguir copia o valor das chaves para os LEDs: c\u00f3digo leaw $ 21185 , % A ; endere\u00e7o da chave movw ( % A ), % D ; copia valor das chaves para %D leaw $ 21184 , % A ; endere\u00e7o do LED movw % D , ( % A ) ; move valor das chaves para %D simulador Tip Execute voc\u00ea esse c\u00f3digo no simulador!","title":"SW"},{"location":"Teoria-Z01-mapadeMemoria/#lcd","text":"Endere\u00e7o Perif\u00e9rico Leitura ( r ) / Escrita ( w ) 16384 - 21183 LCD w O nosso LCD \u00e9 um dispositivo de 320x240 pixels. Cada linha do endere\u00e7o de mem\u00f3ria do LCD representa 16 pixels do dispositivo, conforme figura anterior. Para acender um pixel, basta colocar 1 ou 0 para apagar.- endere\u00e7os do LCD Como nosso LCD possui 320px na horizontal, e como cada endere\u00e7o de mem\u00f3ria acessa 16px por vez, uma linha \u00e9 acess\u00edvel por: 320/16 = 20 endere\u00e7os. Ou seja, para acessar os primeiros px de cada linha devemos escrever endere\u00e7o de mem\u00f3ria: Primeira linha: 16384 + 0 vezes 20 : 16384 Segunda linha: 16384 + 1 vezes 20 : 16404 Terceira linha: 16384 + 2 vezes 20 : 16424 ... \u00daltima linha: 16384 + 239 vezes 20 : 21164 LCD Vamos desenhar px no meio do LCD que, para isso precisamos carregar o valor 0x 0001 no endere\u00e7o 18242 leaw $ 18242 , % A movw $ 1 , ( % A ) Tip Execute voc\u00ea esse c\u00f3digo no simulador!","title":"LCD"},{"location":"Teoria-Z01/","text":"Z01 \u00b6 2020-2 Material atualizado. Nosso computador ao final das entregas de hardware (mais uma \u00fanica entrega!) possuir\u00e1 a estrutura a seguir: No centro, a unidade central de processamento - CPU ( Central processing unit) que \u00e9 respons\u00e1vel por realizar todas as opera\u00e7\u00f5es do computador (processamento, mover dados, decis\u00f5es, ...). A mem\u00f3ria **ROM* \u00e9 onde o programa a ser executado pela CPU est\u00e1 armazenado. A mem\u00f3ria RAM \u00e9 onde a CPU pode armazenar dados e tamb\u00e9m \u00e9 na RAM que temos os perif\u00e9rico do computador mapeado em mem\u00f3ria. Notem que a CPU \u00e9 respons\u00e1vel por gerar os sinais de controle tanto da ROM quanto da mem\u00f3ria RAM. Um dos sinais que a CPU gera \u00e9 chamado de Program Counter - PC , esse sinal \u00e9 conectado ao address da mem\u00f3ria ROM: O PC indica qual instru\u00e7\u00e3o a CPU ir\u00e1 buscar ( fetch ) na mem\u00f3ria para poder executar, o PC \u00e9 normalmente sequ\u00eancia se o c\u00f3digo n\u00e3o possui nenhuma condi\u00e7\u00e3o, a condi\u00e7\u00e3o faz com que o PC mude o valor atual dele para um novo valor, mas no pr\u00f3ximo clock continua a contagem a partir desse valor. A CPU acessa a mem\u00f3ria RAM com 4 sinais: addressM : Indica qual endere\u00e7o da mem\u00f3ria RAM a CPU est\u00e1 acessando outM : A informa\u00e7\u00e3o que a CPU deseja 'escrever' na RAM writeM : Se a CPU quer escrever ( writeM=1 ) ou ler ( writeM=0 ) da RAM inM : Caso a CPU leia da mem\u00f3ria RAM, a informa\u00e7\u00e3o \u00e9 transmitida por esse sinal! CPU \u00b6 A nossa CPU (proposta originalmente no livro texto), possui internamente dois registradores %A e %D de *16*bits cada, uma ULA, um Program Counter e um Control Unit :","title":"Z01"},{"location":"Teoria-Z01/#z01","text":"2020-2 Material atualizado. Nosso computador ao final das entregas de hardware (mais uma \u00fanica entrega!) possuir\u00e1 a estrutura a seguir: No centro, a unidade central de processamento - CPU ( Central processing unit) que \u00e9 respons\u00e1vel por realizar todas as opera\u00e7\u00f5es do computador (processamento, mover dados, decis\u00f5es, ...). A mem\u00f3ria **ROM* \u00e9 onde o programa a ser executado pela CPU est\u00e1 armazenado. A mem\u00f3ria RAM \u00e9 onde a CPU pode armazenar dados e tamb\u00e9m \u00e9 na RAM que temos os perif\u00e9rico do computador mapeado em mem\u00f3ria. Notem que a CPU \u00e9 respons\u00e1vel por gerar os sinais de controle tanto da ROM quanto da mem\u00f3ria RAM. Um dos sinais que a CPU gera \u00e9 chamado de Program Counter - PC , esse sinal \u00e9 conectado ao address da mem\u00f3ria ROM: O PC indica qual instru\u00e7\u00e3o a CPU ir\u00e1 buscar ( fetch ) na mem\u00f3ria para poder executar, o PC \u00e9 normalmente sequ\u00eancia se o c\u00f3digo n\u00e3o possui nenhuma condi\u00e7\u00e3o, a condi\u00e7\u00e3o faz com que o PC mude o valor atual dele para um novo valor, mas no pr\u00f3ximo clock continua a contagem a partir desse valor. A CPU acessa a mem\u00f3ria RAM com 4 sinais: addressM : Indica qual endere\u00e7o da mem\u00f3ria RAM a CPU est\u00e1 acessando outM : A informa\u00e7\u00e3o que a CPU deseja 'escrever' na RAM writeM : Se a CPU quer escrever ( writeM=1 ) ou ler ( writeM=0 ) da RAM inM : Caso a CPU leia da mem\u00f3ria RAM, a informa\u00e7\u00e3o \u00e9 transmitida por esse sinal!","title":"Z01"},{"location":"Teoria-Z01/#cpu","text":"A nossa CPU (proposta originalmente no livro texto), possui internamente dois registradores %A e %D de *16*bits cada, uma ULA, um Program Counter e um Control Unit :","title":"CPU"},{"location":"Teoria-memoria/","text":"","title":"Teoria memoria"},{"location":"Teoria-multimidia/","text":"V\u00eddeos \u00b6 \u00c1lgebra Booleana \u00b6 Exerc\u00edcios \u00b6 v\u00eddeos \u00b6 Quiz \u00b6 L\u00f3gica booleana - Tabela Verdade Responda sobre tabela verdade \u00c9 correto afirmar sobre a tabela verdade: (pode existir mais de um item correto) Considerando um circuito de 4 entradas (A,B, C, D) quantas s\u00e3o as linhas da tabela verdade? \ufeffQual tabela verdade a seguir foi montada correta? Considerando a equa\u00e7\u00e3o: X = not(B) + A , e a tabela verdade da imagem, qual resposta est\u00e1 correta (na sequ\u00eancia da tabela)? Resposta na sequ\u00eancia: X0; X1; X2; X3 \ufeffL\u00f3gica booleana 1 Quest\u00f5es b\u00e1sicas O que \u00e9 correto afirmar sobre bits? 1 AND 0 Se aplicarmos as entradas 1 e 0 a porta, a sa\u00edda ser\u00e1: 1 OR 0 Se aplicarmos as entradas 1 e 0 a porta, a sa\u00edda ser\u00e1:","title":"V\u00eddeos"},{"location":"Teoria-multimidia/#videos","text":"","title":"V\u00eddeos"},{"location":"Teoria-multimidia/#algebra-booleana","text":"","title":"\u00c1lgebra Booleana"},{"location":"Teoria-multimidia/#exercicios","text":"","title":"Exerc\u00edcios"},{"location":"Teoria-multimidia/#videos_1","text":"","title":"v\u00eddeos"},{"location":"Teoria-multimidia/#quiz","text":"","title":"Quiz"},{"location":"Teoria-nasm-jump/","text":"ASM - jump \u00b6 Saltos (jumps) s\u00e3o instru\u00e7\u00f5es em assembly que permitem a execu\u00e7\u00e3o n\u00e3o sequ\u00eancial de um programa. As instru\u00e7\u00f5es de jumpo quando executadas alteram o program counter. Nossa CPU \u00e9 capaz de realizar c\u00f3digos com condi\u00e7\u00e3o, tal como: if a > 0 : b = 2 else : b = 3 ou: while True : b = b + 1 A maneira de realizarmos esse tipo de condi\u00e7\u00e3o \u00e9 com instru\u00e7\u00f5es de salto ( jump ), uma instru\u00e7\u00e3o de salto verifica uma determinada condi\u00e7\u00e3o e realiza ou n\u00e3o o salto com base nessa condi\u00e7\u00e3o, alterando o PC. A sequ\u00eancia de execu\u00e7\u00e3o do c\u00f3digo \u00e9 ditada pelo Program Counter (PC), um salto acontece quando o PC sofre uma mudan\u00e7a da sua sequ\u00eancia natural: | salto v PC: 0 1 2 3 4 8 9 10 11 --------------------------------> tempo Essa mudan\u00e7a pode ser tanto para 'frente' quanto para tr\u00e1s: | salto v PC: 0 1 2 3 4 0 1 2 3 4 x --------------------------------> tempo Salto O salto \u00e9 uma interrup\u00e7\u00e3o no fluxo cont\u00ednuo e sequencial de um programa. O salto pode ser condicional (if, ...) ou incondicional (salta sem condi\u00e7\u00e3o). PC \u00b6 Para executarmos um salto \u00e9 necess\u00e1rio alterarmos o valor do PC, no Z01 isso \u00e9 feito utilizando o valor que est\u00e1 salvo no registrador %A . No nosso caso, antes de realizarmos um salto \u00e9 necess\u00e1rio carregarmos em %A o endere\u00e7o da qual desejamos ir caso o salto se realize (condi\u00e7\u00e3o). O exemplo a seguir realiza um loop infinito (e n\u00e3o faz nada), ele trava nesse loop: c\u00f3digo 0: leaw $ 0 , % A ; carrega 0 em %A (linha 0) 1: jmp ; faz o salto incondicional 2: nop ; nop simulador O PC desse c\u00f3digo fica: | | | | v v v v 0 1 2 0 1 2 0 1 2 0 1 2 Note que o PC \u00e9 incrementado para o valor 2 mesmo ap\u00f3s a realiza\u00e7\u00e3o do salto ( jmp ), isso ocorre por um atraso no processamento do salto, \u00e9 por esse motivo que um salto (de qualquer tipo) deve ser sempre acompanhado de uma instru\u00e7\u00e3o do tipo nop , o nop \u00e9 uma instru\u00e7\u00e3o que n\u00e3o realizada nada na CPU, ela \u00e9 usada para 'dar' tempo a CPU executar o salto. jmp \u00e9 o comando em assembly de salto incondicional. Note Repare que realizamos o comando leaw $0, %A antes de realizarmos o salto, isso \u00e9 necess\u00e1rio pois o valor carregado em PC \u00e9 o valor de %A . nop \u00b6 No exemplo anterior logo ap\u00f3s o salto jmp aparece a instru\u00e7\u00e3o nop . O No Operation ( nop ) \u00e9 uma instru\u00e7\u00e3o que n\u00e3o faz nada na CPU, n\u00e3o modifica registradores e n\u00e3o modifica mem\u00f3ria. Ela serve para 'dar' tempo a CPU para realizar o salto. Como o salto \u00e9 algo que quebra o fluxo cont\u00ednuo de execu\u00e7\u00e3o do c\u00f3digo (chamamos isso de pipeline), \u00e9 necess\u00e1rio colocarmos essa instru\u00e7\u00e3o para que a CPU se organize internamente para realizar a nova sequ\u00eancia de instru\u00e7\u00f5es. Imaginem que um modelo de carros espec\u00edfico est\u00e1 sendo fabricado em uma linha de produ\u00e7\u00e3o, toda a linha (pipeline) est\u00e1 preparada para montar esse tipo de carro (ferramentas, desenhos t\u00e9cnicos, ...) e a fabrica decide por fabricar um carro de modelo diferente (quebra no pipeline). Duas s\u00e3o as alternativas: desligar toda a linha de produ\u00e7\u00e3o para o pessoal se adequar ou deixar a linha em andamento, mas n\u00e3o colocar nenhum carro nela e dar tempo das pessoas se adequarem. A op\u00e7\u00e3o de desligar a linha \u00e9 uma analogia a 'desligarmos' o clock de parte da CPU, que \u00e9 algo mais complexo. A segunda op\u00e7\u00e3o \u00e9 a de colocar opera\u00e7\u00f5es que n\u00e3o fazem nada na CPU dando assim tempo de ajuste interno ( nop ). Salto incondicional \u00b6 O salto mais simples que podemos realizar \u00e9 o salto sem condi\u00e7\u00f5es. Ou seja, chegou nessa instru\u00e7\u00e3o, salta. Isso \u00e9 muito utilizado para realizarmos while(True) , possuimos apenas uma instru\u00e7\u00e3o que realiza o salto incodicional: jmp Warning Antes de realizarmos qualquer salto \u00e9 necess\u00e1rio carregarmos em %A o destino para onde desejamos ir. label \u00b6 Para facilitar o uso de saltos, podemos criar labels no nosso c\u00f3digo assembly, o label \u00e9 um nome que damos para a linha que desejamos saltar. Label e uma string seguida de : : LABEL: O c\u00f3digo anterior ficaria o seguinte com uso de label: c\u00f3digo LOOP: ; label LOOP leaw $ LOOP , % A ; Aqui, $LOOP seria substituido por 0 pelo montador jmp nop simulador Note O label n\u00e3o \u00e9 uma instru\u00e7\u00e3o, \u00e9 um nome para a linha em quest\u00e3o e portanto n\u00e3o \u00e9 convertido para nenhuma opera\u00e7\u00e3o de hardware. Tip Teste o c\u00f3digo anterior no Z01-Simulator . Salto condicional \u00b6 O salto condicional \u00e9 aquele que \u00e9 utilizado para realizarmos if ... else , nele um salto s\u00f3 \u00e9 executado caso uma condi\u00e7\u00e3o espec\u00edfica seja satisfeita. Nossa CPU \u00e9 capaz de realizar a seguintes condi\u00e7\u00f5es: je %D : Salta se valor de %D \u00e9 igual a 0 jne %D : Salta se valor de %D for diferente de 0 jg %D : Salta se valor de %D for maior que 0 jl %D : Salta se valor de %D for menor que 0 jge %D : Salta se valor de %D for maior ou igual a 0 jle %D : Salta se valor de %D for menor ou igual a 0 %D indica o valor salvo no registrador D. Example considere o pseudo c\u00f3digo a seguir: if RAM [ 1 ] > 0 : RAM [ 2 ] = 1 else : RAM [ 2 ] = 2 nasm Em assembly do Z01: leaw $ 1 , % A ; faz %A apontar para RAM[1] movw ( % A ), % D ; carrega o valor de RAM[1] em %D leaw $ ELSE , % A ; precisamos carregar em %A o valor do salto jle % D ; salta se valor em %D for menor ou igual a zero nop ; ; if leaw $ 2 , % A ; movw $ 1 , ( % A ) ; ; leaw $ END , % A ; agora n\u00e3o podemos executar o trecho jmp ; do else, vamos pular para o fim nop ; do c\u00f3digo ; ELSE: ; else ; leaw $ 2 , % A ; movw % A , ( % A ) ; ; END: ; simulador RAM[1] = 0 Warning As labels precisam estar escritas da mesma maneira, altere ea linha 9 para leaw $end, $A ou a linha 15 para END: Tip Teste o c\u00f3digo anterior no Z01-Simulator . Hardware \u00b6 O salto condicional utiliza o comparador que est\u00e1 dentro da nossa ULA para verificar a condi\u00e7\u00e3o e realizar o salto, as etapas s\u00e3o: O Control Unit faz com que o valor do registrador %D passe pela ULA Quando %D sai pela ULA o Comparador gera os sinais ng : menor que zero zr : igual a zero Esses sinais v\u00e3o at\u00e9 o Control Unit O control Unit verifica a condi\u00e7\u00e3o do salto e os valores de ng e zr , se forem condizentes, faz load_PC <= '1' caso contr\u00e1rio, n\u00e3o salta load_pc <= '0' .","title":"ASM - jump"},{"location":"Teoria-nasm-jump/#asm-jump","text":"Saltos (jumps) s\u00e3o instru\u00e7\u00f5es em assembly que permitem a execu\u00e7\u00e3o n\u00e3o sequ\u00eancial de um programa. As instru\u00e7\u00f5es de jumpo quando executadas alteram o program counter. Nossa CPU \u00e9 capaz de realizar c\u00f3digos com condi\u00e7\u00e3o, tal como: if a > 0 : b = 2 else : b = 3 ou: while True : b = b + 1 A maneira de realizarmos esse tipo de condi\u00e7\u00e3o \u00e9 com instru\u00e7\u00f5es de salto ( jump ), uma instru\u00e7\u00e3o de salto verifica uma determinada condi\u00e7\u00e3o e realiza ou n\u00e3o o salto com base nessa condi\u00e7\u00e3o, alterando o PC. A sequ\u00eancia de execu\u00e7\u00e3o do c\u00f3digo \u00e9 ditada pelo Program Counter (PC), um salto acontece quando o PC sofre uma mudan\u00e7a da sua sequ\u00eancia natural: | salto v PC: 0 1 2 3 4 8 9 10 11 --------------------------------> tempo Essa mudan\u00e7a pode ser tanto para 'frente' quanto para tr\u00e1s: | salto v PC: 0 1 2 3 4 0 1 2 3 4 x --------------------------------> tempo Salto O salto \u00e9 uma interrup\u00e7\u00e3o no fluxo cont\u00ednuo e sequencial de um programa. O salto pode ser condicional (if, ...) ou incondicional (salta sem condi\u00e7\u00e3o).","title":"ASM - jump"},{"location":"Teoria-nasm-jump/#pc","text":"Para executarmos um salto \u00e9 necess\u00e1rio alterarmos o valor do PC, no Z01 isso \u00e9 feito utilizando o valor que est\u00e1 salvo no registrador %A . No nosso caso, antes de realizarmos um salto \u00e9 necess\u00e1rio carregarmos em %A o endere\u00e7o da qual desejamos ir caso o salto se realize (condi\u00e7\u00e3o). O exemplo a seguir realiza um loop infinito (e n\u00e3o faz nada), ele trava nesse loop: c\u00f3digo 0: leaw $ 0 , % A ; carrega 0 em %A (linha 0) 1: jmp ; faz o salto incondicional 2: nop ; nop simulador O PC desse c\u00f3digo fica: | | | | v v v v 0 1 2 0 1 2 0 1 2 0 1 2 Note que o PC \u00e9 incrementado para o valor 2 mesmo ap\u00f3s a realiza\u00e7\u00e3o do salto ( jmp ), isso ocorre por um atraso no processamento do salto, \u00e9 por esse motivo que um salto (de qualquer tipo) deve ser sempre acompanhado de uma instru\u00e7\u00e3o do tipo nop , o nop \u00e9 uma instru\u00e7\u00e3o que n\u00e3o realizada nada na CPU, ela \u00e9 usada para 'dar' tempo a CPU executar o salto. jmp \u00e9 o comando em assembly de salto incondicional. Note Repare que realizamos o comando leaw $0, %A antes de realizarmos o salto, isso \u00e9 necess\u00e1rio pois o valor carregado em PC \u00e9 o valor de %A .","title":"PC"},{"location":"Teoria-nasm-jump/#nop","text":"No exemplo anterior logo ap\u00f3s o salto jmp aparece a instru\u00e7\u00e3o nop . O No Operation ( nop ) \u00e9 uma instru\u00e7\u00e3o que n\u00e3o faz nada na CPU, n\u00e3o modifica registradores e n\u00e3o modifica mem\u00f3ria. Ela serve para 'dar' tempo a CPU para realizar o salto. Como o salto \u00e9 algo que quebra o fluxo cont\u00ednuo de execu\u00e7\u00e3o do c\u00f3digo (chamamos isso de pipeline), \u00e9 necess\u00e1rio colocarmos essa instru\u00e7\u00e3o para que a CPU se organize internamente para realizar a nova sequ\u00eancia de instru\u00e7\u00f5es. Imaginem que um modelo de carros espec\u00edfico est\u00e1 sendo fabricado em uma linha de produ\u00e7\u00e3o, toda a linha (pipeline) est\u00e1 preparada para montar esse tipo de carro (ferramentas, desenhos t\u00e9cnicos, ...) e a fabrica decide por fabricar um carro de modelo diferente (quebra no pipeline). Duas s\u00e3o as alternativas: desligar toda a linha de produ\u00e7\u00e3o para o pessoal se adequar ou deixar a linha em andamento, mas n\u00e3o colocar nenhum carro nela e dar tempo das pessoas se adequarem. A op\u00e7\u00e3o de desligar a linha \u00e9 uma analogia a 'desligarmos' o clock de parte da CPU, que \u00e9 algo mais complexo. A segunda op\u00e7\u00e3o \u00e9 a de colocar opera\u00e7\u00f5es que n\u00e3o fazem nada na CPU dando assim tempo de ajuste interno ( nop ).","title":"nop"},{"location":"Teoria-nasm-jump/#salto-incondicional","text":"O salto mais simples que podemos realizar \u00e9 o salto sem condi\u00e7\u00f5es. Ou seja, chegou nessa instru\u00e7\u00e3o, salta. Isso \u00e9 muito utilizado para realizarmos while(True) , possuimos apenas uma instru\u00e7\u00e3o que realiza o salto incodicional: jmp Warning Antes de realizarmos qualquer salto \u00e9 necess\u00e1rio carregarmos em %A o destino para onde desejamos ir.","title":"Salto incondicional"},{"location":"Teoria-nasm-jump/#label","text":"Para facilitar o uso de saltos, podemos criar labels no nosso c\u00f3digo assembly, o label \u00e9 um nome que damos para a linha que desejamos saltar. Label e uma string seguida de : : LABEL: O c\u00f3digo anterior ficaria o seguinte com uso de label: c\u00f3digo LOOP: ; label LOOP leaw $ LOOP , % A ; Aqui, $LOOP seria substituido por 0 pelo montador jmp nop simulador Note O label n\u00e3o \u00e9 uma instru\u00e7\u00e3o, \u00e9 um nome para a linha em quest\u00e3o e portanto n\u00e3o \u00e9 convertido para nenhuma opera\u00e7\u00e3o de hardware. Tip Teste o c\u00f3digo anterior no Z01-Simulator .","title":"label"},{"location":"Teoria-nasm-jump/#salto-condicional","text":"O salto condicional \u00e9 aquele que \u00e9 utilizado para realizarmos if ... else , nele um salto s\u00f3 \u00e9 executado caso uma condi\u00e7\u00e3o espec\u00edfica seja satisfeita. Nossa CPU \u00e9 capaz de realizar a seguintes condi\u00e7\u00f5es: je %D : Salta se valor de %D \u00e9 igual a 0 jne %D : Salta se valor de %D for diferente de 0 jg %D : Salta se valor de %D for maior que 0 jl %D : Salta se valor de %D for menor que 0 jge %D : Salta se valor de %D for maior ou igual a 0 jle %D : Salta se valor de %D for menor ou igual a 0 %D indica o valor salvo no registrador D. Example considere o pseudo c\u00f3digo a seguir: if RAM [ 1 ] > 0 : RAM [ 2 ] = 1 else : RAM [ 2 ] = 2 nasm Em assembly do Z01: leaw $ 1 , % A ; faz %A apontar para RAM[1] movw ( % A ), % D ; carrega o valor de RAM[1] em %D leaw $ ELSE , % A ; precisamos carregar em %A o valor do salto jle % D ; salta se valor em %D for menor ou igual a zero nop ; ; if leaw $ 2 , % A ; movw $ 1 , ( % A ) ; ; leaw $ END , % A ; agora n\u00e3o podemos executar o trecho jmp ; do else, vamos pular para o fim nop ; do c\u00f3digo ; ELSE: ; else ; leaw $ 2 , % A ; movw % A , ( % A ) ; ; END: ; simulador RAM[1] = 0 Warning As labels precisam estar escritas da mesma maneira, altere ea linha 9 para leaw $end, $A ou a linha 15 para END: Tip Teste o c\u00f3digo anterior no Z01-Simulator .","title":"Salto condicional"},{"location":"Teoria-nasm-jump/#hardware","text":"O salto condicional utiliza o comparador que est\u00e1 dentro da nossa ULA para verificar a condi\u00e7\u00e3o e realizar o salto, as etapas s\u00e3o: O Control Unit faz com que o valor do registrador %D passe pela ULA Quando %D sai pela ULA o Comparador gera os sinais ng : menor que zero zr : igual a zero Esses sinais v\u00e3o at\u00e9 o Control Unit O control Unit verifica a condi\u00e7\u00e3o do salto e os valores de ng e zr , se forem condizentes, faz load_PC <= '1' caso contr\u00e1rio, n\u00e3o salta load_pc <= '0' .","title":"Hardware"},{"location":"Teoria-vm-funcoes/","text":"VM - Fun\u00e7\u00f5es \u00b6 A linguagem VM possibilita o uso de fun\u00e7\u00f5es, as fun\u00e7\u00f5es s\u00e3o definidas em novos arquivos .vm na mesma pasta do arquivo Main.vm. Por exemplo : Na pasta do projeto H-VM/src/vmExamples/SimpleFunction possu\u00edmos duas fun\u00e7\u00f5es: O Main.vm e a SimpleFunction.vm . A fun\u00e7\u00e3o main deve sempre deve existir no projeto, e ser\u00e1 a primeira chamada na inicializa\u00e7\u00e3o do sistema (assim como no python e C). Para definirmos uma fun\u00e7\u00e3o em VM basta criarmos um arquivo com a extens\u00e3o .vm (que precisa ter o mesmo nome da fun\u00e7\u00e3o) que ser\u00e1 como uma classe do nosso projeto, podendo conter mais que um m\u00e9todo/fun\u00e7\u00e3o. Note Olhe o exemplo src/vmExamples/StatiTest/ para ver como isso funciona. Uma fun\u00e7\u00e3o \u00e9 definida pela seguinte estrutura : function functionName numberOfVars Onde : function: \u00e9 uma palavra reservado (keyword) para definir fun\u00e7\u00f5es functionName: \u00e9 o nome da fun\u00e7\u00e3o numberOfVars: a quantidade de vari\u00e1veis locais que essa fun\u00e7\u00e3o possui. Como exemplo, vamos transformar a seguinte fun\u00e7\u00e3o em Python para VM: def SimpleFunction ( a , b ): aux0 = a + b aux1 = a - b return ( aux1 + aux0 ) Em VM: function SimpleFunction 2 push argument 0 push argument 1 add pop local 0 // aux0 = a + b push argument 0 push argument 1 sub pop local 1 // aux1 = a - b push local 0 push local 1 add // aux0 + aux1 return Essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais, que pode ser acessada pelo segmento local , os par\u00e2metros passados para a fun\u00e7\u00e3o (a e b) s\u00e3o acess\u00edveis pelo segmento argument : push argument 0 acessa o primeiro argumento da fun\u00e7\u00e3o ( a ), trazendo o dado para a pilha. push argument 1 acessa o primeiro argumento da fun\u00e7\u00e3o ( b ), trazendo o dado para a pilha. push/pop temp 0 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux0 ). push/pop temp 1 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux1 ). Note que os par\u00e2metros devem ser apenas leitura, n\u00e3o devendo escrever nesses segmentos. return \u00b6 A fun\u00e7\u00e3o considera como retorno o \u00faltimo valor da pilha, e sempre retorna um \u00fanico valor apenas. Chamada de fun\u00e7\u00e3o \u00b6 A chamada de fun\u00e7\u00e3o ocorre na pr\u00f3pria pilha, para isso \u00e9 necess\u00e1rio colocar na pilha os par\u00e2metros da fun\u00e7\u00e3o, no exemplo anterior : a b SP-> e em seguida fazer a chamada de fun\u00e7\u00e3o que possui a seguinte estrutura: call functionName numberOfParameters Onde : call : palavra reservada para chamada de fun\u00e7\u00f5es functioName : nome da fun\u00e7\u00e3o a ser chamada numberOfPar : quantidade de par\u00e2metros que essa fun\u00e7\u00e3o recebe. O exemplo a seguir chama a fun\u00e7\u00e3o SimpleFunction com os valores 5 e 8 como argumentos / par\u00e2metros da fun\u00e7\u00e3o. function Main.main 0 push constant 5 push constant 8 call SimpleFunction 2 Graficamente \u00b6","title":"VM - Fun\u00e7\u00f5es"},{"location":"Teoria-vm-funcoes/#vm-funcoes","text":"A linguagem VM possibilita o uso de fun\u00e7\u00f5es, as fun\u00e7\u00f5es s\u00e3o definidas em novos arquivos .vm na mesma pasta do arquivo Main.vm. Por exemplo : Na pasta do projeto H-VM/src/vmExamples/SimpleFunction possu\u00edmos duas fun\u00e7\u00f5es: O Main.vm e a SimpleFunction.vm . A fun\u00e7\u00e3o main deve sempre deve existir no projeto, e ser\u00e1 a primeira chamada na inicializa\u00e7\u00e3o do sistema (assim como no python e C). Para definirmos uma fun\u00e7\u00e3o em VM basta criarmos um arquivo com a extens\u00e3o .vm (que precisa ter o mesmo nome da fun\u00e7\u00e3o) que ser\u00e1 como uma classe do nosso projeto, podendo conter mais que um m\u00e9todo/fun\u00e7\u00e3o. Note Olhe o exemplo src/vmExamples/StatiTest/ para ver como isso funciona. Uma fun\u00e7\u00e3o \u00e9 definida pela seguinte estrutura : function functionName numberOfVars Onde : function: \u00e9 uma palavra reservado (keyword) para definir fun\u00e7\u00f5es functionName: \u00e9 o nome da fun\u00e7\u00e3o numberOfVars: a quantidade de vari\u00e1veis locais que essa fun\u00e7\u00e3o possui. Como exemplo, vamos transformar a seguinte fun\u00e7\u00e3o em Python para VM: def SimpleFunction ( a , b ): aux0 = a + b aux1 = a - b return ( aux1 + aux0 ) Em VM: function SimpleFunction 2 push argument 0 push argument 1 add pop local 0 // aux0 = a + b push argument 0 push argument 1 sub pop local 1 // aux1 = a - b push local 0 push local 1 add // aux0 + aux1 return Essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais, que pode ser acessada pelo segmento local , os par\u00e2metros passados para a fun\u00e7\u00e3o (a e b) s\u00e3o acess\u00edveis pelo segmento argument : push argument 0 acessa o primeiro argumento da fun\u00e7\u00e3o ( a ), trazendo o dado para a pilha. push argument 1 acessa o primeiro argumento da fun\u00e7\u00e3o ( b ), trazendo o dado para a pilha. push/pop temp 0 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux0 ). push/pop temp 1 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux1 ). Note que os par\u00e2metros devem ser apenas leitura, n\u00e3o devendo escrever nesses segmentos.","title":"VM - Fun\u00e7\u00f5es"},{"location":"Teoria-vm-funcoes/#return","text":"A fun\u00e7\u00e3o considera como retorno o \u00faltimo valor da pilha, e sempre retorna um \u00fanico valor apenas.","title":"return"},{"location":"Teoria-vm-funcoes/#chamada-de-funcao","text":"A chamada de fun\u00e7\u00e3o ocorre na pr\u00f3pria pilha, para isso \u00e9 necess\u00e1rio colocar na pilha os par\u00e2metros da fun\u00e7\u00e3o, no exemplo anterior : a b SP-> e em seguida fazer a chamada de fun\u00e7\u00e3o que possui a seguinte estrutura: call functionName numberOfParameters Onde : call : palavra reservada para chamada de fun\u00e7\u00f5es functioName : nome da fun\u00e7\u00e3o a ser chamada numberOfPar : quantidade de par\u00e2metros que essa fun\u00e7\u00e3o recebe. O exemplo a seguir chama a fun\u00e7\u00e3o SimpleFunction com os valores 5 e 8 como argumentos / par\u00e2metros da fun\u00e7\u00e3o. function Main.main 0 push constant 5 push constant 8 call SimpleFunction 2","title":"Chamada de fun\u00e7\u00e3o"},{"location":"Teoria-vm-funcoes/#graficamente","text":"","title":"Graficamente"},{"location":"Teoria-vm-jump/","text":"VM - jump \u00b6 Goto \u00e9 a maneira de desviarmos uma execu\u00e7\u00e3o em vm, e possui a seguinte sintaxe: goto LABEL if-goto LABEL podemos utilizar dois tipos : goto : incondicional , salta sem condi\u00e7\u00e3o if-goto : condiconal, salta se o \u00faltimo valor da pilha for True Exemplo: Salto para igual se 3 = 2 push constant 3 push constant 2 eq if-goto IGUAL .. .. label IGUAL .. .. Exemplo: Contador utilizando for utilizando goto // for(i=0; i<10; i++) // x = x+1; push constant 0 pop temp 0 push constant 1 pop temp 1 label LOOP_START push temp 0 push constant 10 eq if-goto END // se temp0 = 10 salta para o fim push temp 0 push constant 1 add pop temp 0 push temp 1 push constant 1 add pop temp 1 goto LOOP_START // If counter > 0, goto LOOP_START label END labels \u00b6 Os labels s\u00e3o definidos pela keyword label + nome : label nome","title":"VM - jump"},{"location":"Teoria-vm-jump/#vm-jump","text":"Goto \u00e9 a maneira de desviarmos uma execu\u00e7\u00e3o em vm, e possui a seguinte sintaxe: goto LABEL if-goto LABEL podemos utilizar dois tipos : goto : incondicional , salta sem condi\u00e7\u00e3o if-goto : condiconal, salta se o \u00faltimo valor da pilha for True Exemplo: Salto para igual se 3 = 2 push constant 3 push constant 2 eq if-goto IGUAL .. .. label IGUAL .. .. Exemplo: Contador utilizando for utilizando goto // for(i=0; i<10; i++) // x = x+1; push constant 0 pop temp 0 push constant 1 pop temp 1 label LOOP_START push temp 0 push constant 10 eq if-goto END // se temp0 = 10 salta para o fim push temp 0 push constant 1 add pop temp 0 push temp 1 push constant 1 add pop temp 1 goto LOOP_START // If counter > 0, goto LOOP_START label END","title":"VM - jump"},{"location":"Teoria-vm-jump/#labels","text":"Os labels s\u00e3o definidos pela keyword label + nome : label nome","title":"labels"},{"location":"Teoria-vm-memoria/","text":"VM - Mem\u00f3ria \u00b6 Para a m\u00e1quina virtual funcionar corretamente devemos agora definir regi\u00f5es de mem\u00f3ria que serviram para aplica\u00e7\u00f5es espec\u00edficas, tal como armazenar: o topo da pilha ( SP , Stack Pointer), os locais dos par\u00e2metros passados na chamada de fun\u00e7\u00e3o ( ARG , argument), os endere\u00e7os das vari\u00e1veis locais de uma fun\u00e7\u00e3o ( LCL , local) ... A seguir um resumo dos endere\u00e7os de mem\u00f3ria e suas fun\u00e7\u00f5es: Endere\u00e7o (RAM) S\u00edmbolo Nome Uso 0 SP Stack Pointer Ponteiro para o topo da pilha 1 LCL Local Ponteiro para a base das vari\u00e1veis de um fun\u00e7\u00e3o 2 ARG Argument Ponteiro para a base dos argumentos de uma fun\u00e7\u00e3o 3 THIS This Ponteiro para a base do segmento this 4 THAT That Ponteiro para a base do segmento that 5..12 Temp Temporary Endere\u00e7os para armazenar vari\u00e1veis tempor\u00e1rias Al\u00e9m dos endere\u00e7os espec\u00edficos (que possuem pap\u00e9is especiais), devemos tamb\u00e9m definir regi\u00f5es da mem\u00f3ria que ser\u00e3o utilizadas para armazenar tipos de dados espec\u00edficos, s\u00e3o essas : Endere\u00e7o (RAM) Nome Uso 16-255 Static Vari\u00e1veis est\u00e1ticas (acess\u00edveis por todas as fun\u00e7\u00f5es) 256-2047 Stack Pilha utilizada pela VM (stack pointer) 2048-16383 Heap Usada para armazenar objetos e vetores 16384- I/O Perif\u00e9ricos mapeados em mem\u00f3ria Vamos detalhar um pouco de cada item descrito nesse resumo. Stack \u00b6 A stack \u00e9 a regi\u00e3o de mem\u00f3ria utilizada pela VM para armazenar valores e realizar opera\u00e7\u00f5es, funciona como uma forma de abstra\u00e7\u00e3o do hardware, j\u00e1 que agora toda manipula\u00e7\u00e3o de dados acontece na Stack e n\u00e3o mais nos registradores. \u00c9 claro que essa manipula\u00e7\u00e3o influ\u00eancia nos registradores do hardware, mas o programador n\u00e3o mais precisa ter todo o conhecimento do hardware nas opera\u00e7\u00f5es. Por exemplo a opera\u00e7\u00e3o : push constant 5 push constant 3 add Adiciona o valor 5 e o 3 para o topo da pilha e os soma, resultando em um \u00fanico valor : 8. Notem que para essa opera\u00e7\u00e3o ser realizada no hardware do Z01 tivemos que usar os registradores para tornar a opera\u00e7\u00e3o vi\u00e1vel, por\u00e9m isso n\u00e3o \u00e9 mais vis\u00edvel do programa VM. Nesse camada de software n\u00e3o interessa mais se o hardware possui 2, 3, ... N registradores o resultado da opera\u00e7\u00e3o ser\u00e1 a mesma. Teremos 8 no topo da pilha. O hardware vai influenciar o VMTranslator que deve traduzir a linguagem de m\u00e1quina virtual por pilha para a linguagem Assembly, o n\u00famero de registradores pode influenciar a performance do computador mas n\u00e3o ir\u00e1 mudar o conceito de pilha. A stack \u00e9 utilizada tamb\u00e9m para armazenar os valores passados na chamada de fun\u00e7\u00e3o e tamb\u00e9m para armazenar o resultado (return) de uma fun\u00e7\u00e3o. Stack Pointer \u00b6 \u00c9 um ponteiro que indica a onde est\u00e1 o endere\u00e7o do topo da pilha, como a pilha cresce e diminui dinamicamente (conforme os push, pops e opera\u00e7\u00f5es) necessitamos armazenar em algum local o endere\u00e7o do topo da pilha, conforme figura a seguir : Stack Overflow Agora fica mais claro o significado do site stack overflow ? Indica o estouro da pilha. Imagine a situa\u00e7\u00e3o na qual s\u00f3 colocamos dados na pilha e nunca tiramos ( pop , em algum momento a pilha ir\u00e1 passar seu valor m\u00e1ximo, que no nosso caso \u00e9 : 2047 - 256 = 1791 endere\u00e7os e come\u00e7ar\u00e1 a escrever na regi\u00e3o reservada para o Heap, corrompendo os dados que estavam ali salvos). Fun\u00e7\u00f5es \u00b6 Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, o ARG indica o endere\u00e7o da stack na qual os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 indicado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9: Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar os locals Atualiza os ponteiros : SP, LCL, ARG O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o), isto \u00e9 conhecido como salvar contexto (antes da execu\u00e7\u00e3o da fun\u00e7\u00e3o) e restaurar contexto (ap\u00f3s da execu\u00e7\u00e3o da fun\u00e7\u00e3o). Para isso \u00e9 salvo na pilha: Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o) LCL - Local \u00b6 Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Veja como fica um exemplo em Java : void example ( int a , int b ){ int aux0 ; int aux1 ; aux0 = a ; aux1 = b ; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais : aux0, aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis (aux0, aux1) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir: O exemplo em Java anteriormente seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira : function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n Tip Endere\u00e7o local n = LCL + n ARG - Argumento \u00b6 O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Tip Endere\u00e7o argument n = ARG + n Static variables \u00b6 \u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static : O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } Note As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/ HEAP \u00b6 O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria. This \u00b6 This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm That \u00b6 O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir: M\u00e9todo objeto Celeste: void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal: void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, incluimos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chamada da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"VM - Mem\u00f3ria"},{"location":"Teoria-vm-memoria/#vm-memoria","text":"Para a m\u00e1quina virtual funcionar corretamente devemos agora definir regi\u00f5es de mem\u00f3ria que serviram para aplica\u00e7\u00f5es espec\u00edficas, tal como armazenar: o topo da pilha ( SP , Stack Pointer), os locais dos par\u00e2metros passados na chamada de fun\u00e7\u00e3o ( ARG , argument), os endere\u00e7os das vari\u00e1veis locais de uma fun\u00e7\u00e3o ( LCL , local) ... A seguir um resumo dos endere\u00e7os de mem\u00f3ria e suas fun\u00e7\u00f5es: Endere\u00e7o (RAM) S\u00edmbolo Nome Uso 0 SP Stack Pointer Ponteiro para o topo da pilha 1 LCL Local Ponteiro para a base das vari\u00e1veis de um fun\u00e7\u00e3o 2 ARG Argument Ponteiro para a base dos argumentos de uma fun\u00e7\u00e3o 3 THIS This Ponteiro para a base do segmento this 4 THAT That Ponteiro para a base do segmento that 5..12 Temp Temporary Endere\u00e7os para armazenar vari\u00e1veis tempor\u00e1rias Al\u00e9m dos endere\u00e7os espec\u00edficos (que possuem pap\u00e9is especiais), devemos tamb\u00e9m definir regi\u00f5es da mem\u00f3ria que ser\u00e3o utilizadas para armazenar tipos de dados espec\u00edficos, s\u00e3o essas : Endere\u00e7o (RAM) Nome Uso 16-255 Static Vari\u00e1veis est\u00e1ticas (acess\u00edveis por todas as fun\u00e7\u00f5es) 256-2047 Stack Pilha utilizada pela VM (stack pointer) 2048-16383 Heap Usada para armazenar objetos e vetores 16384- I/O Perif\u00e9ricos mapeados em mem\u00f3ria Vamos detalhar um pouco de cada item descrito nesse resumo.","title":"VM - Mem\u00f3ria"},{"location":"Teoria-vm-memoria/#stack","text":"A stack \u00e9 a regi\u00e3o de mem\u00f3ria utilizada pela VM para armazenar valores e realizar opera\u00e7\u00f5es, funciona como uma forma de abstra\u00e7\u00e3o do hardware, j\u00e1 que agora toda manipula\u00e7\u00e3o de dados acontece na Stack e n\u00e3o mais nos registradores. \u00c9 claro que essa manipula\u00e7\u00e3o influ\u00eancia nos registradores do hardware, mas o programador n\u00e3o mais precisa ter todo o conhecimento do hardware nas opera\u00e7\u00f5es. Por exemplo a opera\u00e7\u00e3o : push constant 5 push constant 3 add Adiciona o valor 5 e o 3 para o topo da pilha e os soma, resultando em um \u00fanico valor : 8. Notem que para essa opera\u00e7\u00e3o ser realizada no hardware do Z01 tivemos que usar os registradores para tornar a opera\u00e7\u00e3o vi\u00e1vel, por\u00e9m isso n\u00e3o \u00e9 mais vis\u00edvel do programa VM. Nesse camada de software n\u00e3o interessa mais se o hardware possui 2, 3, ... N registradores o resultado da opera\u00e7\u00e3o ser\u00e1 a mesma. Teremos 8 no topo da pilha. O hardware vai influenciar o VMTranslator que deve traduzir a linguagem de m\u00e1quina virtual por pilha para a linguagem Assembly, o n\u00famero de registradores pode influenciar a performance do computador mas n\u00e3o ir\u00e1 mudar o conceito de pilha. A stack \u00e9 utilizada tamb\u00e9m para armazenar os valores passados na chamada de fun\u00e7\u00e3o e tamb\u00e9m para armazenar o resultado (return) de uma fun\u00e7\u00e3o.","title":"Stack"},{"location":"Teoria-vm-memoria/#stack-pointer","text":"\u00c9 um ponteiro que indica a onde est\u00e1 o endere\u00e7o do topo da pilha, como a pilha cresce e diminui dinamicamente (conforme os push, pops e opera\u00e7\u00f5es) necessitamos armazenar em algum local o endere\u00e7o do topo da pilha, conforme figura a seguir : Stack Overflow Agora fica mais claro o significado do site stack overflow ? Indica o estouro da pilha. Imagine a situa\u00e7\u00e3o na qual s\u00f3 colocamos dados na pilha e nunca tiramos ( pop , em algum momento a pilha ir\u00e1 passar seu valor m\u00e1ximo, que no nosso caso \u00e9 : 2047 - 256 = 1791 endere\u00e7os e come\u00e7ar\u00e1 a escrever na regi\u00e3o reservada para o Heap, corrompendo os dados que estavam ali salvos).","title":"Stack Pointer"},{"location":"Teoria-vm-memoria/#funcoes","text":"Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, o ARG indica o endere\u00e7o da stack na qual os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 indicado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9: Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar os locals Atualiza os ponteiros : SP, LCL, ARG O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o), isto \u00e9 conhecido como salvar contexto (antes da execu\u00e7\u00e3o da fun\u00e7\u00e3o) e restaurar contexto (ap\u00f3s da execu\u00e7\u00e3o da fun\u00e7\u00e3o). Para isso \u00e9 salvo na pilha: Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o)","title":"Fun\u00e7\u00f5es"},{"location":"Teoria-vm-memoria/#lcl-local","text":"Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Veja como fica um exemplo em Java : void example ( int a , int b ){ int aux0 ; int aux1 ; aux0 = a ; aux1 = b ; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais : aux0, aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis (aux0, aux1) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir: O exemplo em Java anteriormente seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira : function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n Tip Endere\u00e7o local n = LCL + n","title":"LCL - Local"},{"location":"Teoria-vm-memoria/#arg-argumento","text":"O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Tip Endere\u00e7o argument n = ARG + n","title":"ARG - Argumento"},{"location":"Teoria-vm-memoria/#static-variables","text":"\u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static : O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } Note As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/","title":"Static variables"},{"location":"Teoria-vm-memoria/#heap","text":"O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria.","title":"HEAP"},{"location":"Teoria-vm-memoria/#this","text":"This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm","title":"This"},{"location":"Teoria-vm-memoria/#that","text":"O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir: M\u00e9todo objeto Celeste: void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal: void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, incluimos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chamada da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"That"},{"location":"Teoria-vm-segmentos/","text":"VM - Segmentos \u00b6 Os comandos push e pop s\u00e3o a \u00fanica maneira que temos de acessar/manipular a mem\u00f3ria. O comando push traz para a pilha um valor da mem\u00f3ria (RAM ou ROM) e o comando pop salva na mem\u00f3ria um valor da pilha (RAM). Os comandos possuem a seguinte sintaxe : push segment index pop segment index Onde index \u00e9 um n\u00famero inteiro positivo e segment pode ser um dos casos a seguir: segment Uso Index Coment\u00e1rio argument Local onde o argumento da fun\u00e7\u00e3o est\u00e1 salvo 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada local Local das vari\u00e1veis locais da fun\u00e7\u00e3o 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada static Local onde as vari\u00e1veis do objeto est\u00e3o salvos 0 .. Essas vari\u00e1veis s\u00e3o compartilhadas por todas as fun\u00e7\u00f5es do mesmo .vm, assim como em um objeto constant Carrega uma constante na pilha 0 .. 32767 Mesmo uso do leaw (carrega da ROM um valor na RAM) this/that Segmentos de uso geral, pode apontar para qualquer lugar 0 .. Usado para ler e escrever de endere\u00e7os da mem\u00f3ria, por exemplo, acessar o LCD pointer Altera os valores do this e do that 0, 1 Usado para modificar a onde o this e o that apontam temp Local para uso de vari\u00e1veis tempor\u00e1rias 0 .. 7 Acessado por qualquer fun\u00e7\u00e3o, \u00e9 armazenado nos endere\u00e7os R5 .. R12 da RAM Exemplo, acessando o temp \u00b6 Por exemplo, para trazermos para a pilha uma constante realizamos a seguinte opera\u00e7\u00e3o: push constant 15 nesse caso o segmento acessado \u00e9 o constant e o par\u00e2metro \u00e9 o 15. Para salvarmos o valor 15 no temp 3 (endere\u00e7o da RAM 7), basta: push constant 15 pop temp 3 Podemos tamb\u00e9m trazer o temp 3 para a pilha: push temp 3 Escrevendo um pixel no LCD \u00b6 Para atualizarmos o LCD via VM ser\u00e1 necess\u00e1rio primeiro atualizarmos para onde o that aponta, that \u00e9 a maneira que possu\u00edmos de escrever em qualquer endere\u00e7o da mem\u00f3ria. O exemplo a seguir ilustra como usamos o segmento that para escrever nos pixels centrais do LCD, supondo que gostar\u00edamos de realizar a seguinte opera\u00e7\u00e3o em C. int * pLCD = 16384 * ( pLCD + 1200 ) = 0xFFFF Nesse pequeno c\u00f3digo em C o que est\u00e1 acontecendo \u00e9 que primeiramente definimos um ponteiro pLCD que aponta para 16384, depois fazemos com que o endere\u00e7o desse ponteiro + 1200 receba 0xFFFF, o mesmo c\u00f3digo em VM \u00e9 realizado da seguinte maneira : push constant 16384 -- carrega 16384 para a pilha pop pointer 1 -- atualiza para onde that aponta (int *pLCD = 16384) push contant 1 -- carrega 1 para a pilha neg -- nega o 1 para obter o valor 0xFFFF -- poderia ter realizado o push contant 4095 no lugar -- dessas duas opera\u00e7\u00f5es pop that 1200 -- faz com que o endere\u00e7o da mem\u00f3ria 16384 + 1200 = 0xFFFF","title":"VM - Segmentos"},{"location":"Teoria-vm-segmentos/#vm-segmentos","text":"Os comandos push e pop s\u00e3o a \u00fanica maneira que temos de acessar/manipular a mem\u00f3ria. O comando push traz para a pilha um valor da mem\u00f3ria (RAM ou ROM) e o comando pop salva na mem\u00f3ria um valor da pilha (RAM). Os comandos possuem a seguinte sintaxe : push segment index pop segment index Onde index \u00e9 um n\u00famero inteiro positivo e segment pode ser um dos casos a seguir: segment Uso Index Coment\u00e1rio argument Local onde o argumento da fun\u00e7\u00e3o est\u00e1 salvo 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada local Local das vari\u00e1veis locais da fun\u00e7\u00e3o 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada static Local onde as vari\u00e1veis do objeto est\u00e3o salvos 0 .. Essas vari\u00e1veis s\u00e3o compartilhadas por todas as fun\u00e7\u00f5es do mesmo .vm, assim como em um objeto constant Carrega uma constante na pilha 0 .. 32767 Mesmo uso do leaw (carrega da ROM um valor na RAM) this/that Segmentos de uso geral, pode apontar para qualquer lugar 0 .. Usado para ler e escrever de endere\u00e7os da mem\u00f3ria, por exemplo, acessar o LCD pointer Altera os valores do this e do that 0, 1 Usado para modificar a onde o this e o that apontam temp Local para uso de vari\u00e1veis tempor\u00e1rias 0 .. 7 Acessado por qualquer fun\u00e7\u00e3o, \u00e9 armazenado nos endere\u00e7os R5 .. R12 da RAM","title":"VM - Segmentos"},{"location":"Teoria-vm-segmentos/#exemplo-acessando-o-temp","text":"Por exemplo, para trazermos para a pilha uma constante realizamos a seguinte opera\u00e7\u00e3o: push constant 15 nesse caso o segmento acessado \u00e9 o constant e o par\u00e2metro \u00e9 o 15. Para salvarmos o valor 15 no temp 3 (endere\u00e7o da RAM 7), basta: push constant 15 pop temp 3 Podemos tamb\u00e9m trazer o temp 3 para a pilha: push temp 3","title":"Exemplo, acessando o temp"},{"location":"Teoria-vm-segmentos/#escrevendo-um-pixel-no-lcd","text":"Para atualizarmos o LCD via VM ser\u00e1 necess\u00e1rio primeiro atualizarmos para onde o that aponta, that \u00e9 a maneira que possu\u00edmos de escrever em qualquer endere\u00e7o da mem\u00f3ria. O exemplo a seguir ilustra como usamos o segmento that para escrever nos pixels centrais do LCD, supondo que gostar\u00edamos de realizar a seguinte opera\u00e7\u00e3o em C. int * pLCD = 16384 * ( pLCD + 1200 ) = 0xFFFF Nesse pequeno c\u00f3digo em C o que est\u00e1 acontecendo \u00e9 que primeiramente definimos um ponteiro pLCD que aponta para 16384, depois fazemos com que o endere\u00e7o desse ponteiro + 1200 receba 0xFFFF, o mesmo c\u00f3digo em VM \u00e9 realizado da seguinte maneira : push constant 16384 -- carrega 16384 para a pilha pop pointer 1 -- atualiza para onde that aponta (int *pLCD = 16384) push contant 1 -- carrega 1 para a pilha neg -- nega o 1 para obter o valor 0xFFFF -- poderia ter realizado o push contant 4095 no lugar -- dessas duas opera\u00e7\u00f5es pop that 1200 -- faz com que o endere\u00e7o da mem\u00f3ria 16384 + 1200 = 0xFFFF","title":"Escrevendo um pixel no LCD"},{"location":"Teoria-vm/","text":"VM \u00b6 A linguagem VM proposta para o curso \u00e9 baseada em pilha (assim como tantas outras), as opera\u00e7\u00f5es nesse n\u00edvel n\u00e3o lidam mais com registradores do computador por\u00e9m com dados que s\u00e3o colocados e tirados de uma pilha ( stack ). Uma grande vantagem disso \u00e9 a abstra\u00e7\u00e3o do hardware, agora n\u00e3o precisamos mais nos preocuparmos com a manipula\u00e7\u00e3o dos dados em baixo n\u00edvel e saber por exemplo quantos registradores possu\u00edmos (o VMTranslator ser\u00e1 encarregado disso). Um c\u00f3digo escrito em VM passa pelas seguintes etapas antes de ser executado em m\u00e1quina : VMTranslator Assembler .vm -------------> .nasm -------------> .hack Com o c\u00f3digo vm conseguimos implementar fun\u00e7\u00f5es, o que facilita muito o desenvolvimento de qualquer software e prepara o terreno para conseguirmos implementar uma linguagem de alto n\u00edvel. O c\u00f3digo vm \u00e9 traduzido para linguagem nasm pelo VMTranslator (voc\u00eas v\u00e3o ter que fazer parte desse programa no \u00faltimo projeto), e ent\u00e3o \u00e9 montado pelo Assembler para linguagem de m\u00e1quina. Temos diversas vantagens quando programamos em linguagem virtual: Abstra\u00e7\u00e3o de Hardware (j\u00e1 n\u00e3o mais lidamos com o hardware diretamente) Portabilidade C\u00f3digo mais alto n\u00edvel (chamada de fun\u00e7\u00f5es, linguagem mais pr\u00f3xima do que estamos acostumados, ...) Exemplo O programa a seguir escrito em vm, faz uso de uma fun\u00e7\u00e3o de multiplica\u00e7\u00e3o para multiplicar 7*2: function Main.main 0 push constant 7 push constant 2 call mult 2 A fun\u00e7\u00e3o de multiplica\u00e7\u00e3o mult \u00e9 implementada como a seguir: function mult 2 push constant 0 pop local 0 push argument 1 pop local 1 label loop push constant 0 push local 1 eq if-goto end push local 0 push argument 0 add pop local 0 push local 1 push constant 1 sub pop local 1 goto loop label end push local 0 return Tip Temos muitos outros exemplos na pasta: H-VM/src/examples/ Pilha \u00b6 A linguagem VM \u00e9 baseada em pilha, ou seja, todas as opera\u00e7\u00f5es que ser\u00e3o realizadas ser\u00e3o feitas na pilha. A pilha \u00e9 uma regi\u00e3o da mem\u00f3ria RAM (no nosso caso come\u00e7a no endere\u00e7o 256 da mem\u00f3ria RAM) reservada para armazenar os dados que est\u00e3o sendo manipulados. A pilha cresce conforme opera\u00e7\u00f5es de push (envio de dados para a pilha) v\u00e3o sendo executados, e decresce conforme opera\u00e7\u00f5es c\u00e1lculo ou de pull (retirar dados da pilha) s\u00e3o executadas. A figura a seguir demonstra o c\u00f3digo a evolu\u00e7\u00e3o da pilha quando o c\u00f3digo a seguir \u00e9 executado: push constant 3 push constant 7 add pop temp 0 Esse c\u00f3digo carrega as constantes 3 e 7 para a pilha e faz soma deles, o resultado \u00e9 guardado no endere\u00e7o de temp 0. !!! info \"Nota\u00e7\u00e0o Explicando A pilha come\u00e7a vazia e o Stack Pointer (SP) aponta para 256 Uma opera\u00e7\u00e3o de push constant 3 \u00e9 executada, SP \u00e9 incrementando e o valor 3 \u00e9 colocado no topo da pilha Uma opera\u00e7\u00e3o de push constant 7 \u00e9 executada, SP \u00e9 incrementando e o valor 7 \u00e9 colocado no topo da pilha Adicionasse os dois valores no topo da pilha add Retira o valor do topo da pilha para o endere\u00e7o de mem\u00f3ria tempor\u00e1rio 0 . Stack Pointer (SP) \u00b6 O Stack Pointer \u00e9 o endere\u00e7o de mem\u00f3ria ( RAM[0] ) reservado por apontar o topo da pilha, ou seja, a pr\u00f3xima posi\u00e7\u00e3o vazia da pilha. O SP \u00e9 salvo na RAM 0 (R0) e deve ser incrementado/decrementado conforme a pilha vai sendo manipulada. Opera\u00e7\u00f5es \u00b6 Considerando a seguinte disposi\u00e7\u00e3o na pilha : ... ... X Y SP -> S\u00e3o suportadas as seguintes opera\u00e7\u00f5es aritm\u00e9ticas na pilha: add \u00b6 executa: X + Y sub \u00b6 executa: X - Y neg \u00b6 executa: -Y (complemento de dois) eq \u00b6 compara X == Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 gt \u00b6 compara X > Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 lt \u00b6 compara X < Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 and \u00b6 executa: X and Y (bit a bit) or \u00b6 executa: X or Y (bit a bit) not \u00b6 executa: not Y (bit a bit) Note As opera\u00e7\u00f5es de compara\u00e7\u00e3o ( eq , gt , lt ) resulta em um True ou False e esse resultado \u00e9 salvo na pilha. Considere o exemplo a seguir (em hexa) que possui inicialmente na pilha os valores 0x2 , 0x3 e 0x5 , ap\u00f3s a opera\u00e7\u00e3o de eq os valores 3 e 5 s\u00e3o comparados e resulta em um valor True ou False ( 0xFFFF ou 0x0000 ). -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x5 SP-> SP-> Warning A pilha n\u00e3o \u00e9 'limpada' a cada opera\u00e7\u00e3o, os endere\u00e7os que n\u00e3o sofreram modifica\u00e7\u00e3o dado uma opera\u00e7\u00e3o continuam l\u00e1, mas voc\u00ea n\u00e3o pode considerar que eles s\u00e3o v\u00e1lidos! Se olharmos a mem\u00f3ria real do exemplo anterior seria a seguinte: -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x0 0x5 SP-> 0x5 0x5 SP-> 0x0 0x0 0x0 O mesmo acontece com arquivos que s\u00e3o deletados do seu computador, o sistema operacional n\u00e3o \"limpa a mem\u00f3ria\" sempre que um arquivo \u00e9 exclu\u00eddo, apenas apaga o ponteiro para aquele arquivo. stackoverflow Agora voc\u00ea consegue entender o significado do nome do site stack overflow? \u00e9 um estouro na pilha (quando o tamanho da pilha ultrapassa a mem\u00f3ria que est\u00e1 reservado para ela!)","title":"VM"},{"location":"Teoria-vm/#vm","text":"A linguagem VM proposta para o curso \u00e9 baseada em pilha (assim como tantas outras), as opera\u00e7\u00f5es nesse n\u00edvel n\u00e3o lidam mais com registradores do computador por\u00e9m com dados que s\u00e3o colocados e tirados de uma pilha ( stack ). Uma grande vantagem disso \u00e9 a abstra\u00e7\u00e3o do hardware, agora n\u00e3o precisamos mais nos preocuparmos com a manipula\u00e7\u00e3o dos dados em baixo n\u00edvel e saber por exemplo quantos registradores possu\u00edmos (o VMTranslator ser\u00e1 encarregado disso). Um c\u00f3digo escrito em VM passa pelas seguintes etapas antes de ser executado em m\u00e1quina : VMTranslator Assembler .vm -------------> .nasm -------------> .hack Com o c\u00f3digo vm conseguimos implementar fun\u00e7\u00f5es, o que facilita muito o desenvolvimento de qualquer software e prepara o terreno para conseguirmos implementar uma linguagem de alto n\u00edvel. O c\u00f3digo vm \u00e9 traduzido para linguagem nasm pelo VMTranslator (voc\u00eas v\u00e3o ter que fazer parte desse programa no \u00faltimo projeto), e ent\u00e3o \u00e9 montado pelo Assembler para linguagem de m\u00e1quina. Temos diversas vantagens quando programamos em linguagem virtual: Abstra\u00e7\u00e3o de Hardware (j\u00e1 n\u00e3o mais lidamos com o hardware diretamente) Portabilidade C\u00f3digo mais alto n\u00edvel (chamada de fun\u00e7\u00f5es, linguagem mais pr\u00f3xima do que estamos acostumados, ...) Exemplo O programa a seguir escrito em vm, faz uso de uma fun\u00e7\u00e3o de multiplica\u00e7\u00e3o para multiplicar 7*2: function Main.main 0 push constant 7 push constant 2 call mult 2 A fun\u00e7\u00e3o de multiplica\u00e7\u00e3o mult \u00e9 implementada como a seguir: function mult 2 push constant 0 pop local 0 push argument 1 pop local 1 label loop push constant 0 push local 1 eq if-goto end push local 0 push argument 0 add pop local 0 push local 1 push constant 1 sub pop local 1 goto loop label end push local 0 return Tip Temos muitos outros exemplos na pasta: H-VM/src/examples/","title":"VM"},{"location":"Teoria-vm/#pilha","text":"A linguagem VM \u00e9 baseada em pilha, ou seja, todas as opera\u00e7\u00f5es que ser\u00e3o realizadas ser\u00e3o feitas na pilha. A pilha \u00e9 uma regi\u00e3o da mem\u00f3ria RAM (no nosso caso come\u00e7a no endere\u00e7o 256 da mem\u00f3ria RAM) reservada para armazenar os dados que est\u00e3o sendo manipulados. A pilha cresce conforme opera\u00e7\u00f5es de push (envio de dados para a pilha) v\u00e3o sendo executados, e decresce conforme opera\u00e7\u00f5es c\u00e1lculo ou de pull (retirar dados da pilha) s\u00e3o executadas. A figura a seguir demonstra o c\u00f3digo a evolu\u00e7\u00e3o da pilha quando o c\u00f3digo a seguir \u00e9 executado: push constant 3 push constant 7 add pop temp 0 Esse c\u00f3digo carrega as constantes 3 e 7 para a pilha e faz soma deles, o resultado \u00e9 guardado no endere\u00e7o de temp 0. !!! info \"Nota\u00e7\u00e0o Explicando A pilha come\u00e7a vazia e o Stack Pointer (SP) aponta para 256 Uma opera\u00e7\u00e3o de push constant 3 \u00e9 executada, SP \u00e9 incrementando e o valor 3 \u00e9 colocado no topo da pilha Uma opera\u00e7\u00e3o de push constant 7 \u00e9 executada, SP \u00e9 incrementando e o valor 7 \u00e9 colocado no topo da pilha Adicionasse os dois valores no topo da pilha add Retira o valor do topo da pilha para o endere\u00e7o de mem\u00f3ria tempor\u00e1rio 0 .","title":"Pilha"},{"location":"Teoria-vm/#stack-pointer-sp","text":"O Stack Pointer \u00e9 o endere\u00e7o de mem\u00f3ria ( RAM[0] ) reservado por apontar o topo da pilha, ou seja, a pr\u00f3xima posi\u00e7\u00e3o vazia da pilha. O SP \u00e9 salvo na RAM 0 (R0) e deve ser incrementado/decrementado conforme a pilha vai sendo manipulada.","title":"Stack Pointer (SP)"},{"location":"Teoria-vm/#operacoes","text":"Considerando a seguinte disposi\u00e7\u00e3o na pilha : ... ... X Y SP -> S\u00e3o suportadas as seguintes opera\u00e7\u00f5es aritm\u00e9ticas na pilha:","title":"Opera\u00e7\u00f5es"},{"location":"Teoria-vm/#add","text":"executa: X + Y","title":"add"},{"location":"Teoria-vm/#sub","text":"executa: X - Y","title":"sub"},{"location":"Teoria-vm/#neg","text":"executa: -Y (complemento de dois)","title":"neg"},{"location":"Teoria-vm/#eq","text":"compara X == Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000","title":"eq"},{"location":"Teoria-vm/#gt","text":"compara X > Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000","title":"gt"},{"location":"Teoria-vm/#lt","text":"compara X < Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000","title":"lt"},{"location":"Teoria-vm/#and","text":"executa: X and Y (bit a bit)","title":"and"},{"location":"Teoria-vm/#or","text":"executa: X or Y (bit a bit)","title":"or"},{"location":"Teoria-vm/#not","text":"executa: not Y (bit a bit) Note As opera\u00e7\u00f5es de compara\u00e7\u00e3o ( eq , gt , lt ) resulta em um True ou False e esse resultado \u00e9 salvo na pilha. Considere o exemplo a seguir (em hexa) que possui inicialmente na pilha os valores 0x2 , 0x3 e 0x5 , ap\u00f3s a opera\u00e7\u00e3o de eq os valores 3 e 5 s\u00e3o comparados e resulta em um valor True ou False ( 0xFFFF ou 0x0000 ). -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x5 SP-> SP-> Warning A pilha n\u00e3o \u00e9 'limpada' a cada opera\u00e7\u00e3o, os endere\u00e7os que n\u00e3o sofreram modifica\u00e7\u00e3o dado uma opera\u00e7\u00e3o continuam l\u00e1, mas voc\u00ea n\u00e3o pode considerar que eles s\u00e3o v\u00e1lidos! Se olharmos a mem\u00f3ria real do exemplo anterior seria a seguinte: -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x0 0x5 SP-> 0x5 0x5 SP-> 0x0 0x0 0x0 O mesmo acontece com arquivos que s\u00e3o deletados do seu computador, o sistema operacional n\u00e3o \"limpa a mem\u00f3ria\" sempre que um arquivo \u00e9 exclu\u00eddo, apenas apaga o ponteiro para aquele arquivo. stackoverflow Agora voc\u00ea consegue entender o significado do nome do site stack overflow? \u00e9 um estouro na pilha (quando o tamanho da pilha ultrapassa a mem\u00f3ria que est\u00e1 reservado para ela!)","title":"not"},{"location":"Util-Aulas/","text":"Resumo Aulas \u00b6 Resumo e planejamento das aulas. Av4 - PF - 02/12 \u00b6 Aula 30/11 \u00b6 Estudo pr\u00e9vio VM - jump VM - Fun\u00e7\u00f5es Expositiva/D\u00favidas (2h00) Aula 25/11 \u00b6 Estudo pr\u00e9vio Linguagem de M\u00e1quina Virtual VM - Segmentos VM - Mem\u00f3ria Expositiva/D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 17: VM (Treinando RPN e VM Z01 - b\u00e1sico) Aula 23/11 \u00b6 Estudo pr\u00e9vio Assembler - Tabela de s\u00edmbolos Resolu\u00e7\u00e3o prova (0h30) D\u00favidas/ Expositiva (0h30): Laborat\u00f3rio (1h00) Lab 16: Assembler - parte 4 Lab 16: Assembler - parte 5 Aula 18/11 \u00b6 Estudo pr\u00e9vio Assembler Revis\u00e3o/ D\u00favidas/ Expositiva (1h00): Laborat\u00f3rio (1h00) Lab 16: Assembler Aula 16/11 \u00b6 Estudo pr\u00e9vio Assembler Expositiva/D\u00favidas (1h20) Laborat\u00f3rio (0h40) Lab 16: Assembler 11/11 - Av3 \u00b6 Aula 09/11 \u00b6 Estudo pr\u00e9vio CPU Linguagem de m\u00e1quina Expositiva/ D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 15: Control unit Aula 04/11 \u00b6 Estudo pr\u00e9vio CPU Linguagem de m\u00e1quina Expositiva/ D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 14: Pequena CPU Aula 28/10 \u00b6 Estudo pr\u00e9vio ASM - Jump Revis\u00e3o/ D\u00favidas/ Expositiva (0h30): Laborat\u00f3rio (1h30) Lab 12: Jump Lab 13: Praticando Aula 26/10 \u00b6 Estudo pr\u00e9vio ASM - Mapa de mem\u00f3ria Revis\u00e3o/ D\u00favidas/ Expositiva (1h00): Laborat\u00f3rio (1h00) Lab 11: Perif\u00e9ricos Aula 21/10 \u00b6 Estudo pr\u00e9vio Linguagem de m\u00e1quina ASM - Assembly Resumo - Assembly Expositiva/ D\u00favidas (1h00): Laborat\u00f3rio (1h00) Lab 10: Assembly Aula 19/10 \u00b6 Projeto D-L\u00f3gica Sequencial. Expositiva/ D\u00favidas (0h30) Aula est\u00fadio (1h30) Aula 14/10 \u00b6 Come\u00e7o do projeto D-L\u00f3gica Sequencial. Estudo pr\u00e9vio L\u00f3gica Sequencial Expositiva/ D\u00favidas (1h00): Laborat\u00f3rio (1h00) Lab 9: L\u00f3gica sequencial Aula 30/09 \u00b6 Segunda Avalia\u00e7\u00e3o Individual - Av2 Aula 23/09 \u00b6 Expositiva/D\u00favidas/Revis\u00e3o para a AV-I (0h30) Aula est\u00fadio (1h30) Aula 21/09 \u00b6 Detalhes da ULA da CPU do Z01.1. Estudo pr\u00e9vio ULA Expositiva/D\u00favidas (0h30) Laborat\u00f3rios (0h30) Lab 8: ULA Aula est\u00fadio (1h00) Aula 16/09 \u00b6 Come\u00e7o do projeto C-ULA, trabalhando com aritm\u00e9tica bin\u00e1ria. Estudo pr\u00e9vio Aritm\u00e9tica Bin\u00e1ria Aritm\u00e9tica Bin\u00e1ria - HW Expositiva/ D\u00favidas (0h30): Handout (0h40): Handout Aritm\u00e9tica Booleana Laborat\u00f3rios (0h50) Lab 6: Adders Lab 7: Visualizando simula\u00e7\u00e3o Aula 14/09 \u00b6 Est\u00fadio Aula 09/09 \u00b6 Projeto B - L\u00f3gica Combinacional Estudo pr\u00e9vio https://insper.github.io/Z01.1/Teoria-Componentes/ https://insper.github.io/Z01.1/VHDL-basico/ https://insper.github.io/Z01.1/VHDL-Combinacional/ Expositiva/ D\u00favidas (0h30) Laborat\u00f3rios (1h30) Lab5: L\u00f3gica Combinacional Aula 02/09 \u00b6 Inicio do projeto B - L\u00f3gica Combinacional, come\u00e7o do uso de VHDL. Estudo pr\u00e9vio https://insper.github.io/Z01.1/Teoria-Componentes/ https://insper.github.io/Z01.1/VHDL-basico/ https://insper.github.io/Z01.1/VHDL-Combinacional/ Expositiva/ D\u00favidas (0h30) Laborat\u00f3rios (1h30) Lab 2: GitHub Lab 3: GitHub Lab 4: FPGA - VHDL Aula 31/08 \u00b6 Primeira Avalia\u00e7\u00e3o Individual - Av1 Aula 26/08 \u00b6 Trabalhar com transistores e circuitos integrados. Estudo pr\u00e9vio Teoria RTL Teoria CMOS Expositiva/ D\u00favidas (0h40): Laborat\u00f3rio (1h20): Lab 1: Transistores / CI Aula 24/08 \u00b6 Estudar l\u00f3gica booleana e praticar Estudo pr\u00e9vio Teoria \u00c1lgebra Booleana Expositiva/ D\u00favidas (45 min) Handout/ Exerc\u00edcio (1h15): \u00c1lgebra Booleana - 1 \u00c1lgebra Booleana - 2 Aula 19/08 \u00b6 D\u00favidas sobre dados digitais, uma breve vis\u00e3o geral sobre git e github. Estudo pr\u00e9vio Dados digitais Expositiva/ D\u00favidas (0h40): Slides Handout/ Exerc\u00edcio (1h20): Dados Digitais 1 Dados Digitais 2 Aritmetica Booleana - Ex. 1 Aula 17/08 \u00b6 Aula de apresenta\u00e7\u00e3o da mat\u00e9ria; vis\u00e3o geral do que vai ser feito; cria\u00e7\u00e3o de grupos. Slides (1h00): Slide Prezi Handout/ Estudo/ Exerc\u00edcio (1h00): Montar grupos Mural","title":"Resumo Aulas"},{"location":"Util-Aulas/#resumo-aulas","text":"Resumo e planejamento das aulas.","title":"Resumo Aulas"},{"location":"Util-Aulas/#av4-pf-0212","text":"","title":"Av4 - PF - 02/12"},{"location":"Util-Aulas/#aula-3011","text":"Estudo pr\u00e9vio VM - jump VM - Fun\u00e7\u00f5es Expositiva/D\u00favidas (2h00)","title":"Aula 30/11"},{"location":"Util-Aulas/#aula-2511","text":"Estudo pr\u00e9vio Linguagem de M\u00e1quina Virtual VM - Segmentos VM - Mem\u00f3ria Expositiva/D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 17: VM (Treinando RPN e VM Z01 - b\u00e1sico)","title":"Aula 25/11"},{"location":"Util-Aulas/#aula-2311","text":"Estudo pr\u00e9vio Assembler - Tabela de s\u00edmbolos Resolu\u00e7\u00e3o prova (0h30) D\u00favidas/ Expositiva (0h30): Laborat\u00f3rio (1h00) Lab 16: Assembler - parte 4 Lab 16: Assembler - parte 5","title":"Aula 23/11"},{"location":"Util-Aulas/#aula-1811","text":"Estudo pr\u00e9vio Assembler Revis\u00e3o/ D\u00favidas/ Expositiva (1h00): Laborat\u00f3rio (1h00) Lab 16: Assembler","title":"Aula 18/11"},{"location":"Util-Aulas/#aula-1611","text":"Estudo pr\u00e9vio Assembler Expositiva/D\u00favidas (1h20) Laborat\u00f3rio (0h40) Lab 16: Assembler","title":"Aula 16/11"},{"location":"Util-Aulas/#1111-av3","text":"","title":"11/11 - Av3"},{"location":"Util-Aulas/#aula-0911","text":"Estudo pr\u00e9vio CPU Linguagem de m\u00e1quina Expositiva/ D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 15: Control unit","title":"Aula 09/11"},{"location":"Util-Aulas/#aula-0411","text":"Estudo pr\u00e9vio CPU Linguagem de m\u00e1quina Expositiva/ D\u00favidas (1h00) Laborat\u00f3rio (1h00) Lab 14: Pequena CPU","title":"Aula 04/11"},{"location":"Util-Aulas/#aula-2810","text":"Estudo pr\u00e9vio ASM - Jump Revis\u00e3o/ D\u00favidas/ Expositiva (0h30): Laborat\u00f3rio (1h30) Lab 12: Jump Lab 13: Praticando","title":"Aula 28/10"},{"location":"Util-Aulas/#aula-2610","text":"Estudo pr\u00e9vio ASM - Mapa de mem\u00f3ria Revis\u00e3o/ D\u00favidas/ Expositiva (1h00): Laborat\u00f3rio (1h00) Lab 11: Perif\u00e9ricos","title":"Aula 26/10"},{"location":"Util-Aulas/#aula-2110","text":"Estudo pr\u00e9vio Linguagem de m\u00e1quina ASM - Assembly Resumo - Assembly Expositiva/ D\u00favidas (1h00): Laborat\u00f3rio (1h00) Lab 10: Assembly","title":"Aula 21/10"},{"location":"Util-Aulas/#aula-1910","text":"Projeto D-L\u00f3gica Sequencial. Expositiva/ D\u00favidas (0h30) Aula est\u00fadio (1h30)","title":"Aula 19/10"},{"location":"Util-Aulas/#aula-1410","text":"Come\u00e7o do projeto D-L\u00f3gica Sequencial. Estudo pr\u00e9vio L\u00f3gica Sequencial Expositiva/ D\u00favidas (1h00): Laborat\u00f3rio (1h00) Lab 9: L\u00f3gica sequencial","title":"Aula 14/10"},{"location":"Util-Aulas/#aula-3009","text":"Segunda Avalia\u00e7\u00e3o Individual - Av2","title":"Aula 30/09"},{"location":"Util-Aulas/#aula-2309","text":"Expositiva/D\u00favidas/Revis\u00e3o para a AV-I (0h30) Aula est\u00fadio (1h30)","title":"Aula 23/09"},{"location":"Util-Aulas/#aula-2109","text":"Detalhes da ULA da CPU do Z01.1. Estudo pr\u00e9vio ULA Expositiva/D\u00favidas (0h30) Laborat\u00f3rios (0h30) Lab 8: ULA Aula est\u00fadio (1h00)","title":"Aula 21/09"},{"location":"Util-Aulas/#aula-1609","text":"Come\u00e7o do projeto C-ULA, trabalhando com aritm\u00e9tica bin\u00e1ria. Estudo pr\u00e9vio Aritm\u00e9tica Bin\u00e1ria Aritm\u00e9tica Bin\u00e1ria - HW Expositiva/ D\u00favidas (0h30): Handout (0h40): Handout Aritm\u00e9tica Booleana Laborat\u00f3rios (0h50) Lab 6: Adders Lab 7: Visualizando simula\u00e7\u00e3o","title":"Aula 16/09"},{"location":"Util-Aulas/#aula-1409","text":"Est\u00fadio","title":"Aula 14/09"},{"location":"Util-Aulas/#aula-0909","text":"Projeto B - L\u00f3gica Combinacional Estudo pr\u00e9vio https://insper.github.io/Z01.1/Teoria-Componentes/ https://insper.github.io/Z01.1/VHDL-basico/ https://insper.github.io/Z01.1/VHDL-Combinacional/ Expositiva/ D\u00favidas (0h30) Laborat\u00f3rios (1h30) Lab5: L\u00f3gica Combinacional","title":"Aula 09/09"},{"location":"Util-Aulas/#aula-0209","text":"Inicio do projeto B - L\u00f3gica Combinacional, come\u00e7o do uso de VHDL. Estudo pr\u00e9vio https://insper.github.io/Z01.1/Teoria-Componentes/ https://insper.github.io/Z01.1/VHDL-basico/ https://insper.github.io/Z01.1/VHDL-Combinacional/ Expositiva/ D\u00favidas (0h30) Laborat\u00f3rios (1h30) Lab 2: GitHub Lab 3: GitHub Lab 4: FPGA - VHDL","title":"Aula 02/09"},{"location":"Util-Aulas/#aula-3108","text":"Primeira Avalia\u00e7\u00e3o Individual - Av1","title":"Aula 31/08"},{"location":"Util-Aulas/#aula-2608","text":"Trabalhar com transistores e circuitos integrados. Estudo pr\u00e9vio Teoria RTL Teoria CMOS Expositiva/ D\u00favidas (0h40): Laborat\u00f3rio (1h20): Lab 1: Transistores / CI","title":"Aula 26/08"},{"location":"Util-Aulas/#aula-2408","text":"Estudar l\u00f3gica booleana e praticar Estudo pr\u00e9vio Teoria \u00c1lgebra Booleana Expositiva/ D\u00favidas (45 min) Handout/ Exerc\u00edcio (1h15): \u00c1lgebra Booleana - 1 \u00c1lgebra Booleana - 2","title":"Aula 24/08"},{"location":"Util-Aulas/#aula-1908","text":"D\u00favidas sobre dados digitais, uma breve vis\u00e3o geral sobre git e github. Estudo pr\u00e9vio Dados digitais Expositiva/ D\u00favidas (0h40): Slides Handout/ Exerc\u00edcio (1h20): Dados Digitais 1 Dados Digitais 2 Aritmetica Booleana - Ex. 1","title":"Aula 19/08"},{"location":"Util-Aulas/#aula-1708","text":"Aula de apresenta\u00e7\u00e3o da mat\u00e9ria; vis\u00e3o geral do que vai ser feito; cria\u00e7\u00e3o de grupos. Slides (1h00): Slide Prezi Handout/ Estudo/ Exerc\u00edcio (1h00): Montar grupos Mural","title":"Aula 17/08"},{"location":"Util-Comecando-novo-projeto/","text":"Come\u00e7ando novo projeto \u00b6 Linux Usar o Linux fornecido! Scrum Master O grupo deve escolher um mediador Aconselh\u00e1vel no primeiro projeto o facilitador ser aquele que tem mais facilidade com linux e git. Voc\u00ea deve fazer a sec\u00e7\u00e3o do seu papel: Mediador/ Desenvolvedor Antes de come\u00e7ar - Mediador \u00b6 Mediador Somente mediador , mas todos devem acompanhar (uma hora ser\u00e1 sua vez). Ao acessar a nova atividade, um novo reposit\u00f3rio \u00e9 criado. Assim, \u00e9 necess\u00e1rio juntar os arquivos desenvolvidos nos projetos anteriores (camadas inferiores) ao novo reposit\u00f3rio. Abrindo terminal no Linux ctrl + alt + t No terminal: $ git remote add --fetch APS-a https://github.com/insper-classroom/aps-<projeto anterior>-<nome do grupo> $ git merge --allow-unrelated-histories APS-a/main -X theirs $ git remote remove APS-a Actions \u00b6 Arquivos ocultos No linux os arquivos que come\u00e7am com . s\u00e3o ocultos, ou seja, eles n\u00e3o aparecem normalmente no gerenciador de arquivos ou no comando ls , para ver os arquivos ocultos: No gerenciador de arquivos aperte crtl + h ( h de hide ) ls -a ( onde -a indica all ) Edite o arquivo actions.yml localizado na pasta .github/workflows/ modificando o final do arquivo para ficar como: Tip Acrescentar o script do novo projeto ao final do arquivo. python3 B-LogicaCombinacional/testeLogicaCombinacional.py python3 C-UnidadeLogicaAritmetica/testeULA.py Agora vamos realizar um commit e submeter aos demais colegas do grupo as altera\u00e7\u00f5es: $ git add .github/workflows/actions.yml $ git commit -m \"configurando actions para novo projeto\" SCRUM_MASTER.json \u00b6 O mediador do projeto deve editar o arquivo SCRUM_MASTER.json localizado na pasta do projeto (no caso do projeto B: B-LogicaCombinacional/SCRUM_MASTER.json ) com os seus dados. Ap\u00f3s editar esse arquivo deve realizar um commit e fazer o envio para o github: $ git commit -am \"configurado scrum do projeto\" $ git push origin main Note Isso \u00e9 importante pois os professores ir\u00e3o usar esse arquivo para saber quem s\u00e3o os mediadores de cada projeto. Atualizar tools \u00b6 Voc\u00ea deve atualizar os scripts de teste, executando o comando a seguir: $ ./updateZ01tools.sh Antes de come\u00e7ar - Desenvolvedores \u00b6 Desenvolvedores Todos desenvolvedores devem fazer essa etapa. Fazer isso somente depois que o mediador fez a parte dele! Volte para a branch main: $ git checkout main Agora todos os integrantes do grupo devem atualizar o reposit\u00f3rio local: $ git pull origin main Atualizando Infra \u00b6 Warning Todos devem realizar essa etapa: Mediadores e Desenvolvedores Atualizar a infra da disciplina executando o comando a seguir na pasta raiz ro repositorio: $ ./updateZ01tools.sh Isso ir\u00e1 baixar as depend\u00eancias phython (via pip) e tamb\u00e9m clonar um reposit\u00f3rio chamado Z01-Tools na raiz do usu\u00e1rio: $HOME/Z01-Tools/ .","title":"Come\u00e7ando novo projeto"},{"location":"Util-Comecando-novo-projeto/#comecando-novo-projeto","text":"Linux Usar o Linux fornecido! Scrum Master O grupo deve escolher um mediador Aconselh\u00e1vel no primeiro projeto o facilitador ser aquele que tem mais facilidade com linux e git. Voc\u00ea deve fazer a sec\u00e7\u00e3o do seu papel: Mediador/ Desenvolvedor","title":"Come\u00e7ando novo projeto"},{"location":"Util-Comecando-novo-projeto/#antes-de-comecar-mediador","text":"Mediador Somente mediador , mas todos devem acompanhar (uma hora ser\u00e1 sua vez). Ao acessar a nova atividade, um novo reposit\u00f3rio \u00e9 criado. Assim, \u00e9 necess\u00e1rio juntar os arquivos desenvolvidos nos projetos anteriores (camadas inferiores) ao novo reposit\u00f3rio. Abrindo terminal no Linux ctrl + alt + t No terminal: $ git remote add --fetch APS-a https://github.com/insper-classroom/aps-<projeto anterior>-<nome do grupo> $ git merge --allow-unrelated-histories APS-a/main -X theirs $ git remote remove APS-a","title":"Antes de come\u00e7ar - Mediador"},{"location":"Util-Comecando-novo-projeto/#actions","text":"Arquivos ocultos No linux os arquivos que come\u00e7am com . s\u00e3o ocultos, ou seja, eles n\u00e3o aparecem normalmente no gerenciador de arquivos ou no comando ls , para ver os arquivos ocultos: No gerenciador de arquivos aperte crtl + h ( h de hide ) ls -a ( onde -a indica all ) Edite o arquivo actions.yml localizado na pasta .github/workflows/ modificando o final do arquivo para ficar como: Tip Acrescentar o script do novo projeto ao final do arquivo. python3 B-LogicaCombinacional/testeLogicaCombinacional.py python3 C-UnidadeLogicaAritmetica/testeULA.py Agora vamos realizar um commit e submeter aos demais colegas do grupo as altera\u00e7\u00f5es: $ git add .github/workflows/actions.yml $ git commit -m \"configurando actions para novo projeto\"","title":"Actions"},{"location":"Util-Comecando-novo-projeto/#scrum_masterjson","text":"O mediador do projeto deve editar o arquivo SCRUM_MASTER.json localizado na pasta do projeto (no caso do projeto B: B-LogicaCombinacional/SCRUM_MASTER.json ) com os seus dados. Ap\u00f3s editar esse arquivo deve realizar um commit e fazer o envio para o github: $ git commit -am \"configurado scrum do projeto\" $ git push origin main Note Isso \u00e9 importante pois os professores ir\u00e3o usar esse arquivo para saber quem s\u00e3o os mediadores de cada projeto.","title":"SCRUM_MASTER.json"},{"location":"Util-Comecando-novo-projeto/#atualizar-tools","text":"Voc\u00ea deve atualizar os scripts de teste, executando o comando a seguir: $ ./updateZ01tools.sh","title":"Atualizar tools"},{"location":"Util-Comecando-novo-projeto/#antes-de-comecar-desenvolvedores","text":"Desenvolvedores Todos desenvolvedores devem fazer essa etapa. Fazer isso somente depois que o mediador fez a parte dele! Volte para a branch main: $ git checkout main Agora todos os integrantes do grupo devem atualizar o reposit\u00f3rio local: $ git pull origin main","title":"Antes de come\u00e7ar - Desenvolvedores"},{"location":"Util-Comecando-novo-projeto/#atualizando-infra","text":"Warning Todos devem realizar essa etapa: Mediadores e Desenvolvedores Atualizar a infra da disciplina executando o comando a seguir na pasta raiz ro repositorio: $ ./updateZ01tools.sh Isso ir\u00e1 baixar as depend\u00eancias phython (via pip) e tamb\u00e9m clonar um reposit\u00f3rio chamado Z01-Tools na raiz do usu\u00e1rio: $HOME/Z01-Tools/ .","title":"Atualizando Infra"},{"location":"Util-Dicas-GIT/","text":"Dicas git \u00b6 Clonando reposit\u00f3rio \u00b6 $ git clone URL_DO_SEU_REP Instalando/Atualizando Z01-tools \u00b6 $ cd SEU_REP $ ./updateZ01tools.sh O script updateZ01tools.sh clona o reposit\u00f3rio http://github.com/Insper/z01-tools e o salva em sua pasta $HOME (/home/user/). O script serve para instalar e/ou atualizar a infra da disciplina, deve ser executado sempre que indicado pelo professor. Configurando upstream (Z01.1 professor) \u00b6 Referenciando reposit\u00f3rio original da disciplina: $ git remote add upstream https://github.com/insper/Z01.1 Atualizando reposit\u00f3rio do grupo \u00b6 Atualizando reposit\u00f3rio do grupo com altera\u00e7\u00f5es feitas no reposit\u00f3rio da disciplina: $ git fetch upstream $ git checkout main $ git merge upstream/main $ git push origin main","title":"Dicas git"},{"location":"Util-Dicas-GIT/#dicas-git","text":"","title":"Dicas git"},{"location":"Util-Dicas-GIT/#clonando-repositorio","text":"$ git clone URL_DO_SEU_REP","title":"Clonando reposit\u00f3rio"},{"location":"Util-Dicas-GIT/#instalandoatualizando-z01-tools","text":"$ cd SEU_REP $ ./updateZ01tools.sh O script updateZ01tools.sh clona o reposit\u00f3rio http://github.com/Insper/z01-tools e o salva em sua pasta $HOME (/home/user/). O script serve para instalar e/ou atualizar a infra da disciplina, deve ser executado sempre que indicado pelo professor.","title":"Instalando/Atualizando Z01-tools"},{"location":"Util-Dicas-GIT/#configurando-upstream-z011-professor","text":"Referenciando reposit\u00f3rio original da disciplina: $ git remote add upstream https://github.com/insper/Z01.1","title":"Configurando upstream (Z01.1 professor)"},{"location":"Util-Dicas-GIT/#atualizando-repositorio-do-grupo","text":"Atualizando reposit\u00f3rio do grupo com altera\u00e7\u00f5es feitas no reposit\u00f3rio da disciplina: $ git fetch upstream $ git checkout main $ git merge upstream/main $ git push origin main","title":"Atualizando reposit\u00f3rio do grupo"},{"location":"Util-Dicas-Travis/","text":"Dicas Actions \u00b6 Adicionando teste ao projeto \u00b6 Edite o arquivo actions.yml localizado na pasta .github/workflows/, adicionando o script que deseja testar. Exemplos, para testarmos o projeto B \u00e9 necess\u00e1rio adicionar a seguinte linha: python3 B-LogicaCombinacional/testeLogicaCombinacional.py Isso deve ser feito na parte final do arquivo python3 B-LogicaCombinacional/testeLogicaCombinacional.py python3 C-UnidadeLogicaAritmetica/testeULA.py python3 D-LogicaSequencial/testeLogicaSequencial.py Warning Voc\u00ea n\u00e3o deve remover os testes antigos","title":"Dicas Actions"},{"location":"Util-Dicas-Travis/#dicas-actions","text":"","title":"Dicas Actions"},{"location":"Util-Dicas-Travis/#adicionando-teste-ao-projeto","text":"Edite o arquivo actions.yml localizado na pasta .github/workflows/, adicionando o script que deseja testar. Exemplos, para testarmos o projeto B \u00e9 necess\u00e1rio adicionar a seguinte linha: python3 B-LogicaCombinacional/testeLogicaCombinacional.py Isso deve ser feito na parte final do arquivo python3 B-LogicaCombinacional/testeLogicaCombinacional.py python3 C-UnidadeLogicaAritmetica/testeULA.py python3 D-LogicaSequencial/testeLogicaSequencial.py Warning Voc\u00ea n\u00e3o deve remover os testes antigos","title":"Adicionando teste ao projeto"},{"location":"Util-Infraestrutura/","text":"Os softwares que ser\u00e3o utilizados ao longo do semestre s\u00e3o: Intel Quartus : Software da Intel/ Altera utilizado para programar FPGAs (compilador, IDE, ...). ModelSim : Software da MentorGraphics utilizado para simular HDL (VHDL/Verilog) Python 3 : Para automatizar os testes Java JDK 8 : Java Development Kit Editor de texto : Editor de texto para programa\u00e7\u00e3o em VHDL/Java IDE de programa\u00e7\u00e3o JAVA : Eclipse / IntelliJ IDEA Voc\u00ea ir\u00e1 receber um SSD com Linux e a infra de elementos j\u00e1 instalada.","title":"Infraestrutura"},{"location":"Util-InstructionSet/","text":"Download em PDF","title":"Instruction Set"},{"location":"Util-Resumo-Assembly/","text":"Z01 - Resumo Assembly \u00b6 Nota\u00e7\u00e3o reg : Registrador ( %A , %D ) mem : Acesso a mem\u00f3ria (%A) im : Imediato, pode ser: ( $1 , $0 , $-1 ) const : Constante positiva ( $0 , $9 , ....) Arquivos: extens\u00f5es .nasm : Arquivo assembly .hack : Linguagem de m\u00e1quina (arquivo com zeros e uns) .mif : Arquivo .hack que pode ser salvo na mem\u00f3ria da FPGA .lst : sa\u00edda do simulador com os estados da CPU Warning Nosso hardware n\u00e3o suporta opera\u00e7\u00f5es que realizam escrita e leitura na mem\u00f3ria RAM ao mesmo tempo. Opera\u00e7\u00f5es como: incw (%A) decw (%A) addw (%A), %D, (%A) subw %D, (%A), (%A) ... V\u00e3o ser aceitas pelo assembler, mas v\u00e3o executar erradas no HW. Instru\u00e7\u00f5es \u00b6 LEA - Carregamento Efetivo do Endere\u00e7o (Valor) \u00b6 leaw const, reg Restri\u00e7\u00e3o A opera\u00e7\u00e3o de leaw s\u00f3 aceita o registrador %A A instru\u00e7\u00e3o leaw armazena o valor passado ( const ) no registrador especificado ; Exemplo: %A = 15 leaw $ 15 , % A MOV - Copia Valores \u00b6 movw im*/reg/mem, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o de mov faz na verde uma c\u00f3pia, deixando a origem com o dado original. A instru\u00e7\u00e3o mov, copia o valor da primeira posi\u00e7\u00e3o para a segunda posi\u00e7\u00e3o (terceira e quarta opcional). ; Exemplo: D = RAM[A] movw ( % A ), % D ADD - Adi\u00e7\u00e3o de Inteiros \u00b6 addw reg/mem, reg/mem/im*, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o permite salvar o resultado em mais de um destino. instru\u00e7\u00e3o add, soma o primeiro valor ao segundo valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: D = RAM[A]+D addw ( % A ), % D , % D SUB - Subtra\u00e7\u00e3o de Inteiros \u00b6 subw reg/mem, rem/mem/im*, reg/mem {, reg/mem, reg/mem} A instru\u00e7\u00e3o sub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = D - RAM[A] subw % D , ( % A ), % A RSUB - Subtra\u00e7\u00e3o de Inteiros Reversa \u00b6 rsubw reg/mem/im*, rem/mem, reg {, reg, reg} A instru\u00e7\u00e3o rsub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = RAM[A] - D rsubw % D , ( % A ), % A INC - Incrementa Inteiro \u00b6 incw reg Restri\u00e7\u00e3o O destino \u00e9 o pr\u00f3prio registrador! A opera\u00e7\u00e3o n\u00e3o permite salvar em um registrador diferente. Dica Se quiser fazer a opera\u00e7\u00e3o de inc e salvar em outro registrador, pode utilizar a opera\u00e7\u00e3o de addw : ; D = A + 1 addw $ 1 , % A , % D A instru\u00e7\u00e3o inc, adiciona um (1) ao valor do registrador ou mem\u00f3ria. ; Exemplo: D = D + 1 incw % D DEC - Decrementa Inteiro \u00b6 decw reg A instru\u00e7\u00e3o dec, subtrai um (1) do valor do registrador ou mem\u00f3ria. ; Exemplo: A = A-1 decw % A NOT - Nega\u00e7\u00e3o por Complemento de Um \u00b6 notw reg A instru\u00e7\u00e3o not, inverte o valor de cada bit do reg origem, ou seja, se um bit tem valor 0 fica com 1 e vice-versa. ; Exemplo: D = !D notw % D NEG - Nega\u00e7\u00e3o por Complemento de dois \u00b6 negw reg A instru\u00e7\u00e3o neg, faz o valor ficar negativo, ou seja, um valor de x \u00e9 modificado para -x. ; Exemplo: A = -A negw % A AND - Operador E (and) \u00b6 andw reg/mem, rem/mem A instru\u00e7\u00e3o and executa o operador l\u00f3gico E (and). ; Exemplo: D = A&D andw % A , % D , % D OR - Operador OU (or) \u00b6 orw reg/mem, rem/mem A instru\u00e7\u00e3o or executa o operador l\u00f3gico Ou (or). ; Exemplo: D = RAM[A] | D orw ( % A ), % D , % D JMP - Jump \u00b6 jmp A instru\u00e7\u00e3o jmp executa um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A. jmp JE - Desvia Execu\u00e7\u00e3o se Igual a Zero \u00b6 je reg A instru\u00e7\u00e3o je faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for igual a zero. je % D JNE - Desvia Execu\u00e7\u00e3o se Diferente de Zero \u00b6 jne reg A instru\u00e7\u00e3o jne faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for diferente de zero. jne % D JG - Desvia Execu\u00e7\u00e3o se Maior que Zero \u00b6 jg reg A instru\u00e7\u00e3o jg desvia, o fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior que zero. jg % D JGE - Desvia Execu\u00e7\u00e3o se Maior Igual a Zero \u00b6 jge reg A instru\u00e7\u00e3o jge faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior ou igual a zero. jge % D JL - Desvia Execu\u00e7\u00e3o se Menor que Zero \u00b6 jl reg A instru\u00e7\u00e3o jl faz desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor que zero. jl % D JLE - Desvia Execu\u00e7\u00e3o se Menor Igual a Zero \u00b6 jle reg A instru\u00e7\u00e3o jle faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor ou igual a zero. jle % D NOP - N\u00e3o faz nada (No Operation) \u00b6 nop A instru\u00e7\u00e3o nop n\u00e3o faz nada, usado para pular um ciclo de execu\u00e7\u00e3o. nop Descri\u00e7\u00e3o Detalhada \u00b6 Formato das Instru\u00e7\u00f5es Em Assembly, codificamos uma instru\u00e7\u00e3o por linha e ela \u00e9 constru\u00edda a partir do mnem\u00f4nico da opera\u00e7\u00e3o e seus argumentos. Al\u00e9m disso, temos marcadores de posi\u00e7\u00e3o (endere\u00e7o usado em desvios), constantes e poss\u00edveis vari\u00e1veis. O formato das instru\u00e7\u00f5es na sintaxe AT&T segue o seguinte formato: mnem\u00f4nico origem, destino Registradores Todos os registradores devem ter como prefixo o sinal de porcentagem '%\\', por exemplo: %A ou %D. Valores Literais Todos os valores literais devem ter como prefixo o sinal de cifr\u00e3o '$\\', por exemplo: $55, $376, sendo o maior valor 2047 (15 bits). Endere\u00e7amento de Mem\u00f3ria Na sintaxe AT&T, a mem\u00f3ria \u00e9 referenciada com par\u00eantese em volta do registrador que armazena o endere\u00e7o: por exemplo (%A). Tamanho dos operadores Algumas instru\u00e7\u00f5es podem trabalhar com diferentes tamanhos de dados, assim as instru\u00e7\u00f5es podem ter um sufixo, informando o tamanho do dado que ir\u00e1 manipular, sendo b (8 bits), w (16 bits) e l (32 bits). Por exemplo: movw $2000, (%A) Instru\u00e7\u00f5es de Transfer\u00eancia de Controle As instru\u00e7\u00f5es de jump, fazem o fluxo do programa desviar de uma posi\u00e7\u00e3o do programa para outra. Para marcar as posi\u00e7\u00f5es no programa, s\u00e3o usados marcadores (labels) que sempre terminam com dois pontos (:). Por exemplo: loop: Registradores virtuais Os s\u00edmbolos R0, ..., R15 s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0, ..., 15 Ponteiros de I/O Os s\u00edmbolos SCREEN e KBD s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 16384 e 24576, respectivamente. Ponteiros de controle da VM Os s\u00edmbolos SP, LCL, ARG, THIS, e THAT s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0-4, respectivamente. Nota\u00e7\u00f5es: im : valor imediato (somente os valores 1, 0 e -1). reg : registrador. mem: mem\u00f3ria, ou seja (%A). Limita\u00e7\u00f5es: A arquitetura n\u00e3o permite somar o valor da mem\u00f3ria apontada por (%A) com o valor de %A, ou de (%A) com (%A), tampouco %A com %A. N\u00e3o \u00e9 poss\u00edvel somar (ou subtrair, se \u00e9 que isso faz sentido) o registrador com o mesmo, por exemplo somar %D com %D. N\u00e3o \u00e9 poss\u00edvel ler e gravar a mem\u00f3ria ao mesmo tempo. Por exemplo, as instru\u00e7\u00f5es abaixo n\u00e3o funcionam no nosso computador: incw (%A); subw (%A),%D,(%A). Observa\u00e7\u00e3o: A linguagem Assembly apresentada \u00e9 especifica para o processador produzido no curso. Embora muito similar a outras usadas em produtos de mercado, as instru\u00e7\u00f5es possuem limita\u00e7\u00f5es inerentes a cada hardware.","title":"Resumo Assembly"},{"location":"Util-Resumo-Assembly/#z01-resumo-assembly","text":"Nota\u00e7\u00e3o reg : Registrador ( %A , %D ) mem : Acesso a mem\u00f3ria (%A) im : Imediato, pode ser: ( $1 , $0 , $-1 ) const : Constante positiva ( $0 , $9 , ....) Arquivos: extens\u00f5es .nasm : Arquivo assembly .hack : Linguagem de m\u00e1quina (arquivo com zeros e uns) .mif : Arquivo .hack que pode ser salvo na mem\u00f3ria da FPGA .lst : sa\u00edda do simulador com os estados da CPU Warning Nosso hardware n\u00e3o suporta opera\u00e7\u00f5es que realizam escrita e leitura na mem\u00f3ria RAM ao mesmo tempo. Opera\u00e7\u00f5es como: incw (%A) decw (%A) addw (%A), %D, (%A) subw %D, (%A), (%A) ... V\u00e3o ser aceitas pelo assembler, mas v\u00e3o executar erradas no HW.","title":"Z01 - Resumo Assembly"},{"location":"Util-Resumo-Assembly/#instrucoes","text":"","title":"Instru\u00e7\u00f5es"},{"location":"Util-Resumo-Assembly/#lea-carregamento-efetivo-do-endereco-valor","text":"leaw const, reg Restri\u00e7\u00e3o A opera\u00e7\u00e3o de leaw s\u00f3 aceita o registrador %A A instru\u00e7\u00e3o leaw armazena o valor passado ( const ) no registrador especificado ; Exemplo: %A = 15 leaw $ 15 , % A","title":"LEA - Carregamento Efetivo do Endere\u00e7o (Valor)"},{"location":"Util-Resumo-Assembly/#mov-copia-valores","text":"movw im*/reg/mem, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o de mov faz na verde uma c\u00f3pia, deixando a origem com o dado original. A instru\u00e7\u00e3o mov, copia o valor da primeira posi\u00e7\u00e3o para a segunda posi\u00e7\u00e3o (terceira e quarta opcional). ; Exemplo: D = RAM[A] movw ( % A ), % D","title":"MOV - Copia Valores"},{"location":"Util-Resumo-Assembly/#add-adicao-de-inteiros","text":"addw reg/mem, reg/mem/im*, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o permite salvar o resultado em mais de um destino. instru\u00e7\u00e3o add, soma o primeiro valor ao segundo valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: D = RAM[A]+D addw ( % A ), % D , % D","title":"ADD - Adi\u00e7\u00e3o de Inteiros"},{"location":"Util-Resumo-Assembly/#sub-subtracao-de-inteiros","text":"subw reg/mem, rem/mem/im*, reg/mem {, reg/mem, reg/mem} A instru\u00e7\u00e3o sub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = D - RAM[A] subw % D , ( % A ), % A","title":"SUB - Subtra\u00e7\u00e3o de Inteiros"},{"location":"Util-Resumo-Assembly/#rsub-subtracao-de-inteiros-reversa","text":"rsubw reg/mem/im*, rem/mem, reg {, reg, reg} A instru\u00e7\u00e3o rsub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = RAM[A] - D rsubw % D , ( % A ), % A","title":"RSUB - Subtra\u00e7\u00e3o de Inteiros Reversa"},{"location":"Util-Resumo-Assembly/#inc-incrementa-inteiro","text":"incw reg Restri\u00e7\u00e3o O destino \u00e9 o pr\u00f3prio registrador! A opera\u00e7\u00e3o n\u00e3o permite salvar em um registrador diferente. Dica Se quiser fazer a opera\u00e7\u00e3o de inc e salvar em outro registrador, pode utilizar a opera\u00e7\u00e3o de addw : ; D = A + 1 addw $ 1 , % A , % D A instru\u00e7\u00e3o inc, adiciona um (1) ao valor do registrador ou mem\u00f3ria. ; Exemplo: D = D + 1 incw % D","title":"INC - Incrementa Inteiro"},{"location":"Util-Resumo-Assembly/#dec-decrementa-inteiro","text":"decw reg A instru\u00e7\u00e3o dec, subtrai um (1) do valor do registrador ou mem\u00f3ria. ; Exemplo: A = A-1 decw % A","title":"DEC - Decrementa Inteiro"},{"location":"Util-Resumo-Assembly/#not-negacao-por-complemento-de-um","text":"notw reg A instru\u00e7\u00e3o not, inverte o valor de cada bit do reg origem, ou seja, se um bit tem valor 0 fica com 1 e vice-versa. ; Exemplo: D = !D notw % D","title":"NOT - Nega\u00e7\u00e3o por Complemento de Um"},{"location":"Util-Resumo-Assembly/#neg-negacao-por-complemento-de-dois","text":"negw reg A instru\u00e7\u00e3o neg, faz o valor ficar negativo, ou seja, um valor de x \u00e9 modificado para -x. ; Exemplo: A = -A negw % A","title":"NEG - Nega\u00e7\u00e3o por Complemento de dois"},{"location":"Util-Resumo-Assembly/#and-operador-e-and","text":"andw reg/mem, rem/mem A instru\u00e7\u00e3o and executa o operador l\u00f3gico E (and). ; Exemplo: D = A&D andw % A , % D , % D","title":"AND - Operador E (and)"},{"location":"Util-Resumo-Assembly/#or-operador-ou-or","text":"orw reg/mem, rem/mem A instru\u00e7\u00e3o or executa o operador l\u00f3gico Ou (or). ; Exemplo: D = RAM[A] | D orw ( % A ), % D , % D","title":"OR - Operador OU (or)"},{"location":"Util-Resumo-Assembly/#jmp-jump","text":"jmp A instru\u00e7\u00e3o jmp executa um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A. jmp","title":"JMP - Jump"},{"location":"Util-Resumo-Assembly/#je-desvia-execucao-se-igual-a-zero","text":"je reg A instru\u00e7\u00e3o je faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for igual a zero. je % D","title":"JE - Desvia Execu\u00e7\u00e3o se Igual a Zero"},{"location":"Util-Resumo-Assembly/#jne-desvia-execucao-se-diferente-de-zero","text":"jne reg A instru\u00e7\u00e3o jne faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for diferente de zero. jne % D","title":"JNE - Desvia Execu\u00e7\u00e3o se Diferente de Zero"},{"location":"Util-Resumo-Assembly/#jg-desvia-execucao-se-maior-que-zero","text":"jg reg A instru\u00e7\u00e3o jg desvia, o fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior que zero. jg % D","title":"JG - Desvia Execu\u00e7\u00e3o se Maior que Zero"},{"location":"Util-Resumo-Assembly/#jge-desvia-execucao-se-maior-igual-a-zero","text":"jge reg A instru\u00e7\u00e3o jge faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior ou igual a zero. jge % D","title":"JGE - Desvia Execu\u00e7\u00e3o se Maior Igual a Zero"},{"location":"Util-Resumo-Assembly/#jl-desvia-execucao-se-menor-que-zero","text":"jl reg A instru\u00e7\u00e3o jl faz desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor que zero. jl % D","title":"JL - Desvia Execu\u00e7\u00e3o se Menor que Zero"},{"location":"Util-Resumo-Assembly/#jle-desvia-execucao-se-menor-igual-a-zero","text":"jle reg A instru\u00e7\u00e3o jle faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor ou igual a zero. jle % D","title":"JLE - Desvia Execu\u00e7\u00e3o se Menor Igual a Zero"},{"location":"Util-Resumo-Assembly/#nop-nao-faz-nada-no-operation","text":"nop A instru\u00e7\u00e3o nop n\u00e3o faz nada, usado para pular um ciclo de execu\u00e7\u00e3o. nop","title":"NOP - N\u00e3o faz nada (No Operation)"},{"location":"Util-Resumo-Assembly/#descricao-detalhada","text":"Formato das Instru\u00e7\u00f5es Em Assembly, codificamos uma instru\u00e7\u00e3o por linha e ela \u00e9 constru\u00edda a partir do mnem\u00f4nico da opera\u00e7\u00e3o e seus argumentos. Al\u00e9m disso, temos marcadores de posi\u00e7\u00e3o (endere\u00e7o usado em desvios), constantes e poss\u00edveis vari\u00e1veis. O formato das instru\u00e7\u00f5es na sintaxe AT&T segue o seguinte formato: mnem\u00f4nico origem, destino Registradores Todos os registradores devem ter como prefixo o sinal de porcentagem '%\\', por exemplo: %A ou %D. Valores Literais Todos os valores literais devem ter como prefixo o sinal de cifr\u00e3o '$\\', por exemplo: $55, $376, sendo o maior valor 2047 (15 bits). Endere\u00e7amento de Mem\u00f3ria Na sintaxe AT&T, a mem\u00f3ria \u00e9 referenciada com par\u00eantese em volta do registrador que armazena o endere\u00e7o: por exemplo (%A). Tamanho dos operadores Algumas instru\u00e7\u00f5es podem trabalhar com diferentes tamanhos de dados, assim as instru\u00e7\u00f5es podem ter um sufixo, informando o tamanho do dado que ir\u00e1 manipular, sendo b (8 bits), w (16 bits) e l (32 bits). Por exemplo: movw $2000, (%A) Instru\u00e7\u00f5es de Transfer\u00eancia de Controle As instru\u00e7\u00f5es de jump, fazem o fluxo do programa desviar de uma posi\u00e7\u00e3o do programa para outra. Para marcar as posi\u00e7\u00f5es no programa, s\u00e3o usados marcadores (labels) que sempre terminam com dois pontos (:). Por exemplo: loop: Registradores virtuais Os s\u00edmbolos R0, ..., R15 s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0, ..., 15 Ponteiros de I/O Os s\u00edmbolos SCREEN e KBD s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 16384 e 24576, respectivamente. Ponteiros de controle da VM Os s\u00edmbolos SP, LCL, ARG, THIS, e THAT s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0-4, respectivamente. Nota\u00e7\u00f5es: im : valor imediato (somente os valores 1, 0 e -1). reg : registrador. mem: mem\u00f3ria, ou seja (%A). Limita\u00e7\u00f5es: A arquitetura n\u00e3o permite somar o valor da mem\u00f3ria apontada por (%A) com o valor de %A, ou de (%A) com (%A), tampouco %A com %A. N\u00e3o \u00e9 poss\u00edvel somar (ou subtrair, se \u00e9 que isso faz sentido) o registrador com o mesmo, por exemplo somar %D com %D. N\u00e3o \u00e9 poss\u00edvel ler e gravar a mem\u00f3ria ao mesmo tempo. Por exemplo, as instru\u00e7\u00f5es abaixo n\u00e3o funcionam no nosso computador: incw (%A); subw (%A),%D,(%A). Observa\u00e7\u00e3o: A linguagem Assembly apresentada \u00e9 especifica para o processador produzido no curso. Embora muito similar a outras usadas em produtos de mercado, as instru\u00e7\u00f5es possuem limita\u00e7\u00f5es inerentes a cada hardware.","title":"Descri\u00e7\u00e3o Detalhada"},{"location":"Util-Resumo-Labs/","text":"Resumo \u00b6 Atual Projeto ID Laborat\u00f3rio Descri\u00e7\u00e3o X - Mundo Real J - VM Translator 17 J VM Translator Lab 1 Tradu\u00e7\u00e3o de vm para nasm I - VM 16 I VM Lab 1 Programas em linguagem VM H - Assembler 15 H Assembler Lab 1 Implementando m\u00e9todos em java G - CPU 14 G CPU Lab 1 F - Assembly 13 F Assembly Lab 3 12 F Assembly Lab 2 11 F Assembly Lab 1 E - Sequencial 10 E Sequencial Lab 1 D - ULA 9 D ULA Lab 1 8 D ULA Lab 2 C - L\u00f3gica Combinacional 7 C L\u00f3gica Combinacional Lab 2 6 C L\u00f3gica Combinacional Lab 1 5 C Combinacional Lab 1 B - CI 4 B CI Lab 2 3 B Lab 1 A - Transistores 2 A Transistores Lab 2 1 A Transistores Lab 1","title":"Resumo"},{"location":"Util-Resumo-Labs/#resumo","text":"Atual Projeto ID Laborat\u00f3rio Descri\u00e7\u00e3o X - Mundo Real J - VM Translator 17 J VM Translator Lab 1 Tradu\u00e7\u00e3o de vm para nasm I - VM 16 I VM Lab 1 Programas em linguagem VM H - Assembler 15 H Assembler Lab 1 Implementando m\u00e9todos em java G - CPU 14 G CPU Lab 1 F - Assembly 13 F Assembly Lab 3 12 F Assembly Lab 2 11 F Assembly Lab 1 E - Sequencial 10 E Sequencial Lab 1 D - ULA 9 D ULA Lab 1 8 D ULA Lab 2 C - L\u00f3gica Combinacional 7 C L\u00f3gica Combinacional Lab 2 6 C L\u00f3gica Combinacional Lab 1 5 C Combinacional Lab 1 B - CI 4 B CI Lab 2 3 B Lab 1 A - Transistores 2 A Transistores Lab 2 1 A Transistores Lab 1","title":"Resumo"},{"location":"Util-Resumo-Projetos/","text":"Resumo \u00b6 Atual Projeto ID Laborat\u00f3rio Descri\u00e7\u00e3o X - Mundo Real J - VM Translator 17 J VM Translator Lab 1 Tradu\u00e7\u00e3o de vm para nasm I - VM 16 I VM Lab 1 Programas em linguagem VM H - Assembler 15 H Assembler Lab 1 Implementando m\u00e9todos em java G - CPU 14 G CPU Lab 1 F - Assembly 13 F Assembly Lab 3 12 F Assembly Lab 2 11 F Assembly Lab 1 E - Sequencial 10 E Sequencial Lab 1 D - ULA 9 D ULA Lab 1 8 D ULA Lab 2 C - L\u00f3gica Combinacional 7 C L\u00f3gica Combinacional Lab 2 6 C L\u00f3gica Combinacional Lab 1 5 C Combinacional Lab 1 B - CI 4 B CI Lab 2 3 B Lab 1 A - Transistores 2 A Transistores Lab 2 1 A Transistores Lab 1","title":"Resumo"},{"location":"Util-Resumo-Projetos/#resumo","text":"Atual Projeto ID Laborat\u00f3rio Descri\u00e7\u00e3o X - Mundo Real J - VM Translator 17 J VM Translator Lab 1 Tradu\u00e7\u00e3o de vm para nasm I - VM 16 I VM Lab 1 Programas em linguagem VM H - Assembler 15 H Assembler Lab 1 Implementando m\u00e9todos em java G - CPU 14 G CPU Lab 1 F - Assembly 13 F Assembly Lab 3 12 F Assembly Lab 2 11 F Assembly Lab 1 E - Sequencial 10 E Sequencial Lab 1 D - ULA 9 D ULA Lab 1 8 D ULA Lab 2 C - L\u00f3gica Combinacional 7 C L\u00f3gica Combinacional Lab 2 6 C L\u00f3gica Combinacional Lab 1 5 C Combinacional Lab 1 B - CI 4 B CI Lab 2 3 B Lab 1 A - Transistores 2 A Transistores Lab 2 1 A Transistores Lab 1","title":"Resumo"},{"location":"Util-Resumo-VM/","text":"Linguagem VM \u00b6 Nota\u00e7\u00e3o \u00b6 Pilha : Local onde a opera\u00e7\u00e3o \u00e9 executada Primeiro endere\u00e7o : Dado no topo da pilha Segundo endere\u00e7o : Segundo dado no topo da pilha Stack Pointer : Ponteiro para o endere\u00e7o do dado no topo da pilha ... ... X <- Segundo Valor Y <- Primeiro Valor SP -> Opera\u00e7\u00e3o Argumentos retorno Descri\u00e7\u00e3o add : Adi\u00e7\u00e3o X, Y X X = X + Y sub : Subtra\u00e7\u00e3o X, Y X X = X - Y neg : Nega\u00e7\u00e3o Y Y Y = - Y not : Not bit a bit Y Y Y = ! Y and : And bit a bit X, Y X X = X and Y or : Or bit a bit X, Y X X = X or Y eq : Equal X, Y X X = True if X = Y else False gt : Greater Than X, Y X X = True if X > Y else False lt : Less Than X, Y X X = True if X < Y else False Opera\u00e7\u00f5es \u00b6 add - Adi\u00e7\u00e3o \u00b6 add X = X + Y A opera\u00e7\u00e3o add adiciona dois valores da pilha, e retorna o resultado no local do segundo valor. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X+Y Y | SP -> SP -> | sub - Subtra\u00e7\u00e3o \u00b6 sub X = X-Y A opera\u00e7\u00e3o sub subtrai dois valores da pilha, e retorna o resultado no local do segundo valor. neg - Nega\u00e7\u00e3o \u00b6 neg Y = -Y A opera\u00e7\u00e3o neg nega (complemento de dois) o valor no topo da pilha, e retorna o resultado no mesmo local. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X Y | -Y SP -> | SP -> not - not bit a bit \u00b6 and Y = !Y A opera\u00e7\u00e3o not inverte (bit a bit) o valor no topo da pilha, e retorna o resultado no mesmo local. or - Or bit a bit \u00b6 or Y = X or Y A opera\u00e7\u00e3o or aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o. and - and bit a bit \u00b6 and Y = X and Y A opera\u00e7\u00e3o and aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o. eq - Equal \u00b6 eq X = True se X==Y ou False A opera\u00e7\u00e3o eq verifica se os dois valores no topo da pilha s\u00e3o iguais, re retorna o resultado (True ou False) no segundo valor da pilha. True/false 'True' \u00e9 representando por todos os bits em '1': '0xFFFF' 'False' \u00e9 representando por todos os bits em '0': 0x0000' Pilha Essa opera\u00e7\u00e3o consume os dois valores da pilha, veja exemplo. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | True/False Y | SP -> SP -> | gt - Greater Than \u00b6 gt X = True se X>Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 maior que o anterior, retorna o resultado (True ou False) no segundo valor da pilha. lt - Less Than \u00b6 lt X = True se X<Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 menor que o anterior, retorna o resultado (True ou False) no segundo valor da pilha. Label \u00b6 Labels s\u00e3o definidos pelo keyword label seguido de seu nome : label nome S\u00e3o utilizados para endere\u00e7ar o c\u00f3digo em uma condi\u00e7\u00e3o de goto. Goto \u00b6 Existem dois tipos de GOTO, condicional ( if-goto ) e incondicional ( goto ). No condicional o salto \u00e9 realizado caso a condi\u00e7\u00e3o n\u00e3o for Falsa (verifica sempre o \u00faltimo valor da pilha). goto nome if-goto nome Fun\u00e7\u00e3o \u00b6 A seguir defini\u00e7\u00f5es de fun\u00e7\u00f5es: Declara\u00e7\u00e3o de fun\u00e7\u00e3o \u00b6 Uma fun\u00e7\u00e3o \u00e9 definida pelo keyword function seguido do seu nome e quantidade de vari\u00e1veis locais n na estrutura a seguir : function nome n Toda fun\u00e7\u00e3o em VM deve possuir um retorno, definido pelo keyword return Exemplo declara\u00e7\u00e3o de fun\u00e7\u00e3o funcion add 2 push argument 0 push argument 1 add Chamada de fun\u00e7\u00e3o \u00b6 Uma fun\u00e7\u00e3o em VM \u00e9 chamada pelo keyword: call seguido do nome da fun\u00e7\u00e3o e da quantidade m de par\u00e2metros passados para essa fun\u00e7\u00e3o. call nome m Exemplo chamada de fun\u00e7\u00e3o push constant 3 push constant 2 call m ult 2 Par\u00e2metros \u00b6 Os par\u00e2metros de uma fun\u00e7\u00e3o s\u00e3o passados na pr\u00f3pria pilha.","title":"Resumo VM"},{"location":"Util-Resumo-VM/#linguagem-vm","text":"","title":"Linguagem VM"},{"location":"Util-Resumo-VM/#notacao","text":"Pilha : Local onde a opera\u00e7\u00e3o \u00e9 executada Primeiro endere\u00e7o : Dado no topo da pilha Segundo endere\u00e7o : Segundo dado no topo da pilha Stack Pointer : Ponteiro para o endere\u00e7o do dado no topo da pilha ... ... X <- Segundo Valor Y <- Primeiro Valor SP -> Opera\u00e7\u00e3o Argumentos retorno Descri\u00e7\u00e3o add : Adi\u00e7\u00e3o X, Y X X = X + Y sub : Subtra\u00e7\u00e3o X, Y X X = X - Y neg : Nega\u00e7\u00e3o Y Y Y = - Y not : Not bit a bit Y Y Y = ! Y and : And bit a bit X, Y X X = X and Y or : Or bit a bit X, Y X X = X or Y eq : Equal X, Y X X = True if X = Y else False gt : Greater Than X, Y X X = True if X > Y else False lt : Less Than X, Y X X = True if X < Y else False","title":"Nota\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#operacoes","text":"","title":"Opera\u00e7\u00f5es"},{"location":"Util-Resumo-VM/#add-adicao","text":"add X = X + Y A opera\u00e7\u00e3o add adiciona dois valores da pilha, e retorna o resultado no local do segundo valor. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X+Y Y | SP -> SP -> |","title":"add - Adi\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#sub-subtracao","text":"sub X = X-Y A opera\u00e7\u00e3o sub subtrai dois valores da pilha, e retorna o resultado no local do segundo valor.","title":"sub - Subtra\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#neg-negacao","text":"neg Y = -Y A opera\u00e7\u00e3o neg nega (complemento de dois) o valor no topo da pilha, e retorna o resultado no mesmo local. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X Y | -Y SP -> | SP ->","title":"neg - Nega\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#not-not-bit-a-bit","text":"and Y = !Y A opera\u00e7\u00e3o not inverte (bit a bit) o valor no topo da pilha, e retorna o resultado no mesmo local.","title":"not - not bit a bit"},{"location":"Util-Resumo-VM/#or-or-bit-a-bit","text":"or Y = X or Y A opera\u00e7\u00e3o or aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o.","title":"or - Or bit a bit"},{"location":"Util-Resumo-VM/#and-and-bit-a-bit","text":"and Y = X and Y A opera\u00e7\u00e3o and aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o.","title":"and - and bit a bit"},{"location":"Util-Resumo-VM/#eq-equal","text":"eq X = True se X==Y ou False A opera\u00e7\u00e3o eq verifica se os dois valores no topo da pilha s\u00e3o iguais, re retorna o resultado (True ou False) no segundo valor da pilha. True/false 'True' \u00e9 representando por todos os bits em '1': '0xFFFF' 'False' \u00e9 representando por todos os bits em '0': 0x0000' Pilha Essa opera\u00e7\u00e3o consume os dois valores da pilha, veja exemplo. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | True/False Y | SP -> SP -> |","title":"eq - Equal"},{"location":"Util-Resumo-VM/#gt-greater-than","text":"gt X = True se X>Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 maior que o anterior, retorna o resultado (True ou False) no segundo valor da pilha.","title":"gt - Greater Than"},{"location":"Util-Resumo-VM/#lt-less-than","text":"lt X = True se X<Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 menor que o anterior, retorna o resultado (True ou False) no segundo valor da pilha.","title":"lt - Less Than"},{"location":"Util-Resumo-VM/#label","text":"Labels s\u00e3o definidos pelo keyword label seguido de seu nome : label nome S\u00e3o utilizados para endere\u00e7ar o c\u00f3digo em uma condi\u00e7\u00e3o de goto.","title":"Label"},{"location":"Util-Resumo-VM/#goto","text":"Existem dois tipos de GOTO, condicional ( if-goto ) e incondicional ( goto ). No condicional o salto \u00e9 realizado caso a condi\u00e7\u00e3o n\u00e3o for Falsa (verifica sempre o \u00faltimo valor da pilha). goto nome if-goto nome","title":"Goto"},{"location":"Util-Resumo-VM/#funcao","text":"A seguir defini\u00e7\u00f5es de fun\u00e7\u00f5es:","title":"Fun\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#declaracao-de-funcao","text":"Uma fun\u00e7\u00e3o \u00e9 definida pelo keyword function seguido do seu nome e quantidade de vari\u00e1veis locais n na estrutura a seguir : function nome n Toda fun\u00e7\u00e3o em VM deve possuir um retorno, definido pelo keyword return Exemplo declara\u00e7\u00e3o de fun\u00e7\u00e3o funcion add 2 push argument 0 push argument 1 add","title":"Declara\u00e7\u00e3o de fun\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#chamada-de-funcao","text":"Uma fun\u00e7\u00e3o em VM \u00e9 chamada pelo keyword: call seguido do nome da fun\u00e7\u00e3o e da quantidade m de par\u00e2metros passados para essa fun\u00e7\u00e3o. call nome m Exemplo chamada de fun\u00e7\u00e3o push constant 3 push constant 2 call m ult 2","title":"Chamada de fun\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#parametros","text":"Os par\u00e2metros de uma fun\u00e7\u00e3o s\u00e3o passados na pr\u00f3pria pilha.","title":"Par\u00e2metros"},{"location":"Util-Status-Travis-Grupos/","text":"GRUPO A B C D E F G H I","title":"Util Status Travis Grupos"},{"location":"Util-VM-Linux/","text":"Boot SSD via VirtualBox \u00b6 Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Windows 10 (mas com o devido cuidado funciona no Mac OS e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive, se sim, ejete ele no Windows Explorer. Conecte o HD Externo de tipo A (MBR) no Windows, neste momento dever\u00e1 aparecer uma mensagem dizendo para formatar a unidade para poder utiliza-la, clique em N\u00e3o. Agora, abra o Painel de Controle, procure por Ferramentas Administrativas e em seguida Gerenciamento do Computador (Cuidado para n\u00e3o confundir com Gerenciador de Dispositivos!). Agora no menu lateral, procure por Gerenciamento de Discos, na parte central, voc\u00ea deve ser capaz de ver o seu HD e o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Com foco no HD Externo e procure pelo n\u00famero do Disco (geralmente fica na parte inferior em baixo do nome, no gr\u00e1fico de barras). Deve haver algo como Disco 2 ou Disco 1 . Agora, abra uma Linha de Comando como Administrador (bot\u00e3o direito, e executar como Administrador). Navegue at\u00e9 a pasta do VirtualBox em C:\\Program Files\\Oracle\\VirtualBox e execute o seguinte comando, substituindo o N pelo n\u00famero de disco corresponde visto anteriormente (deve-se manter o \\.\\PhysicalDrive). VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk \\\\.\\PhysicalDriveN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Windows. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Procure qualquer atalho ou no menu Iniciar pelo VirtualBox e clique com bot\u00e3o direito e Executar como Administrador. Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert, de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para C:\\Users\\SEU_USUARIO\\VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Boot SSD via VirtualBox"},{"location":"Util-VM-Linux/#boot-ssd-via-virtualbox","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Windows 10 (mas com o devido cuidado funciona no Mac OS e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive, se sim, ejete ele no Windows Explorer. Conecte o HD Externo de tipo A (MBR) no Windows, neste momento dever\u00e1 aparecer uma mensagem dizendo para formatar a unidade para poder utiliza-la, clique em N\u00e3o. Agora, abra o Painel de Controle, procure por Ferramentas Administrativas e em seguida Gerenciamento do Computador (Cuidado para n\u00e3o confundir com Gerenciador de Dispositivos!). Agora no menu lateral, procure por Gerenciamento de Discos, na parte central, voc\u00ea deve ser capaz de ver o seu HD e o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Com foco no HD Externo e procure pelo n\u00famero do Disco (geralmente fica na parte inferior em baixo do nome, no gr\u00e1fico de barras). Deve haver algo como Disco 2 ou Disco 1 . Agora, abra uma Linha de Comando como Administrador (bot\u00e3o direito, e executar como Administrador). Navegue at\u00e9 a pasta do VirtualBox em C:\\Program Files\\Oracle\\VirtualBox e execute o seguinte comando, substituindo o N pelo n\u00famero de disco corresponde visto anteriormente (deve-se manter o \\.\\PhysicalDrive). VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk \\\\.\\PhysicalDriveN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Windows. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Procure qualquer atalho ou no menu Iniciar pelo VirtualBox e clique com bot\u00e3o direito e Executar como Administrador. Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert, de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para C:\\Users\\SEU_USUARIO\\VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Boot SSD via VirtualBox"},{"location":"Util-VM-MAC/","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Mac OS Mojave (mas com o devido cuidado funciona no Windows e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive ou instalador montado (mostrando como unidade), se sim, ejete eles no Finder. Conecte o HD Externo de tipo A (MBR) no Mac OS, neste momento dever\u00e1 aparecer uma mensagem dizendo que o Mac OS n\u00e3o \u00e9 capaz de ler o disco, aten\u00e7\u00e3o, voc\u00ea deve clicar no bot\u00e3o 'Ignorar' Agora, abra o Disk Utility (Utilit\u00e1rio de Disco), ele pode ser encontrado pelo Spotlight ou pelo Launchpad, conforme imagem. Clique no bot\u00e3o Visualizar e selecione Mostrar todos os dispositivos . Agora no menu lateral, voc\u00ea deve ser capaz de ver o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Selecione o HD Externo no Disk Utility e nas informa\u00e7\u00f5es exibidas procure por Dispositivo: diskN , sendo que haver\u00e1 um n\u00famero no lugar do N, no caso da foto \u00e9 disk2 . Verifique qual o n\u00famero em seu Mac OS. Agora, abra um Terminal. E execute o seguinte comando, substituindo o diskN pelo disco corresponde visto anteriormente (deve-se manter o /dev/ inicial). Ele ir\u00e1 solicitar a sua senha do Mac OS, por favor digite. sudo VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk /dev/diskN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Mac OS. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Em seguida, no terminal novamente, digite o comando sudo /Applications/VirtualBox.app/Contents/MacOS/VirtualBox Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert , de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para /Users/SEU_USUARIO/VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Util VM MAC"},{"location":"Util-VM-Windows/","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Windows 10 (mas com o devido cuidado funciona no Mac OS e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive, se sim, ejete ele no Windows Explorer. Conecte o HD Externo de tipo A (MBR) no Windows, neste momento dever\u00e1 aparecer uma mensagem dizendo para formatar a unidade para poder utiliza-la, clique em N\u00e3o. Agora, abra o Painel de Controle, procure por Ferramentas Administrativas e em seguida Gerenciamento do Computador (Cuidado para n\u00e3o confundir com Gerenciador de Dispositivos!). Agora no menu lateral, procure por Gerenciamento de Discos, na parte central, voc\u00ea deve ser capaz de ver o seu HD e o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Com foco no HD Externo e procure pelo n\u00famero do Disco (geralmente fica na parte inferior em baixo do nome, no gr\u00e1fico de barras). Deve haver algo como Disco 2 ou Disco 1 . Agora, abra uma Linha de Comando como Administrador (bot\u00e3o direito, e executar como Administrador). Navegue at\u00e9 a pasta do VirtualBox em C:\\Program Files\\Oracle\\VirtualBox e execute o seguinte comando, substituindo o N pelo n\u00famero de disco corresponde visto anteriormente (deve-se manter o \\.\\PhysicalDrive). VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk \\\\.\\PhysicalDriveN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Windows. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Procure qualquer atalho ou no menu Iniciar pelo VirtualBox e clique com bot\u00e3o direito e Executar como Administrador. Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert, de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para C:\\Users\\SEU_USUARIO\\VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Util VM Windows"},{"location":"Util-Video-Aulas/","text":"Material desenvolvido pelo Prof. Luciano Soares no ano de 2017, pode ser utilizado para estudar! Conte\u00fado de \u00c1lgebra Booleana https://www.youtube.com/watch?v=YYIucfsQKl4 Conte\u00fado Transistores https://www.youtube.com/watch?v=rRg9wdzlPvE Conte\u00fado sobre Circuitos Integrados https://www.youtube.com/watch?v=zX36rn_lIl0 Conte\u00fado sobre L\u00f3gica Combinacional https://www.youtube.com/watch?v=ImFt9YjEHHc Conte\u00fado Dados Digitais https://www.youtube.com/watch?v=dVixMB1uSYA Conte\u00fado de Unidade L\u00f3gica Aritm\u00e9tica https://www.youtube.com/watch?v=zRX3sOtjS10 Conte\u00fado de L\u00f3gica Sequencial https://www.youtube.com/watch?v=lNW2d26S-gI Conte\u00fado de Mem\u00f3rias https://www.youtube.com/watch?v=CAw-cQUZO_g Conte\u00fado de L\u00f3gica de Controle https://www.youtube.com/watch?v=eEXI72tztws Conte\u00fado Linguagem de M\u00e1quina https://www.youtube.com/watch?v=_MhpD0Geqlk Conte\u00fado Assembly https://www.youtube.com/watch?v=xABQNUe3hG0 Conte\u00fado Computador https://www.youtube.com/watch?v=uVgqGkz106Q Conte\u00fado Assembler https://www.youtube.com/watch?v=xFBPHkaFIlk Conte\u00fado M\u00e1quina Virtual https://www.youtube.com/watch?v=U9DRGBVp8Eg Conte\u00fado Pilhas https://www.youtube.com/watch?v=5N0rTGZHdwY Conte\u00fado de Controle https://www.youtube.com/watch?v=Hp4ZwLMvYfg Conte\u00fado Linguagem de Alto N\u00edvel https://www.youtube.com/watch?v=YZucTUVv-n8 Conte\u00fado Linguagem Orientada a Objetos https://www.youtube.com/watch?v=-9Fj-ShFV_8 Conte\u00fado An\u00e1lise L\u00e9xica e Sint\u00e1tica https://www.youtube.com/watch?v=rtHxrs6TC6Y Programa\u00e7\u00e3o de FPGA pelo Quartus https://www.youtube.com/watch?v=QuH2pduAs34 Exemplo MuxVHDLQuartus https://www.youtube.com/watch?v=m3B8Yob3xkE Gravando e atualizando dados numa mem\u00f3ria de uma FPGA pelo Quartus https://www.youtube.com/watch?v=zb4taQX4yL8","title":"V\u00eddeo Aulas (Luciano)"},{"location":"Util-Z01.1-Cheat-Sheet/","text":"","title":"Z01.1 Cheat Sheet"},{"location":"Util-online/","text":"On-line - Corona \u00b6 Elementos de Sistemas n\u00e3o sofrer\u00e1 grandes mudan\u00e7as, continuaremos com as din\u00e2micas atuais de aula: Teoria passada antes da aula por material no site da disciplina (V\u00eddeos + Texto + Livros + Links) As entregas de projetos semanais se mant\u00e9m (um facilitador por projeto) S\u00f3 n\u00e3o teremos mais a FPGA, algumas rubricas de projetos ter\u00e3o que ser adequadas. Avalia\u00e7\u00e3o: (se mant\u00e9m) 4 Provas Provas 100% remotas Devem acumular 60 pts de HW e 60 pts de SW Devem possuir no m\u00ednimo C em todos os projetos Nota individual / Grupo vamos mudar como a nota de participa\u00e7\u00e3o individual \u00e9 atribu\u00edda, na quarta eu informo voc\u00eas. Note Vai come\u00e7ar valer s\u00f3 no pr\u00f3ximo projeto! Calend\u00e1rio \u00b6 Atendimento Segunda (se mant\u00e9m \u00e0s 12h) Quarta feira ser\u00e1 aula \"normal\" (no teams), irei trazer uma atividade para fazermos. AV1 adiada para Sexta - 27/3 Projeto C adiado para Ter\u00e7a - 31/3 Ferramentas \u00b6 Microsoft teams (precisa instalar) Temos uma sala l\u00e1, chamada de 3s-Elementos Cada grupo ter\u00e1 uma sala Eu irei acabar com o Travis para n\u00e3o termos uma ferramenta concorrendo com outro. Plugin no vs code: live share","title":"On-line - Corona :tangerine:"},{"location":"Util-online/#on-line-corona","text":"Elementos de Sistemas n\u00e3o sofrer\u00e1 grandes mudan\u00e7as, continuaremos com as din\u00e2micas atuais de aula: Teoria passada antes da aula por material no site da disciplina (V\u00eddeos + Texto + Livros + Links) As entregas de projetos semanais se mant\u00e9m (um facilitador por projeto) S\u00f3 n\u00e3o teremos mais a FPGA, algumas rubricas de projetos ter\u00e3o que ser adequadas. Avalia\u00e7\u00e3o: (se mant\u00e9m) 4 Provas Provas 100% remotas Devem acumular 60 pts de HW e 60 pts de SW Devem possuir no m\u00ednimo C em todos os projetos Nota individual / Grupo vamos mudar como a nota de participa\u00e7\u00e3o individual \u00e9 atribu\u00edda, na quarta eu informo voc\u00eas. Note Vai come\u00e7ar valer s\u00f3 no pr\u00f3ximo projeto!","title":"On-line - Corona"},{"location":"Util-online/#calendario","text":"Atendimento Segunda (se mant\u00e9m \u00e0s 12h) Quarta feira ser\u00e1 aula \"normal\" (no teams), irei trazer uma atividade para fazermos. AV1 adiada para Sexta - 27/3 Projeto C adiado para Ter\u00e7a - 31/3","title":"Calend\u00e1rio"},{"location":"Util-online/#ferramentas","text":"Microsoft teams (precisa instalar) Temos uma sala l\u00e1, chamada de 3s-Elementos Cada grupo ter\u00e1 uma sala Eu irei acabar com o Travis para n\u00e3o termos uma ferramenta concorrendo com outro. Plugin no vs code: live share","title":"Ferramentas"},{"location":"Util-vixi-sou-scrum/","text":"Vixi! Sou scrum master \u00b6 Passos Voc\u00ea \u00e9 o mediador (Scrum Master) do projeto e n\u00e3o sabe por onde come\u00e7ar? A seguir os passos que devem ser realizados! Merge dos reposit\u00f3rios Editar SCRUM_MASTER.json com suas informa\u00e7\u00f5es Ler documenta\u00e7\u00e3o do projeto Configurar Actions para executar teste do projeto Criar issues no github (detalhes ao final dessa p\u00e1gina) Discuta com os seus colegas Acompanhe o grupo ajudando o pessoal trabalhar, seu papel \u00e9 entregar!! no prazo!!! Na entrega do projeto, todos os issues devem ter sido resolvidos (e arquivados). Todos as tarefas devem ser movidas para done no projects. Com o projeto finalizado: Criar uma tag no git para marcar o commit que tudo funciona, exemplo: git tag Projeto-C + git push --tag Preencher formul\u00e1rio Adicionando issues \u00b6 Tip Os issues devem ser todos os m\u00f3dulos a serem implementados do projeto. Voc\u00ea deve manter o quadro atualizado.","title":"Vixi! Sou scrum master"},{"location":"Util-vixi-sou-scrum/#vixi-sou-scrum-master","text":"Passos Voc\u00ea \u00e9 o mediador (Scrum Master) do projeto e n\u00e3o sabe por onde come\u00e7ar? A seguir os passos que devem ser realizados! Merge dos reposit\u00f3rios Editar SCRUM_MASTER.json com suas informa\u00e7\u00f5es Ler documenta\u00e7\u00e3o do projeto Configurar Actions para executar teste do projeto Criar issues no github (detalhes ao final dessa p\u00e1gina) Discuta com os seus colegas Acompanhe o grupo ajudando o pessoal trabalhar, seu papel \u00e9 entregar!! no prazo!!! Na entrega do projeto, todos os issues devem ter sido resolvidos (e arquivados). Todos as tarefas devem ser movidas para done no projects. Com o projeto finalizado: Criar uma tag no git para marcar o commit que tudo funciona, exemplo: git tag Projeto-C + git push --tag Preencher formul\u00e1rio","title":"Vixi! Sou scrum master"},{"location":"Util-vixi-sou-scrum/#adicionando-issues","text":"Tip Os issues devem ser todos os m\u00f3dulos a serem implementados do projeto. Voc\u00ea deve manter o quadro atualizado.","title":"Adicionando issues"},{"location":"VHDL-Combinacional/","text":"Combinacional \u00b6 Em sistemas digitais, l\u00f3gica combinacional \u00e9 aquela que n\u00e3o depende do estado anterior (n\u00e3o possui mem\u00f3ria), podemos classificar portas l\u00f3gicas (and, or, nand ...), mux, demux, comparadores, full address e outros componentes como sendo do tipo combinacional. Note Logic is combinational if outputs at a specified time are a function only of the inputs at that time. Examples of combinational logic functions are decoders, multiplexers, and adders. ... Trecho extra\u00eddo do site da intel VHDL \u00b6 Existem duas formas de descrevermos um circuito combinacional em VHDL, uma delas \u00e9 utilizando o process , n\u00e3o iremos tratar dessa alternativa nesse documento. Note O uso de process pode confundir voc\u00eas nesse primeiro momento, por parecer um fun\u00e7\u00e3o de um programa sequ\u00eancial. Para transcrevermos uma l\u00f3gica combinacional em VHDL basta escrever a implementa\u00e7\u00e3o Equa\u00e7\u00f5es \u00b6 Podemos escrever equa\u00e7\u00f5es em VHDL utilizando os seguintes operadores: not , and , or , nor , xor , xnor . Como no exemplo a seguir: \\(X = (\\bar{A} . B) + C)\\) Transcrevemos para: X <= (( not A ) and B ) or C ; Tip Abuse dos parenteses () para explicitar a l\u00f3gica desejada, por exemplo: not A and B ---> not (A and B) \\ \\-> (not A) and B Tip Quando desenvolvemos projetos para FPGA n\u00e3o tem a necessidade de simplificarmos a equa\u00e7\u00e3o l\u00f3gica, a ferramenta ( Quartus ) faz isso para a gente. Concatenate \u00b6 Em VHDL podemos concatenar bit para formar vetores, isso \u00e9 feito da seguinte forma: signal bit0 , bit1 : std_logic ; signal vec : std_logic_vector ( 1 downto 0 ); begin vec <= bit1 & bit0 ; end ; No exemplo anterior, temos um vetor de 2 bits ( vec ) que \u00e9 formado por: [bit1, bit0] . with select \u00b6 https://insights.sigasi.com/tech/signal-assignments-vhdl-withselect-whenelse-and-case/ O with select em VHDL \u00e9 utilizado quando desejamos que um sinal (ou sa\u00edda) receba diferentes valores com base em um sinal de sele\u00e7\u00e3o. No exemplo a seguir, o sinal b recebe o valor 1000 quando o sinal de sele\u00e7\u00e3o a for 00 , 0100 quando a for 01 , ..., note que no \u00faltimo caso usamos o others , ele entrou no lugar do 11 . signal a : std_logic_vector ( 1 downto 0 ); signal b : std_logic_Vector ( 3 downto 0 ); begin with a select b <= \"1000\" when \"00\" , \"0100\" when \"01\" , \"0010\" when \"10\" , \"0001\" when others ; O hardware gerado pela descri\u00e7\u00e3o anterior seria: Warning Utilizar others na \u00faltima op\u00e7\u00e3o! Tip Precisamos lembrar que no final tudo vai virar um hardware, o with \u00e9 normalmente utilizado para implementar um multiplexiador ! Multiplexador when else \u00b6 O construtor when else \u00e9 um pouco mais geral, para cada op\u00e7\u00e3o voc\u00ea pode fornecer uma condi\u00e7\u00e3o diferente. O mesmo exemplo do with ficaria escrito da seguinte maneira: b <= \"1000\" when a = \"00\" else \"0100\" when a = \"01\" else \"0010\" when a = \"10\" else \"0001\" ; Warning A \u00faltima op\u00e7\u00e3o n\u00e3o deve possuir nenhuma condi\u00e7\u00e3o! Por\u00e9m com o when else temos a flexibilidade de realizar algo como: b <= \"1000\" when ( a = \"00\" AND en = '1' ) else \"0100\" when ( a = \"01\" AND en = '1' ) else \"0010\" when ( a = \"10\" AND en = '1' ) else \"0010\" when ( a = \"00\" AND en = '1' ) else \"0000\" ; -- enable desativado Nesse exemplo, temos duas condi\u00e7\u00f5es para cada op\u00e7\u00e3o: a e en devem satisfazer a condi\u00e7\u00e3o, isso n\u00e3o \u00e9 poss\u00edvel com o with select . Note others e else : Precisamos entender que um sinal do tipo std_logic em VHDL n\u00e3o pode assumir apenas os valores 0 e 1 , mas sim: 0 , 1 , X , Z , W , L , H , - , para cobrir todas as op\u00e7\u00f5es (com dois 'bits') dever\u00edamos possuir 64 linhas para cada with ou when que fossemos construir.","title":"Combinacional"},{"location":"VHDL-Combinacional/#combinacional","text":"Em sistemas digitais, l\u00f3gica combinacional \u00e9 aquela que n\u00e3o depende do estado anterior (n\u00e3o possui mem\u00f3ria), podemos classificar portas l\u00f3gicas (and, or, nand ...), mux, demux, comparadores, full address e outros componentes como sendo do tipo combinacional. Note Logic is combinational if outputs at a specified time are a function only of the inputs at that time. Examples of combinational logic functions are decoders, multiplexers, and adders. ... Trecho extra\u00eddo do site da intel","title":"Combinacional"},{"location":"VHDL-Combinacional/#vhdl","text":"Existem duas formas de descrevermos um circuito combinacional em VHDL, uma delas \u00e9 utilizando o process , n\u00e3o iremos tratar dessa alternativa nesse documento. Note O uso de process pode confundir voc\u00eas nesse primeiro momento, por parecer um fun\u00e7\u00e3o de um programa sequ\u00eancial. Para transcrevermos uma l\u00f3gica combinacional em VHDL basta escrever a implementa\u00e7\u00e3o","title":"VHDL"},{"location":"VHDL-Combinacional/#equacoes","text":"Podemos escrever equa\u00e7\u00f5es em VHDL utilizando os seguintes operadores: not , and , or , nor , xor , xnor . Como no exemplo a seguir: \\(X = (\\bar{A} . B) + C)\\) Transcrevemos para: X <= (( not A ) and B ) or C ; Tip Abuse dos parenteses () para explicitar a l\u00f3gica desejada, por exemplo: not A and B ---> not (A and B) \\ \\-> (not A) and B Tip Quando desenvolvemos projetos para FPGA n\u00e3o tem a necessidade de simplificarmos a equa\u00e7\u00e3o l\u00f3gica, a ferramenta ( Quartus ) faz isso para a gente.","title":"Equa\u00e7\u00f5es"},{"location":"VHDL-Combinacional/#concatenate","text":"Em VHDL podemos concatenar bit para formar vetores, isso \u00e9 feito da seguinte forma: signal bit0 , bit1 : std_logic ; signal vec : std_logic_vector ( 1 downto 0 ); begin vec <= bit1 & bit0 ; end ; No exemplo anterior, temos um vetor de 2 bits ( vec ) que \u00e9 formado por: [bit1, bit0] .","title":"Concatenate"},{"location":"VHDL-Combinacional/#with-select","text":"https://insights.sigasi.com/tech/signal-assignments-vhdl-withselect-whenelse-and-case/ O with select em VHDL \u00e9 utilizado quando desejamos que um sinal (ou sa\u00edda) receba diferentes valores com base em um sinal de sele\u00e7\u00e3o. No exemplo a seguir, o sinal b recebe o valor 1000 quando o sinal de sele\u00e7\u00e3o a for 00 , 0100 quando a for 01 , ..., note que no \u00faltimo caso usamos o others , ele entrou no lugar do 11 . signal a : std_logic_vector ( 1 downto 0 ); signal b : std_logic_Vector ( 3 downto 0 ); begin with a select b <= \"1000\" when \"00\" , \"0100\" when \"01\" , \"0010\" when \"10\" , \"0001\" when others ; O hardware gerado pela descri\u00e7\u00e3o anterior seria: Warning Utilizar others na \u00faltima op\u00e7\u00e3o! Tip Precisamos lembrar que no final tudo vai virar um hardware, o with \u00e9 normalmente utilizado para implementar um multiplexiador ! Multiplexador","title":"with select"},{"location":"VHDL-Combinacional/#when-else","text":"O construtor when else \u00e9 um pouco mais geral, para cada op\u00e7\u00e3o voc\u00ea pode fornecer uma condi\u00e7\u00e3o diferente. O mesmo exemplo do with ficaria escrito da seguinte maneira: b <= \"1000\" when a = \"00\" else \"0100\" when a = \"01\" else \"0010\" when a = \"10\" else \"0001\" ; Warning A \u00faltima op\u00e7\u00e3o n\u00e3o deve possuir nenhuma condi\u00e7\u00e3o! Por\u00e9m com o when else temos a flexibilidade de realizar algo como: b <= \"1000\" when ( a = \"00\" AND en = '1' ) else \"0100\" when ( a = \"01\" AND en = '1' ) else \"0010\" when ( a = \"10\" AND en = '1' ) else \"0010\" when ( a = \"00\" AND en = '1' ) else \"0000\" ; -- enable desativado Nesse exemplo, temos duas condi\u00e7\u00f5es para cada op\u00e7\u00e3o: a e en devem satisfazer a condi\u00e7\u00e3o, isso n\u00e3o \u00e9 poss\u00edvel com o with select . Note others e else : Precisamos entender que um sinal do tipo std_logic em VHDL n\u00e3o pode assumir apenas os valores 0 e 1 , mas sim: 0 , 1 , X , Z , W , L , H , - , para cobrir todas as op\u00e7\u00f5es (com dois 'bits') dever\u00edamos possuir 64 linhas para cada with ou when que fossemos construir.","title":"when else"},{"location":"VHDL-RTL/","text":"RTL Viewer \u00b6 RTL \u00e9 uma forma de visualiza\u00e7\u00e3o de um circuito digital. Ela nos ajudar\u00e1 a entender o circuito que foi escrito em HDL. Muitas vezes a pr\u00f3pria ferramenta n\u00e3o compreende o hardware que desejamos descrever (lembre que HDL \u00e9 uma linguagem de descri\u00e7\u00e3o de hardware, n\u00e3o de programa\u00e7\u00e3o). Com o RTL conseguimos ter uma no\u00e7\u00e3o de qual foi a 'interpreta\u00e7\u00e3o' do nosso hardware que a ferramenta (no caso o Quartus) entendeu. O RTL Viewer \u00e9 uma ferramenta do Quartus utilizada para visualizar o RTL (interpreta\u00e7\u00e3o do hardware descrito em HDL). Para criarmos esse RTL de um m\u00f3dulo espec\u00edfico devemos no Quartus selecionar o componente em quest\u00e3o como TopLevel , para isso fa\u00e7a o seguinte: Example Exemplo para o projeto D, mas se aplica a qualquer outro! Abra o projeto no Quartus localizado em D-LogicaSequencial/Quartus/ No Project Navigator escolha por Files : Encontre o arquivo que deseja configurar como TopLevel : Clique com o bot\u00e3o direito no arquivo e selecione a op\u00e7\u00e3o: Set as Top Level Entity Agora o Quartus ir\u00e1 enterpretar esse m\u00f3dulo como sendo o \"top\" do projeto (podemos pensar como sendo o main ). Compile o Projeto ( Processing -> Start ) Abra o RTL Viewer ( Tools -> NetList Viewers -> RTL Viewer ) Esse c\u00f3digo em VHDL ir\u00e1 ser interpretada pelo compilador como um FlipFlop tipo D.","title":"RTL Viewer"},{"location":"VHDL-RTL/#rtl-viewer","text":"RTL \u00e9 uma forma de visualiza\u00e7\u00e3o de um circuito digital. Ela nos ajudar\u00e1 a entender o circuito que foi escrito em HDL. Muitas vezes a pr\u00f3pria ferramenta n\u00e3o compreende o hardware que desejamos descrever (lembre que HDL \u00e9 uma linguagem de descri\u00e7\u00e3o de hardware, n\u00e3o de programa\u00e7\u00e3o). Com o RTL conseguimos ter uma no\u00e7\u00e3o de qual foi a 'interpreta\u00e7\u00e3o' do nosso hardware que a ferramenta (no caso o Quartus) entendeu. O RTL Viewer \u00e9 uma ferramenta do Quartus utilizada para visualizar o RTL (interpreta\u00e7\u00e3o do hardware descrito em HDL). Para criarmos esse RTL de um m\u00f3dulo espec\u00edfico devemos no Quartus selecionar o componente em quest\u00e3o como TopLevel , para isso fa\u00e7a o seguinte: Example Exemplo para o projeto D, mas se aplica a qualquer outro! Abra o projeto no Quartus localizado em D-LogicaSequencial/Quartus/ No Project Navigator escolha por Files : Encontre o arquivo que deseja configurar como TopLevel : Clique com o bot\u00e3o direito no arquivo e selecione a op\u00e7\u00e3o: Set as Top Level Entity Agora o Quartus ir\u00e1 enterpretar esse m\u00f3dulo como sendo o \"top\" do projeto (podemos pensar como sendo o main ). Compile o Projeto ( Processing -> Start ) Abra o RTL Viewer ( Tools -> NetList Viewers -> RTL Viewer ) Esse c\u00f3digo em VHDL ir\u00e1 ser interpretada pelo compilador como um FlipFlop tipo D.","title":"RTL Viewer"},{"location":"VHDL-Sequencial/","text":"Sequencial \u00b6 Como trabalhar com l\u00f3gica sequ\u00eancia em VHDL Process VHDL \u00b6 Em VHDL quando desejamos fazer algo sequencial \u00e9 necess\u00e1rio usarmos uma estrutura chamada de process, que possui a declara\u00e7\u00e3o a seguir: process ( optional sensitivity list ) declarations begin sequential statements end process ; Nesse process possu\u00edmos a lista de sensibilidade ( sensitivity list ) que indica quando o process ser\u00e1 executado. Podemos pensar da seguinte maneira, sempre que algum sinal que est\u00e1 listado nessa lista de sensibilidade mudar de valor ( 0 -> 1 , 1 -> 0 ) o processo ser\u00e1 executado. Vamos ver o exemplo a seguir: process ( A ) begin Q <= A ; end process ; Entendendo Sempre que o sinal A (sinal ou porta) alterar de valor o sinal Q ser\u00e1 atribu\u00eddo com o seu valor Agora vamos criar um outro processo ( esse estar\u00e1 errado ): process ( A ) begin Q <= A and B ; end process ; A ideia por traz desse processo seria que o sinal Q receba o sinal A e B sempre que algum dos dois sofram alguma altera\u00e7\u00e3o, por\u00e9m essa implementa\u00e7\u00e3o n\u00e3o ir\u00e1 funcionar j\u00e1 que B n\u00e3o faz parte da lista de sensibilidade e se B mudar de valor o processo n\u00e3o ser\u00e1 chamado, o sinal Q s\u00f3 ser\u00e1 atualizado quando A mudar de valor. Tarefa Reescreva no codeshare do grupo o m\u00f3dulo anterior corrigido. Chame um professor para validar! Clock \u00b6 Para inserirmos um clock (um sistema s\u00edncrono) precisamos necessariamente usar um process , e a arquitetura \u00e9 a seguinte: process ( clock ) begin if ( rising_edge ( clock )) then Q <= D ; end if ; end process ; Sempre que o clock sofrer varia\u00e7\u00e3o ( 0 -> 1 , 1 -> 0 ) o process \u00e9 chamado e verifica-se se a transi\u00e7\u00e3o foi de borda de subida ( rising_edge ) se for, atribui o sinal A ao sinal Q, caso contr\u00e1rio Q mant\u00e9m seu \u00faltimo valor. Note Em FPGA um sinal digital n\u00e3o deve sofrer atualiza\u00e7\u00e3o em ambas as bordas: subida ( rising_edge ) e de descida ( falling_edge ) pois n\u00e3o ser\u00e1 suportado por hardware . Salvo em registradores DDR (double data rate) especiais, exemplo do que n\u00e3o deve ser feito!: process ( clock ) begin if ( rising_edge ( clock )) then Q <= D ; elsif ( falling_edge ( clock )) then Q <= D ; end if ; end process ;","title":"Sequencial"},{"location":"VHDL-Sequencial/#sequencial","text":"Como trabalhar com l\u00f3gica sequ\u00eancia em VHDL","title":"Sequencial"},{"location":"VHDL-Sequencial/#process-vhdl","text":"Em VHDL quando desejamos fazer algo sequencial \u00e9 necess\u00e1rio usarmos uma estrutura chamada de process, que possui a declara\u00e7\u00e3o a seguir: process ( optional sensitivity list ) declarations begin sequential statements end process ; Nesse process possu\u00edmos a lista de sensibilidade ( sensitivity list ) que indica quando o process ser\u00e1 executado. Podemos pensar da seguinte maneira, sempre que algum sinal que est\u00e1 listado nessa lista de sensibilidade mudar de valor ( 0 -> 1 , 1 -> 0 ) o processo ser\u00e1 executado. Vamos ver o exemplo a seguir: process ( A ) begin Q <= A ; end process ; Entendendo Sempre que o sinal A (sinal ou porta) alterar de valor o sinal Q ser\u00e1 atribu\u00eddo com o seu valor Agora vamos criar um outro processo ( esse estar\u00e1 errado ): process ( A ) begin Q <= A and B ; end process ; A ideia por traz desse processo seria que o sinal Q receba o sinal A e B sempre que algum dos dois sofram alguma altera\u00e7\u00e3o, por\u00e9m essa implementa\u00e7\u00e3o n\u00e3o ir\u00e1 funcionar j\u00e1 que B n\u00e3o faz parte da lista de sensibilidade e se B mudar de valor o processo n\u00e3o ser\u00e1 chamado, o sinal Q s\u00f3 ser\u00e1 atualizado quando A mudar de valor. Tarefa Reescreva no codeshare do grupo o m\u00f3dulo anterior corrigido. Chame um professor para validar!","title":"Process VHDL"},{"location":"VHDL-Sequencial/#clock","text":"Para inserirmos um clock (um sistema s\u00edncrono) precisamos necessariamente usar um process , e a arquitetura \u00e9 a seguinte: process ( clock ) begin if ( rising_edge ( clock )) then Q <= D ; end if ; end process ; Sempre que o clock sofrer varia\u00e7\u00e3o ( 0 -> 1 , 1 -> 0 ) o process \u00e9 chamado e verifica-se se a transi\u00e7\u00e3o foi de borda de subida ( rising_edge ) se for, atribui o sinal A ao sinal Q, caso contr\u00e1rio Q mant\u00e9m seu \u00faltimo valor. Note Em FPGA um sinal digital n\u00e3o deve sofrer atualiza\u00e7\u00e3o em ambas as bordas: subida ( rising_edge ) e de descida ( falling_edge ) pois n\u00e3o ser\u00e1 suportado por hardware . Salvo em registradores DDR (double data rate) especiais, exemplo do que n\u00e3o deve ser feito!: process ( clock ) begin if ( rising_edge ( clock )) then Q <= D ; elsif ( falling_edge ( clock )) then Q <= D ; end if ; end process ;","title":"Clock"},{"location":"VHDL-basico/","text":"Introdu\u00e7\u00e3o \u00b6 2020-2 Material atualizado. Estudando Leituras (extra) Free Range VHDL BOOK VHDL CookBook VHDL B\u00e1sico: Parte 1 - Entidade VHDL B\u00e1sico: Parte 2 - Arquitetura V\u00eddeos (extra) O VHDL \u00e9 uma linguagem de descri\u00e7\u00e3o de hardware ( Hardware Description Language - HDL ), n\u00e3o sendo uma linguagem de programa\u00e7\u00e3o. Foi criada durante a Guerra Fria no Departamento de Defesa Americano (DoD-DARPA) para a documenta\u00e7\u00e3o de hardwares complexos (complementava/substitu\u00eda os esquem\u00e1ticos). Com a evolu\u00e7\u00e3o da tecnologia agora \u00e9 poss\u00edvel utilizar a linguagem para implementar sistemas digitais em hardwares program\u00e1veis (FPGA/CPL/...). Por n\u00e3o ter sido criada para o fim que a utilizamos, o VHDL \u00e9 no primeiro momento bastante intrigante. Mas com o usar, voc\u00eas ir\u00e3o se acostumar com a linguagem e ser\u00e3o capazes de realizar hardwares cada vez mais complexos. Note Algumas vezes iremos utilizar a palavra 'c\u00f3digo' para descrever um projeto em VHDL, tenha em mente que n\u00e3o estamos falando de um programa e sim de uma descri\u00e7\u00e3o de hardware. Um programa em Python / Java / C \u00e9 como uma receita de bolo que ser\u00e1 executada em uma cozinha que j\u00e1 est\u00e1 montada, essa cozinha \u00e9 o sua CPU (processador), e n\u00e3o d\u00e1 para mudar com c\u00f3digo (software), o que voc\u00ea muda de um programa para outro \u00e9 a receita. Uma cozinha \u00e9 capaz de realizar diversas receitas diferentes .... No caso do VHDL n\u00e3o temos essa 'cozinha' pronta, na verdade, podemos criar qualquer cozinha que quisermos. Com o VHDL voc\u00ea ser\u00e1 o arquiteto de cozinhas, capaz de criar praticamente qualquer hardware! E ent\u00e3o realizar suas receitas na cozinha que criou. Regras de Ouro do VHDL \u00b6 VHDL \u00e9 uma descri\u00e7\u00e3o, ou projeto, do hardware e n\u00e3o uma programa\u00e7\u00e3o dele. As linhas de c\u00f3digo n\u00e3o s\u00e3o executadas sequencialmente com exce\u00e7\u00e3o de algumas constru\u00e7\u00f5es da linguagem. As linhas de c\u00f3digo ser\u00e3o executadas simultaneamente. Deve-se possuir uma vis\u00e3o de como o circuito digital final ser\u00e1. Se ele for muito complexo, use uma divis\u00e3o em blocos menores at\u00e9 chegar \u00e0s unidades construtivas b\u00e1sicas. B\u00e1sico \u00b6 Um c\u00f3digo em VHDL possui basicamente tr\u00eas partes: Declara\u00e7\u00e3o de bibliotecas utilizadas library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work. all ; Declara\u00e7\u00e3o das entradas e sa\u00eddas desse bloco (entidade) entity TopLevel is port ( a : in std_logic ; b : out std_logic ); end entity ; Implementa\u00e7\u00e3o da l\u00f3gica que relaciona as entradas e sa\u00eddas do m\u00f3dulo (arquitetura) architecture rtl of TopLevel is begin a <= not b ; -- a sa\u00edda A recebe a entrada B end rtl ; Coment\u00e1rios em VHDL Coment\u00e1rios em VHDL s\u00e3o iniciados com dois tra\u00e7os: -- . Exemplo: -- Coment\u00e1rio em VHDL -- a <= not b; Trecho de c\u00f3digo comentado a <= ` 1 ` ; -- coment\u00e1rio Bibliotecas \u00b6 As bibliotecas do VHDL s\u00e3o onde as defini\u00e7\u00f5es dos tipos e das opera\u00e7\u00f5es s\u00e3o realizadas, n\u00e3o ser\u00e1 necess\u00e1rio mexer com isso ao longo do semestre, essa parte j\u00e1 vai estar pronta nos projetos que voc\u00eas forem mexer. Entidade (entity) \u00b6 Podemos pensar na entidade como o trecho de c\u00f3digo que define o m\u00f3dulo como uma caixa preta, ela explicita quem s\u00e3o as entradas e quais s\u00e3o as sa\u00eddas desse m\u00f3dulo. Assim como um CHIP, que possui pinos de entradas e pinos de sa\u00edda. No exemplo anterior, o m\u00f3dulo \u00e9 chamado de TopLevel e possui uma entrada a e uma sa\u00edda b . Tanto a entrada quanto a sa\u00edda s\u00e3o do tipo std_logic . Cada porta tem a descri\u00e7\u00e3o de sua dire\u00e7\u00e3o ( in , out ), como detalhado a seguir: Uma entidade pode ter nenhuma ou 'infinitas' portas, para adicionarmos uma porta nova a uma entidade, basta adicionarmos uma nova linha com as tr\u00eas propriedades: NOME : DIRE\u00c7\u00c3O TIPO; Tip Note a necessidade do ; no final da linha, isso indica para o VHDL que essa descri\u00e7\u00e3o 'acabou'. A quebra de linha Enter n\u00e3o tem uso para o VHDL, s\u00f3 serve para facilitar nossa leitura. Warning O ; n\u00e3o deve aparecer na \u00faltima porta! No exemplo anterior a porta b : out STD_LOGIC n\u00e3o possui ; . Example Adicionando uma entrada x ao m\u00f3dulo anterior: entity TopLevel is port ( a : in std_logic ; b : out std_logic ; x : in std_logic ); end entity ; Nome \u00b6 No VHDL voc\u00ea n\u00e3o pode usar um nome de porta que: Comece com um n\u00famero: ( 0 , 1 , ... ), ex: 0bus : out std_logic; \u00c9 uma das muitas palavras reservadas : in , out , not , ex: bus : out std_logic; Possua espa\u00e7o: entrada 1: in std_logic; Para mais detalhes, d\u00ea uma olhada na documenta\u00e7\u00e3o completa Dire\u00e7\u00e3o \u00b6 A dire\u00e7\u00e3o in , out define se a informa\u00e7\u00e3o ir\u00e1 entrar no m\u00f3dulo ou sair do m\u00f3dulo. Por exemplo, se quisermos 'ler' um bot\u00e3o, devemos declarar essa porta como sendo uma 'entrada' ( in ) do m\u00f3dulo, mas se quisermos acionar um LED, devemos declarar essa porta como 'sa\u00edda' ( out ), pois ela ser\u00e1 controlada por nossa l\u00f3gica. Tipo \u00b6 O tipo define se a porta ser\u00e1 composta por um \u00fanico bit std_logic ou por um vetor de bits std_logic_vector(2 downto 0) (vetor de 3 bits). O tipo STD_LOGIC \u00e9 muito mais complexo que s\u00f3 um bit, mas vamos deixar isso de lado por ora. Exemplos \u00b6 M\u00f3dulo com duas entradas bin\u00e1rias: a , x e uma sa\u00edda b entity Comp1 is port ( a : in std_logic ; x : in std_logic ; b : out std_logic ); end entity ; M\u00f3dulo chamado MUX que possui 4 entradas na forma de um vetor ( I : in std_logic_vector(3 downto 0) ), um seletor de dois bits na forma de um vetor ( S ) e uma sa\u00edda q na forma de um bit. entity mux is port ( I : in std_logic_vector ( 3 downto 0 ); S : in std_logic_vector ( 1 downto 0 ); q : out std_logic ); end entity ; Tip Note que a entrada I foi declarada como sendo um vetor que come\u00e7a em 3 e termina em 0 , possuindo no total 4 bits: 3 , 2 , 1 , 0 Em diagrama el\u00e9trico \u00e9 utilizado a seguinte nota\u00e7\u00e3o para indicar um vetor de bits: Uso de uma / no fio com a indica\u00e7\u00e3o da quantidade de bits Uso de uma linha mais grossa, para indicar um vetor Entidade de uma ULA entity ALU is port ( x , y : in STD_LOGIC_VECTOR ( 15 downto 0 ); -- entradas de dados da ALU zx : in STD_LOGIC ; -- zera a entrada x nx : in STD_LOGIC ; -- inverte a entrada x zy : in STD_LOGIC ; -- zera a entrada y ny : in STD_LOGIC ; -- inverte a entrada y f : in STD_LOGIC ; -- se 0 calcula x & y, sen\u00e3o x + y no : in STD_LOGIC ; -- inverte o valor da sa\u00edda zr : out STD_LOGIC ; -- setado se sa\u00edda igual a zero ng : out STD_LOGIC ; -- setado se sa\u00edda \u00e9 negativa saida : out STD_LOGIC_VECTOR ( 15 downto 0 ) -- sa\u00edda de dados da ALU ); end entity ; nota Note que a primeira linha declara duas portas com nome x e y com a mesma dire\u00e7\u00e3o in e do tipo std_logic_vector(15 downto 0) . Isso \u00e9 um atalho no VHDL e deve ser evitado. O ideal \u00e9 reescrever essa linha como a seguir: port ( x : in STD_LOGIC_VECTOR ( 15 downto 0 ); -- entrada X de dados da ALU y : in STD_LOGIC_VECTOR ( 15 downto 0 ); -- entrada Y de dados da ALU Arquitetura (architecture) \u00b6 A arquitetura ( architecture ) define a rela\u00e7\u00e3o das entradas com as sa\u00eddas da entidade. Nessa parte \u00e9 onde ser\u00e1 constru\u00edda a l\u00f3gica digital desse m\u00f3dulo. Pense que \u00e9 na arquitetura onde transcrevemos uma equa\u00e7\u00e3o l\u00f3gica, ou onde descrevemos uma mem\u00f3ria. architecture rtl of TopLevel is -- Aqui \u00e9 declaro os poss\u00edveis: -- a) sinais internos de uma entidade -- b) outras entidades que essa entidade pode utilizar begin -- Aqui \u00e9 onde a coisa acontece de verdade -- onde \u00e9 feita a descri\u00e7\u00e3o da l\u00f3gica digital a <= not b ; end rtl ; Opera\u00e7\u00f5es b\u00e1sicas \u00b6 Suponha o uso da entidade a seguir para os exemplos que ser\u00e3o apresentados entity Foo is port ( x : in std_logic ; y : in std_logic ; q : out std_logic ; p : out std_logic ); end entity ; No VHDL usamos <= para representar que alguma coisa (a esquerda da seta) recebe algum outro valor (a direita da seta). Exemplos: q <= x; q recebe o valor de x Na pr\u00e1tica estamos conectando um fio de x que liga em q q <= '0'; q recebe o valor 0 Na pr\u00e1tica estamos conectando um fio que sai de q e liga no terra q <= '1'; q recebe o valor 1 Na pr\u00e1tica estamos conectando um fio que sai de q e liga no vcc Note Note que aqui estamos usando aspas simples: '0' e '1' para indicar um n\u00famero bin\u00e1rio ( std_logic ). Aspas dupla \"0101\" em VHDL significa que estamos trabalhando com um vetor de n\u00fameros bin\u00e1rios ( std_logic_vector ). Podemos utilizar portas l\u00f3gicas nas opera\u00e7\u00f5es, alguns operadores implementados pela linguagem, s\u00e3o: not , and , or , nand , nor , xor , xnor . O uso dos operadores \u00e9 feito da seguinte maneira: q <= not x; q recebe o valor de x negado q <= x and y; q recebe o valor de x E y p <= x xor y; q recebe o valor de x XOR y Warning Em VHDL n\u00e3o \u00e9 poss\u00edvel 'ler' uma sa\u00edda, as seguintes opera\u00e7\u00f5es n\u00e3o pode ser realizada: q <= not x ; -- x \u00e9 sa\u00edda p <= q ; -- q \u00e9 sa\u00edda Opera\u00e7\u00e3o com vetores \u00b6 Suponha o uso da entidade a seguir para os exemplos que ser\u00e3o apresentados entity Bar is port ( a : in std_logic ; b : in std_logic_vector ( 3 downto 0 ); q : out std_logic ; p : out std_logic_vector ( 2 downto 0 ) ); end entity ; Exemplos de opera\u00e7\u00e3o com vetores: p <= \"100\" p recebe o valor em bin\u00e1rio 100 p <= not \"100\" p recebe o valor em bin\u00e1rio 011 p <= b(2 downto 0); p recebe os tr\u00eas primeiros bits de b p(0) <= a; p bit 0 recebe o valor da entrada a q <= not b(1); a sa\u00edda bin\u00e1ria q recebe o bit 1 da entrada b negado. Tip \u00c9 comum confundir quando usar aspas simples '' e aspas dupla \"\" , fique atento aos erros de compila\u00e7\u00e3o. signal \u00b6 Sinais s\u00e3o declarados entre a palavra reservada architecture e o begin e servem para facilitar/ possibilitar o desenvolvimento de um sistema digital, eles s\u00f3 s\u00e3o vis\u00edveis dentro de uma entidade e servem como 'fios' internos de um m\u00f3dulo. Sinais s\u00e3o diferente de portas n\u00e3o possuem dire\u00e7\u00e3o, e s\u00e3o declarados da seguinte maneira: signal NAME : TYPE TYPE pode ser: std_logic / std_logic_vector , entre outros. Exemplo: architecture rtl of TopLevel is -- Declara\u00e7\u00e3o de sinais signal aux1 : std_logic ; signal aux2 : std_logic_vector ( 1 downto 0 ); -- inicio da implementa\u00e7\u00e3o begin -------------------- aux1 <= not a ; q <= aux1 ; p ( 0 ) <= aux1 ; -------------------- aux2 <= b ( 3 downto 2 ); p ( 2 downto 1 ) <= aux2 ; end rtl ; No exemplo anterior, criamos um sinal auxiliar chamado de aux1 que recebe a entrada a negada, esse sinal \u00e9 ent\u00e3o atribu\u00eddo a sa\u00edda q e ao bit 0 da sa\u00edda p . Outro sinal aux2 , vetor de 2 bits recebe os dois bits mais significativos da entrada b e ent\u00e3o \u00e9 atribu\u00eddo a sa\u00edda p , bits 2 e 1.","title":"Introdu\u00e7\u00e3o"},{"location":"VHDL-basico/#introducao","text":"2020-2 Material atualizado. Estudando Leituras (extra) Free Range VHDL BOOK VHDL CookBook VHDL B\u00e1sico: Parte 1 - Entidade VHDL B\u00e1sico: Parte 2 - Arquitetura V\u00eddeos (extra) O VHDL \u00e9 uma linguagem de descri\u00e7\u00e3o de hardware ( Hardware Description Language - HDL ), n\u00e3o sendo uma linguagem de programa\u00e7\u00e3o. Foi criada durante a Guerra Fria no Departamento de Defesa Americano (DoD-DARPA) para a documenta\u00e7\u00e3o de hardwares complexos (complementava/substitu\u00eda os esquem\u00e1ticos). Com a evolu\u00e7\u00e3o da tecnologia agora \u00e9 poss\u00edvel utilizar a linguagem para implementar sistemas digitais em hardwares program\u00e1veis (FPGA/CPL/...). Por n\u00e3o ter sido criada para o fim que a utilizamos, o VHDL \u00e9 no primeiro momento bastante intrigante. Mas com o usar, voc\u00eas ir\u00e3o se acostumar com a linguagem e ser\u00e3o capazes de realizar hardwares cada vez mais complexos. Note Algumas vezes iremos utilizar a palavra 'c\u00f3digo' para descrever um projeto em VHDL, tenha em mente que n\u00e3o estamos falando de um programa e sim de uma descri\u00e7\u00e3o de hardware. Um programa em Python / Java / C \u00e9 como uma receita de bolo que ser\u00e1 executada em uma cozinha que j\u00e1 est\u00e1 montada, essa cozinha \u00e9 o sua CPU (processador), e n\u00e3o d\u00e1 para mudar com c\u00f3digo (software), o que voc\u00ea muda de um programa para outro \u00e9 a receita. Uma cozinha \u00e9 capaz de realizar diversas receitas diferentes .... No caso do VHDL n\u00e3o temos essa 'cozinha' pronta, na verdade, podemos criar qualquer cozinha que quisermos. Com o VHDL voc\u00ea ser\u00e1 o arquiteto de cozinhas, capaz de criar praticamente qualquer hardware! E ent\u00e3o realizar suas receitas na cozinha que criou.","title":"Introdu\u00e7\u00e3o"},{"location":"VHDL-basico/#regras-de-ouro-do-vhdl","text":"VHDL \u00e9 uma descri\u00e7\u00e3o, ou projeto, do hardware e n\u00e3o uma programa\u00e7\u00e3o dele. As linhas de c\u00f3digo n\u00e3o s\u00e3o executadas sequencialmente com exce\u00e7\u00e3o de algumas constru\u00e7\u00f5es da linguagem. As linhas de c\u00f3digo ser\u00e3o executadas simultaneamente. Deve-se possuir uma vis\u00e3o de como o circuito digital final ser\u00e1. Se ele for muito complexo, use uma divis\u00e3o em blocos menores at\u00e9 chegar \u00e0s unidades construtivas b\u00e1sicas.","title":"Regras de Ouro do VHDL"},{"location":"VHDL-basico/#basico","text":"Um c\u00f3digo em VHDL possui basicamente tr\u00eas partes: Declara\u00e7\u00e3o de bibliotecas utilizadas library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work. all ; Declara\u00e7\u00e3o das entradas e sa\u00eddas desse bloco (entidade) entity TopLevel is port ( a : in std_logic ; b : out std_logic ); end entity ; Implementa\u00e7\u00e3o da l\u00f3gica que relaciona as entradas e sa\u00eddas do m\u00f3dulo (arquitetura) architecture rtl of TopLevel is begin a <= not b ; -- a sa\u00edda A recebe a entrada B end rtl ; Coment\u00e1rios em VHDL Coment\u00e1rios em VHDL s\u00e3o iniciados com dois tra\u00e7os: -- . Exemplo: -- Coment\u00e1rio em VHDL -- a <= not b; Trecho de c\u00f3digo comentado a <= ` 1 ` ; -- coment\u00e1rio","title":"B\u00e1sico"},{"location":"VHDL-basico/#bibliotecas","text":"As bibliotecas do VHDL s\u00e3o onde as defini\u00e7\u00f5es dos tipos e das opera\u00e7\u00f5es s\u00e3o realizadas, n\u00e3o ser\u00e1 necess\u00e1rio mexer com isso ao longo do semestre, essa parte j\u00e1 vai estar pronta nos projetos que voc\u00eas forem mexer.","title":"Bibliotecas"},{"location":"VHDL-basico/#entidade-entity","text":"Podemos pensar na entidade como o trecho de c\u00f3digo que define o m\u00f3dulo como uma caixa preta, ela explicita quem s\u00e3o as entradas e quais s\u00e3o as sa\u00eddas desse m\u00f3dulo. Assim como um CHIP, que possui pinos de entradas e pinos de sa\u00edda. No exemplo anterior, o m\u00f3dulo \u00e9 chamado de TopLevel e possui uma entrada a e uma sa\u00edda b . Tanto a entrada quanto a sa\u00edda s\u00e3o do tipo std_logic . Cada porta tem a descri\u00e7\u00e3o de sua dire\u00e7\u00e3o ( in , out ), como detalhado a seguir: Uma entidade pode ter nenhuma ou 'infinitas' portas, para adicionarmos uma porta nova a uma entidade, basta adicionarmos uma nova linha com as tr\u00eas propriedades: NOME : DIRE\u00c7\u00c3O TIPO; Tip Note a necessidade do ; no final da linha, isso indica para o VHDL que essa descri\u00e7\u00e3o 'acabou'. A quebra de linha Enter n\u00e3o tem uso para o VHDL, s\u00f3 serve para facilitar nossa leitura. Warning O ; n\u00e3o deve aparecer na \u00faltima porta! No exemplo anterior a porta b : out STD_LOGIC n\u00e3o possui ; . Example Adicionando uma entrada x ao m\u00f3dulo anterior: entity TopLevel is port ( a : in std_logic ; b : out std_logic ; x : in std_logic ); end entity ;","title":"Entidade (entity)"},{"location":"VHDL-basico/#nome","text":"No VHDL voc\u00ea n\u00e3o pode usar um nome de porta que: Comece com um n\u00famero: ( 0 , 1 , ... ), ex: 0bus : out std_logic; \u00c9 uma das muitas palavras reservadas : in , out , not , ex: bus : out std_logic; Possua espa\u00e7o: entrada 1: in std_logic; Para mais detalhes, d\u00ea uma olhada na documenta\u00e7\u00e3o completa","title":"Nome"},{"location":"VHDL-basico/#direcao","text":"A dire\u00e7\u00e3o in , out define se a informa\u00e7\u00e3o ir\u00e1 entrar no m\u00f3dulo ou sair do m\u00f3dulo. Por exemplo, se quisermos 'ler' um bot\u00e3o, devemos declarar essa porta como sendo uma 'entrada' ( in ) do m\u00f3dulo, mas se quisermos acionar um LED, devemos declarar essa porta como 'sa\u00edda' ( out ), pois ela ser\u00e1 controlada por nossa l\u00f3gica.","title":"Dire\u00e7\u00e3o"},{"location":"VHDL-basico/#tipo","text":"O tipo define se a porta ser\u00e1 composta por um \u00fanico bit std_logic ou por um vetor de bits std_logic_vector(2 downto 0) (vetor de 3 bits). O tipo STD_LOGIC \u00e9 muito mais complexo que s\u00f3 um bit, mas vamos deixar isso de lado por ora.","title":"Tipo"},{"location":"VHDL-basico/#exemplos","text":"M\u00f3dulo com duas entradas bin\u00e1rias: a , x e uma sa\u00edda b entity Comp1 is port ( a : in std_logic ; x : in std_logic ; b : out std_logic ); end entity ; M\u00f3dulo chamado MUX que possui 4 entradas na forma de um vetor ( I : in std_logic_vector(3 downto 0) ), um seletor de dois bits na forma de um vetor ( S ) e uma sa\u00edda q na forma de um bit. entity mux is port ( I : in std_logic_vector ( 3 downto 0 ); S : in std_logic_vector ( 1 downto 0 ); q : out std_logic ); end entity ; Tip Note que a entrada I foi declarada como sendo um vetor que come\u00e7a em 3 e termina em 0 , possuindo no total 4 bits: 3 , 2 , 1 , 0 Em diagrama el\u00e9trico \u00e9 utilizado a seguinte nota\u00e7\u00e3o para indicar um vetor de bits: Uso de uma / no fio com a indica\u00e7\u00e3o da quantidade de bits Uso de uma linha mais grossa, para indicar um vetor Entidade de uma ULA entity ALU is port ( x , y : in STD_LOGIC_VECTOR ( 15 downto 0 ); -- entradas de dados da ALU zx : in STD_LOGIC ; -- zera a entrada x nx : in STD_LOGIC ; -- inverte a entrada x zy : in STD_LOGIC ; -- zera a entrada y ny : in STD_LOGIC ; -- inverte a entrada y f : in STD_LOGIC ; -- se 0 calcula x & y, sen\u00e3o x + y no : in STD_LOGIC ; -- inverte o valor da sa\u00edda zr : out STD_LOGIC ; -- setado se sa\u00edda igual a zero ng : out STD_LOGIC ; -- setado se sa\u00edda \u00e9 negativa saida : out STD_LOGIC_VECTOR ( 15 downto 0 ) -- sa\u00edda de dados da ALU ); end entity ; nota Note que a primeira linha declara duas portas com nome x e y com a mesma dire\u00e7\u00e3o in e do tipo std_logic_vector(15 downto 0) . Isso \u00e9 um atalho no VHDL e deve ser evitado. O ideal \u00e9 reescrever essa linha como a seguir: port ( x : in STD_LOGIC_VECTOR ( 15 downto 0 ); -- entrada X de dados da ALU y : in STD_LOGIC_VECTOR ( 15 downto 0 ); -- entrada Y de dados da ALU","title":"Exemplos"},{"location":"VHDL-basico/#arquitetura-architecture","text":"A arquitetura ( architecture ) define a rela\u00e7\u00e3o das entradas com as sa\u00eddas da entidade. Nessa parte \u00e9 onde ser\u00e1 constru\u00edda a l\u00f3gica digital desse m\u00f3dulo. Pense que \u00e9 na arquitetura onde transcrevemos uma equa\u00e7\u00e3o l\u00f3gica, ou onde descrevemos uma mem\u00f3ria. architecture rtl of TopLevel is -- Aqui \u00e9 declaro os poss\u00edveis: -- a) sinais internos de uma entidade -- b) outras entidades que essa entidade pode utilizar begin -- Aqui \u00e9 onde a coisa acontece de verdade -- onde \u00e9 feita a descri\u00e7\u00e3o da l\u00f3gica digital a <= not b ; end rtl ;","title":"Arquitetura (architecture)"},{"location":"VHDL-basico/#operacoes-basicas","text":"Suponha o uso da entidade a seguir para os exemplos que ser\u00e3o apresentados entity Foo is port ( x : in std_logic ; y : in std_logic ; q : out std_logic ; p : out std_logic ); end entity ; No VHDL usamos <= para representar que alguma coisa (a esquerda da seta) recebe algum outro valor (a direita da seta). Exemplos: q <= x; q recebe o valor de x Na pr\u00e1tica estamos conectando um fio de x que liga em q q <= '0'; q recebe o valor 0 Na pr\u00e1tica estamos conectando um fio que sai de q e liga no terra q <= '1'; q recebe o valor 1 Na pr\u00e1tica estamos conectando um fio que sai de q e liga no vcc Note Note que aqui estamos usando aspas simples: '0' e '1' para indicar um n\u00famero bin\u00e1rio ( std_logic ). Aspas dupla \"0101\" em VHDL significa que estamos trabalhando com um vetor de n\u00fameros bin\u00e1rios ( std_logic_vector ). Podemos utilizar portas l\u00f3gicas nas opera\u00e7\u00f5es, alguns operadores implementados pela linguagem, s\u00e3o: not , and , or , nand , nor , xor , xnor . O uso dos operadores \u00e9 feito da seguinte maneira: q <= not x; q recebe o valor de x negado q <= x and y; q recebe o valor de x E y p <= x xor y; q recebe o valor de x XOR y Warning Em VHDL n\u00e3o \u00e9 poss\u00edvel 'ler' uma sa\u00edda, as seguintes opera\u00e7\u00f5es n\u00e3o pode ser realizada: q <= not x ; -- x \u00e9 sa\u00edda p <= q ; -- q \u00e9 sa\u00edda","title":"Opera\u00e7\u00f5es b\u00e1sicas"},{"location":"VHDL-basico/#operacao-com-vetores","text":"Suponha o uso da entidade a seguir para os exemplos que ser\u00e3o apresentados entity Bar is port ( a : in std_logic ; b : in std_logic_vector ( 3 downto 0 ); q : out std_logic ; p : out std_logic_vector ( 2 downto 0 ) ); end entity ; Exemplos de opera\u00e7\u00e3o com vetores: p <= \"100\" p recebe o valor em bin\u00e1rio 100 p <= not \"100\" p recebe o valor em bin\u00e1rio 011 p <= b(2 downto 0); p recebe os tr\u00eas primeiros bits de b p(0) <= a; p bit 0 recebe o valor da entrada a q <= not b(1); a sa\u00edda bin\u00e1ria q recebe o bit 1 da entrada b negado. Tip \u00c9 comum confundir quando usar aspas simples '' e aspas dupla \"\" , fique atento aos erros de compila\u00e7\u00e3o.","title":"Opera\u00e7\u00e3o com vetores"},{"location":"VHDL-basico/#signal","text":"Sinais s\u00e3o declarados entre a palavra reservada architecture e o begin e servem para facilitar/ possibilitar o desenvolvimento de um sistema digital, eles s\u00f3 s\u00e3o vis\u00edveis dentro de uma entidade e servem como 'fios' internos de um m\u00f3dulo. Sinais s\u00e3o diferente de portas n\u00e3o possuem dire\u00e7\u00e3o, e s\u00e3o declarados da seguinte maneira: signal NAME : TYPE TYPE pode ser: std_logic / std_logic_vector , entre outros. Exemplo: architecture rtl of TopLevel is -- Declara\u00e7\u00e3o de sinais signal aux1 : std_logic ; signal aux2 : std_logic_vector ( 1 downto 0 ); -- inicio da implementa\u00e7\u00e3o begin -------------------- aux1 <= not a ; q <= aux1 ; p ( 0 ) <= aux1 ; -------------------- aux2 <= b ( 3 downto 2 ); p ( 2 downto 1 ) <= aux2 ; end rtl ; No exemplo anterior, criamos um sinal auxiliar chamado de aux1 que recebe a entrada a negada, esse sinal \u00e9 ent\u00e3o atribu\u00eddo a sa\u00edda q e ao bit 0 da sa\u00edda p . Outro sinal aux2 , vetor de 2 bits recebe os dois bits mais significativos da entrada b e ent\u00e3o \u00e9 atribu\u00eddo a sa\u00edda p , bits 2 e 1.","title":"signal"},{"location":"VHDL-exemplos/","text":"Exemplos completos \u00b6 http://esd.cs.ucr.edu/labs/tutorial/ https://www.intel.com/content/www/us/en/programmable/support/support-resources/design-examples/design-software/vhdl.html http://ftp.smart-dv.com/examples/vhdl/index.html Combinacional \u00b6 END \u00b6 library ieee ; use ieee.std_logic_1164. all ; -------------------------------------------------- entity AND_ent is port ( x : in std_logic ; y : in std_logic ; F : out std_logic ); end AND_ent ; -------------------------------------------------- architecture behav2 of AND_ent is begin F <= x and y ; end behav2 ; Exemplo extra\u00eddo de: http://esd.cs.ucr.edu/labs/tutorial/ mux \u00b6 ------------------------------------------------------- -- Design Name : mux_using_when -- File Name : mux_using_assign.v -- Function : 2:1 Mux using when -- Coder : Deepak Kumar Tala ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity mux_using_when is port ( din_0 : in std_logic ; -- Mux first input din_1 : in std_logic ; -- Mux Second input sel : in std_logic ; -- Select input mux_out : out std_logic -- Mux output ); end entity ; architecture behavior of mux_using_when is begin mux_out <= din_0 when ( sel = '0' ) else din_1 ; end architecture ; ou ------------------------------------------------------- -- Design Name : mux_using_when -- File Name : mux_using_assign.v -- Function : 2:1 Mux using when -- Coder : Deepak Kumar Tala ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity mux_using_when is port ( din_0 : in std_logic ; -- Mux first input din_1 : in std_logic ; -- Mux Second input sel : in std_logic ; -- Select input mux_out : out std_logic -- Mux output ); end entity ; architecture behavior of mux_using_when is begin mux_out <= din_0 when ( sel = '0' ) else din_1 ; end architecture ; Exemplo extra\u00eddo de: http://ftp.smart-dv.com/examples/vhdl/mux.html demux \u00b6 Sa\u00edda sendo 4 sinais independentes: library ieee ; use ieee.std_logic_1164. all ; entity demux is port ( din : in std_logic ; -- Mux first input sel : in std_logic_vector ( 1 downto 0 ); -- Select output dout_0 : out std_logic ; -- demux first out dout_1 : out std_logic ; -- demux second out dout_2 : out std_logic ; -- demux ... dout_3 : out std_logic -- demux ... ); end entity ; architecture behavior of mux_using_when is begin dout_0 <= din when sel = \"00\" else '0' ; dout_1 <= din when sel = \"01\" else '0' ; dout_2 <= din when sel = \"10\" else '0' ; dout_3 <= din when sel = \"11\" else '0' ; end architecture ; Sa\u00edda sendo um vetor: library ieee ; use ieee.std_logic_1164. all ; entity demux is port ( din : in std_logic ; -- Mux first input sel : in std_logic_vector ( 1 downto 0 ); -- Select output dout : out std_logic_vector ( 3 downto 0 ) -- demux out vector ); end entity ; architecture behavior of mux_using_when is begin dout ( 0 ) <= din when sel = \"00\" else '0' ; dout ( 1 ) <= din when sel = \"01\" else '0' ; dout ( 2 ) <= din when sel = \"10\" else '0' ; dout ( 3 ) <= din when sel = \"11\" else '0' ; end architecture ; Enconder \u00b6 ------------------------------------------------------- -- Design Name : pri_encoder_using_when -- File Name : pri_encoder_using_when.vhd -- Function : Pri Encoder using when-else -- Coder : Deepak Kumar Tala (Verilog) -- Translator : Alexander H Pham (VHDL) -- Fixed : Tomasz Olszewski ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity pri_encoder_using_when is port ( enable : in std_logic ; -- Enable for the encoder encoder_in : in std_logic_vector ( 15 downto 0 ); -- 16-bit Input binary_out : out std_logic_vector ( 3 downto 0 ) -- 4 bit binary Output ); end entity ; architecture behavior of pri_encoder_using_when is begin binary_out <= \"0000\" when enable = '0' else \"0001\" when encoder_in ( 1 ) = '1' else \"0010\" when encoder_in ( 2 ) = '1' else \"0011\" when encoder_in ( 3 ) = '1' else \"0100\" when encoder_in ( 4 ) = '1' else \"0101\" when encoder_in ( 5 ) = '1' else \"0110\" when encoder_in ( 6 ) = '1' else \"0111\" when encoder_in ( 7 ) = '1' else \"1000\" when encoder_in ( 8 ) = '1' else \"1001\" when encoder_in ( 9 ) = '1' else \"1010\" when encoder_in ( 10 ) = '1' else \"1011\" when encoder_in ( 11 ) = '1' else \"1100\" when encoder_in ( 12 ) = '1' else \"1101\" when encoder_in ( 13 ) = '1' else \"1110\" when encoder_in ( 14 ) = '1' else \"1111\" when encoder_in ( 15 ) = '1' else \"0000\" ; end architecture ; Exemplo extra\u00eddo de: http://ftp.smart-dv.com/examples/vhdl/pri_encoder.html#Encoder_-_Using_when_Statement Paridade \u00b6 ------------------------------------------------------- -- Design Name : parity_using_assign -- File Name : parity_using_assign.vhd -- Function : Parity using direct assignment -- Coder : Deepak Kumar Tala (Verilog) -- Translator : Alexander H Pham (VHDL) ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity parity_using_assign is port ( data_in : in std_logic_vector ( 7 downto 0 ); parity_out : out std_logic ); end entity ; architecture rtl of parity_using_assign is begin parity_out <= ( data_in ( 0 ) xor data_in ( 1 )) xor ( data_in ( 2 ) xor data_in ( 3 )) xor ( data_in ( 4 ) xor data_in ( 5 )) xor ( data_in ( 6 ) xor data_in ( 7 )); end architecture ; Exemplo extra\u00eddo de: http://ftp.smart-dv.com/examples/vhdl/parity.html#Using_Assign","title":"Exemplos completos"},{"location":"VHDL-exemplos/#exemplos-completos","text":"http://esd.cs.ucr.edu/labs/tutorial/ https://www.intel.com/content/www/us/en/programmable/support/support-resources/design-examples/design-software/vhdl.html http://ftp.smart-dv.com/examples/vhdl/index.html","title":"Exemplos completos"},{"location":"VHDL-exemplos/#combinacional","text":"","title":"Combinacional"},{"location":"VHDL-exemplos/#end","text":"library ieee ; use ieee.std_logic_1164. all ; -------------------------------------------------- entity AND_ent is port ( x : in std_logic ; y : in std_logic ; F : out std_logic ); end AND_ent ; -------------------------------------------------- architecture behav2 of AND_ent is begin F <= x and y ; end behav2 ; Exemplo extra\u00eddo de: http://esd.cs.ucr.edu/labs/tutorial/","title":"END"},{"location":"VHDL-exemplos/#mux","text":"------------------------------------------------------- -- Design Name : mux_using_when -- File Name : mux_using_assign.v -- Function : 2:1 Mux using when -- Coder : Deepak Kumar Tala ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity mux_using_when is port ( din_0 : in std_logic ; -- Mux first input din_1 : in std_logic ; -- Mux Second input sel : in std_logic ; -- Select input mux_out : out std_logic -- Mux output ); end entity ; architecture behavior of mux_using_when is begin mux_out <= din_0 when ( sel = '0' ) else din_1 ; end architecture ; ou ------------------------------------------------------- -- Design Name : mux_using_when -- File Name : mux_using_assign.v -- Function : 2:1 Mux using when -- Coder : Deepak Kumar Tala ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity mux_using_when is port ( din_0 : in std_logic ; -- Mux first input din_1 : in std_logic ; -- Mux Second input sel : in std_logic ; -- Select input mux_out : out std_logic -- Mux output ); end entity ; architecture behavior of mux_using_when is begin mux_out <= din_0 when ( sel = '0' ) else din_1 ; end architecture ; Exemplo extra\u00eddo de: http://ftp.smart-dv.com/examples/vhdl/mux.html","title":"mux"},{"location":"VHDL-exemplos/#demux","text":"Sa\u00edda sendo 4 sinais independentes: library ieee ; use ieee.std_logic_1164. all ; entity demux is port ( din : in std_logic ; -- Mux first input sel : in std_logic_vector ( 1 downto 0 ); -- Select output dout_0 : out std_logic ; -- demux first out dout_1 : out std_logic ; -- demux second out dout_2 : out std_logic ; -- demux ... dout_3 : out std_logic -- demux ... ); end entity ; architecture behavior of mux_using_when is begin dout_0 <= din when sel = \"00\" else '0' ; dout_1 <= din when sel = \"01\" else '0' ; dout_2 <= din when sel = \"10\" else '0' ; dout_3 <= din when sel = \"11\" else '0' ; end architecture ; Sa\u00edda sendo um vetor: library ieee ; use ieee.std_logic_1164. all ; entity demux is port ( din : in std_logic ; -- Mux first input sel : in std_logic_vector ( 1 downto 0 ); -- Select output dout : out std_logic_vector ( 3 downto 0 ) -- demux out vector ); end entity ; architecture behavior of mux_using_when is begin dout ( 0 ) <= din when sel = \"00\" else '0' ; dout ( 1 ) <= din when sel = \"01\" else '0' ; dout ( 2 ) <= din when sel = \"10\" else '0' ; dout ( 3 ) <= din when sel = \"11\" else '0' ; end architecture ;","title":"demux"},{"location":"VHDL-exemplos/#enconder","text":"------------------------------------------------------- -- Design Name : pri_encoder_using_when -- File Name : pri_encoder_using_when.vhd -- Function : Pri Encoder using when-else -- Coder : Deepak Kumar Tala (Verilog) -- Translator : Alexander H Pham (VHDL) -- Fixed : Tomasz Olszewski ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity pri_encoder_using_when is port ( enable : in std_logic ; -- Enable for the encoder encoder_in : in std_logic_vector ( 15 downto 0 ); -- 16-bit Input binary_out : out std_logic_vector ( 3 downto 0 ) -- 4 bit binary Output ); end entity ; architecture behavior of pri_encoder_using_when is begin binary_out <= \"0000\" when enable = '0' else \"0001\" when encoder_in ( 1 ) = '1' else \"0010\" when encoder_in ( 2 ) = '1' else \"0011\" when encoder_in ( 3 ) = '1' else \"0100\" when encoder_in ( 4 ) = '1' else \"0101\" when encoder_in ( 5 ) = '1' else \"0110\" when encoder_in ( 6 ) = '1' else \"0111\" when encoder_in ( 7 ) = '1' else \"1000\" when encoder_in ( 8 ) = '1' else \"1001\" when encoder_in ( 9 ) = '1' else \"1010\" when encoder_in ( 10 ) = '1' else \"1011\" when encoder_in ( 11 ) = '1' else \"1100\" when encoder_in ( 12 ) = '1' else \"1101\" when encoder_in ( 13 ) = '1' else \"1110\" when encoder_in ( 14 ) = '1' else \"1111\" when encoder_in ( 15 ) = '1' else \"0000\" ; end architecture ; Exemplo extra\u00eddo de: http://ftp.smart-dv.com/examples/vhdl/pri_encoder.html#Encoder_-_Using_when_Statement","title":"Enconder"},{"location":"VHDL-exemplos/#paridade","text":"------------------------------------------------------- -- Design Name : parity_using_assign -- File Name : parity_using_assign.vhd -- Function : Parity using direct assignment -- Coder : Deepak Kumar Tala (Verilog) -- Translator : Alexander H Pham (VHDL) ------------------------------------------------------- library ieee ; use ieee.std_logic_1164. all ; entity parity_using_assign is port ( data_in : in std_logic_vector ( 7 downto 0 ); parity_out : out std_logic ); end entity ; architecture rtl of parity_using_assign is begin parity_out <= ( data_in ( 0 ) xor data_in ( 1 )) xor ( data_in ( 2 ) xor data_in ( 3 )) xor ( data_in ( 4 ) xor data_in ( 5 )) xor ( data_in ( 6 ) xor data_in ( 7 )); end architecture ; Exemplo extra\u00eddo de: http://ftp.smart-dv.com/examples/vhdl/parity.html#Using_Assign","title":"Paridade"},{"location":"VHDL-port-map/","text":"port map \u00b6 Esse texto explica como realizar o port map em VHDL, t\u00e9cnica que permite o reaproveitamento de m\u00f3dulos e o desenvolvimento hier\u00e1rquico. Desenvolvimento hier\u00e1rquico \u00b6 \u00c9 uma t\u00e9cnica de organiza\u00e7\u00e3o de projeto onde s\u00e3o desenvolvidos pequenos m\u00f3dulos e esses m\u00f3dulos fazem parte de um sistema maior, que por sua vez, fazem parte de algo muito mais complexo. As vantagens de um desenvolvimento desse tipo s\u00e3o: Facilidade em realizar testes e valida\u00e7\u00e3o Cada m\u00f3dulo \u00e9 testado independentemente Trabalho em equipe A partir do momento que as interfaces s\u00e3o bem estabelecidas, cada um do time pode desenvolver um m\u00f3dulo Ferramentas gostam / se adaptam bem As ferramentas de desenvolvimento conseguem otimizar o hardware melhor Reaproveitamento de m\u00f3dulos Muito mais f\u00e1cil para reaproveitar outros m\u00f3dulos. Leitura extra https://www.intel.com/content/www/us/en/programmable/support/support-resources/design-examples/design-software/vhdl/v_hier.html Fonte: https://www.embedded.com/the-art-of-fpga-construction/ port map \u00b6 port map \u00e9 a maneira em VHDL de reaproveitamos uma entidade definida em outro lugar no nosso arquivo. Pensar em port map como uma fun\u00e7\u00e3o n\u00e3o \u00e9 de todo errado, mas devesse notar que quando usamos port map estamos criando uma c\u00f3pia do hardware que \u00e9 descrito pela entidade usada, isso \u00e9 diferente de uma fun\u00e7\u00e3o em Python, que reaproveita o mesmo trecho de c\u00f3digo para cada chamada de fun\u00e7\u00e3o. \u00c9 mais apropriado pensar que a descri\u00e7\u00e3o de um hardware \u00e9 uma receita (que vemos na architecture ), o port map seria como o bolo, voc\u00ea pode ter v\u00e1rios bolos com a mesma receita e cada bolo pode ser usado/ir para pessoa diferente (entrada e sa\u00eddas). Vamos ver como usar port map com um exemplo a seguir, nesse exemplo possu\u00edmos dois arquivos modulo2.vhd e modulo1.vhd , e desejamos utilizar o modulo1 dentro do componente 2 (modulo2): ------------------- i1 | -------- | o1 -->|--->| modulo1|-----|--> i2 | -->| | | -->|/ -------- | | modulo2 | ------------------- -- `modulo1.vhd` entity modulo1 is port ( a , b : in std_logic ; x : out std_logic ); end entity ; architecture rtl OF modulo1 IS begin x <= a xor b ; end architecture ; -- `modulo2.vhd` entity modulo2 is port ( i1 , i2 : in std_logic ; o1 : out std_logic ); end entity ; architecture rtl OF modulo2 IS -- Aqui devemos fazer a declara\u00e7\u00e3o do componente -- que queremos utilizar, a declara\u00e7\u00e3o -- tem que ser igual a entidade do componente -- original, mas trocando a palavra `entity` -- pelo keyword `component` component modulo1 is port ( a , b : in std_logic ; x : out std_logic ); end component ; begin -- Agora com o componente 'criado' -- podemos utilizar no nosso projeto -- -- podemos dar um 'nome' a intancia do componente -- | -- | | nome do componente a ser usado -- v v u1 : modulo1 port map ( a => i1 , -- o sinal a do componente \u00e9 conectado no sinal i1 b => i2 , -- o sinal a do componente \u00e9 conectado no sinal i1 x => o1 -- o sinal a do componente \u00e9 conectado no sinal i1 ); end architecture ; Tip O nome da inst\u00e2ncia n\u00e3o pode repetir ( u1 , ...) Podemos instanciar a quantidade de componente que desejarmos (vai depender do tamanho da FPGA) Nenhuma porta de entrada pode ficar vazia! Voc\u00ea n\u00e3o precisa ligar todas sa\u00eddas. Para deixar uma sa\u00edda desconectada utilize o keyword OPEN : vhdl u1: modulo1 port map( a => OPEN, N\u00e3o podemos aplicar opera\u00e7\u00f5es no port map : vhdl u1: modulo1 port map( a => i1 and i2, Evitar a nota\u00e7\u00e3o de port map que n\u00e3o indica qual porta vai para onde: u1 : modulo1 port map ( i1 , i2 , o1 ); As vezes \u00e9 necess\u00e1rio criarmos sinais ( signals ) para atribuirmos aos componentes Video-Exemplo: Construindo um Adder de 4-bits usando FullAdder de 1-bit \u00b6 Vers\u00e3o Texto - Exemplo: Construindo um Adder de 4-bits usando FullAdder de 1-bit \u00b6 Neste exemplo vamos ver a elabora\u00e7\u00e3o de um somador ( adder ) de 4-bits atr\u00e1ves do uso de v\u00e1rios somadores de 1-bit. Suponha que voc\u00ea j\u00e1 tenha um somador pronto por\u00e9m o mesmo \u00e9 apenas de 1-bit, criar um somador de 4-bits do zero, pode ser uma tarefa trabalhosa, elaborar uma tabela verdade de 2^4 = 16 linhas, econtrar 4 sa\u00eddas distintas (cada bit de sa\u00edda), enfim... ser\u00e1 que n\u00e3o \u00e9 poss\u00edvel usar o conceito que vimos de port-map anteriormente e multiplos somadores para obter o desejado? Sim, \u00e9 poss\u00edvel, desde que nosso somador de 1-bit seja um Full-Adder, lembre-se que a principal diferen\u00e7a de um Full-Adder e um Half-Adder, \u00e9 a presen\u00e7a de uma entrada de Carry In, que permite que a liga\u00e7\u00e3o em cascata de v\u00e1rios somadores. Portanto, o nosso somador de 4-bits, nada mais ser\u00e1 que uma caixa preta que dentro ter\u00e1 4 somadores de 1-bit realizando o trabalho, para o usu\u00e1rio final, que ir\u00e1 utilizar o componente isto ficar\u00e1 transparente e o mesmo n\u00e3o saber\u00e1 deste detalhe. Vamos criar nosso componente Somador de 4-bits, Adder.vhdl e definir suas entradas e sa\u00eddas (4-bits). entity Adder is port ( X : in std_logic_vector ( 3 downto 0 ); Y : in std_logic_vector ( 3 downto 0 ); Z : out std_logic_vector ( 3 downto 0 ) ); end Adder ; architecture archAdder of Adder is begin end archAdder ; Agora suponha que temos o arquivo de nosso FullAdder de 1-bit, FullAdder1.vhdl e que tenha a defini\u00e7\u00e3o (entidade da seguinte forma): entity FullAdder1 is port ( X : in std_logic ; Y : in std_logic ; Cin : in std_logic ; Z : out std_logic ; Cout : out std_logic ); end FullAdder1 ; Observe que n\u00f3s preocupamos apenas em ver a entidade (onde existem as entradas e sa\u00eddas). Quer dizer que agora podemos usar a entidade FullAdder1 diretamente no Adder ? N\u00e3o ainda! O componente Adder n\u00e3o conhece nenhum FullAdder1 ! para poder usar. Por isto devemos declarar na arquitetura do Adder que existe um componente com este nome e com tais entradas e sa\u00eddas dispon\u00edveis para uso! Para isso usamos a declara\u00e7\u00e3o component do VHDL, permitindo especificar os nomes e entradas. architecture archAdder of Adder is component FullAdder1 port ( -- Input ports X : in std_logic ; Y : in std_logic ; Cin : in std_logic ; -- Output ports Z : out std_logic ; Cout : out std_logic ); end component ; begin end archAdder ; Pronto! Agora podemos usar o componente FullAdder1 , na verdade, podemos usar v\u00e1rios! Isso mesmo, podemos criar v\u00e1rias inst\u00e2ncias deste FullAdder1 , vamos precisar de 4. A forma de fazer isto em VHDL, \u00e9 usar definir um nome de instancia, nome do componente e suas liga\u00e7\u00f5es (port-map). Sintaxe: < instance_name > : < component_name > port map ( < formal_input > => < signal > , < formal_output > => < signal > ); Exemplo para os nosso 4 FAs (por enquanto vamos ligar apenas as entradas X, Y e sa\u00eddas Z sem se preocupar com os Cin/Cout). A0 : FullAdder1 port map ( X => X ( 0 ), Y => Y ( 0 ), Z => Z ( 0 ) ); A1 : FullAdder1 port map ( X => X ( 1 ), Y => Y ( 1 ), Z => Z ( 1 ) ); A2 : FullAdder1 port map ( X => X ( 2 ), Y => Y ( 2 ), Z => Z ( 2 ) ); A3 : FullAdder1 port map ( X => X ( 3 ), Y => Y ( 3 ), Z => Z ( 3 ) ); Observe que conseguimos facilmente instanciar 4 somadores de 1-bit! Outro detalhe importante no port-map \u00e9 que sempre o sinal a esquerda pertence ao componente e este \u00e9 conectado ao sinal da direita (pertence ao arquivo atual). Por isto podemos ligar X a X(0), sem dar erro de nome duplicado, pois o VHDL \u00e9 espertinho e sabe que o primeiro X se refere ao X do componente e o segundo, ao do nosso Adder de 4-bits. Agora precisamos ligar os Carrys para que nosso somador some corretamente, lembre, o primeiro somador (bit 0), ter\u00e1 carry de entrada (Cin) zero (0), e os demais somadores receberam o carry de sa\u00edda (Cout) do somador anterior. No entanto no VHDL n\u00e3o \u00e9 poss\u00edvel ligar diretamente entre componentes diferentes!! E agora? Existem no VHDL, sinais virtuais, literalmente chamados signals , podemos pensar nestes sinais como um fio , cuidado, eles n\u00e3o s\u00e3o variav\u00e9is (o VHDL possui elas, por\u00e9m tem algumas pecularidades diferentes que n\u00e3o iremos abordar aqui) Os sinais devem serem declarados dentro de um arquitetura com a seguinte sintaxe signal < name > : < type > ; Como teremos 4 carrys de sa\u00edda, podemos usar ent\u00e3o signal carry : std_logic_vector ( 3 downto 0 ); Agora basta ligar o carry dos somadores intermediarios e o final, no anterior (n\u00e3o esquece de ligar o carry de entrada e sa\u00edda). Exemplo dos dois primeiros somadores. A0 : FullAdder1 port map ( X => X ( 0 ), Y => Y ( 0 ), Cin => '0' , Z => Z ( 0 ), Cout => carry ( 0 ) ); A1 : FullAdder1 port map ( X => X ( 1 ), Y => Y ( 1 ), Cin => carry ( 0 ), Z => Z ( 1 ), Cout => carry ( 1 ) ); ... Feito isto, seu somador est\u00e1 completo, basta utiliza-lo em um TopLevel ou outro VHDL que desejar para ver os resultados!","title":"port map"},{"location":"VHDL-port-map/#port-map","text":"Esse texto explica como realizar o port map em VHDL, t\u00e9cnica que permite o reaproveitamento de m\u00f3dulos e o desenvolvimento hier\u00e1rquico.","title":"port map"},{"location":"VHDL-port-map/#desenvolvimento-hierarquico","text":"\u00c9 uma t\u00e9cnica de organiza\u00e7\u00e3o de projeto onde s\u00e3o desenvolvidos pequenos m\u00f3dulos e esses m\u00f3dulos fazem parte de um sistema maior, que por sua vez, fazem parte de algo muito mais complexo. As vantagens de um desenvolvimento desse tipo s\u00e3o: Facilidade em realizar testes e valida\u00e7\u00e3o Cada m\u00f3dulo \u00e9 testado independentemente Trabalho em equipe A partir do momento que as interfaces s\u00e3o bem estabelecidas, cada um do time pode desenvolver um m\u00f3dulo Ferramentas gostam / se adaptam bem As ferramentas de desenvolvimento conseguem otimizar o hardware melhor Reaproveitamento de m\u00f3dulos Muito mais f\u00e1cil para reaproveitar outros m\u00f3dulos. Leitura extra https://www.intel.com/content/www/us/en/programmable/support/support-resources/design-examples/design-software/vhdl/v_hier.html Fonte: https://www.embedded.com/the-art-of-fpga-construction/","title":"Desenvolvimento hier\u00e1rquico"},{"location":"VHDL-port-map/#port-map_1","text":"port map \u00e9 a maneira em VHDL de reaproveitamos uma entidade definida em outro lugar no nosso arquivo. Pensar em port map como uma fun\u00e7\u00e3o n\u00e3o \u00e9 de todo errado, mas devesse notar que quando usamos port map estamos criando uma c\u00f3pia do hardware que \u00e9 descrito pela entidade usada, isso \u00e9 diferente de uma fun\u00e7\u00e3o em Python, que reaproveita o mesmo trecho de c\u00f3digo para cada chamada de fun\u00e7\u00e3o. \u00c9 mais apropriado pensar que a descri\u00e7\u00e3o de um hardware \u00e9 uma receita (que vemos na architecture ), o port map seria como o bolo, voc\u00ea pode ter v\u00e1rios bolos com a mesma receita e cada bolo pode ser usado/ir para pessoa diferente (entrada e sa\u00eddas). Vamos ver como usar port map com um exemplo a seguir, nesse exemplo possu\u00edmos dois arquivos modulo2.vhd e modulo1.vhd , e desejamos utilizar o modulo1 dentro do componente 2 (modulo2): ------------------- i1 | -------- | o1 -->|--->| modulo1|-----|--> i2 | -->| | | -->|/ -------- | | modulo2 | ------------------- -- `modulo1.vhd` entity modulo1 is port ( a , b : in std_logic ; x : out std_logic ); end entity ; architecture rtl OF modulo1 IS begin x <= a xor b ; end architecture ; -- `modulo2.vhd` entity modulo2 is port ( i1 , i2 : in std_logic ; o1 : out std_logic ); end entity ; architecture rtl OF modulo2 IS -- Aqui devemos fazer a declara\u00e7\u00e3o do componente -- que queremos utilizar, a declara\u00e7\u00e3o -- tem que ser igual a entidade do componente -- original, mas trocando a palavra `entity` -- pelo keyword `component` component modulo1 is port ( a , b : in std_logic ; x : out std_logic ); end component ; begin -- Agora com o componente 'criado' -- podemos utilizar no nosso projeto -- -- podemos dar um 'nome' a intancia do componente -- | -- | | nome do componente a ser usado -- v v u1 : modulo1 port map ( a => i1 , -- o sinal a do componente \u00e9 conectado no sinal i1 b => i2 , -- o sinal a do componente \u00e9 conectado no sinal i1 x => o1 -- o sinal a do componente \u00e9 conectado no sinal i1 ); end architecture ; Tip O nome da inst\u00e2ncia n\u00e3o pode repetir ( u1 , ...) Podemos instanciar a quantidade de componente que desejarmos (vai depender do tamanho da FPGA) Nenhuma porta de entrada pode ficar vazia! Voc\u00ea n\u00e3o precisa ligar todas sa\u00eddas. Para deixar uma sa\u00edda desconectada utilize o keyword OPEN : vhdl u1: modulo1 port map( a => OPEN, N\u00e3o podemos aplicar opera\u00e7\u00f5es no port map : vhdl u1: modulo1 port map( a => i1 and i2, Evitar a nota\u00e7\u00e3o de port map que n\u00e3o indica qual porta vai para onde: u1 : modulo1 port map ( i1 , i2 , o1 ); As vezes \u00e9 necess\u00e1rio criarmos sinais ( signals ) para atribuirmos aos componentes","title":"port map"},{"location":"VHDL-port-map/#video-exemplo-construindo-um-adder-de-4-bits-usando-fulladder-de-1-bit","text":"","title":"Video-Exemplo: Construindo um Adder de 4-bits usando FullAdder de 1-bit"},{"location":"VHDL-port-map/#versao-texto-exemplo-construindo-um-adder-de-4-bits-usando-fulladder-de-1-bit","text":"Neste exemplo vamos ver a elabora\u00e7\u00e3o de um somador ( adder ) de 4-bits atr\u00e1ves do uso de v\u00e1rios somadores de 1-bit. Suponha que voc\u00ea j\u00e1 tenha um somador pronto por\u00e9m o mesmo \u00e9 apenas de 1-bit, criar um somador de 4-bits do zero, pode ser uma tarefa trabalhosa, elaborar uma tabela verdade de 2^4 = 16 linhas, econtrar 4 sa\u00eddas distintas (cada bit de sa\u00edda), enfim... ser\u00e1 que n\u00e3o \u00e9 poss\u00edvel usar o conceito que vimos de port-map anteriormente e multiplos somadores para obter o desejado? Sim, \u00e9 poss\u00edvel, desde que nosso somador de 1-bit seja um Full-Adder, lembre-se que a principal diferen\u00e7a de um Full-Adder e um Half-Adder, \u00e9 a presen\u00e7a de uma entrada de Carry In, que permite que a liga\u00e7\u00e3o em cascata de v\u00e1rios somadores. Portanto, o nosso somador de 4-bits, nada mais ser\u00e1 que uma caixa preta que dentro ter\u00e1 4 somadores de 1-bit realizando o trabalho, para o usu\u00e1rio final, que ir\u00e1 utilizar o componente isto ficar\u00e1 transparente e o mesmo n\u00e3o saber\u00e1 deste detalhe. Vamos criar nosso componente Somador de 4-bits, Adder.vhdl e definir suas entradas e sa\u00eddas (4-bits). entity Adder is port ( X : in std_logic_vector ( 3 downto 0 ); Y : in std_logic_vector ( 3 downto 0 ); Z : out std_logic_vector ( 3 downto 0 ) ); end Adder ; architecture archAdder of Adder is begin end archAdder ; Agora suponha que temos o arquivo de nosso FullAdder de 1-bit, FullAdder1.vhdl e que tenha a defini\u00e7\u00e3o (entidade da seguinte forma): entity FullAdder1 is port ( X : in std_logic ; Y : in std_logic ; Cin : in std_logic ; Z : out std_logic ; Cout : out std_logic ); end FullAdder1 ; Observe que n\u00f3s preocupamos apenas em ver a entidade (onde existem as entradas e sa\u00eddas). Quer dizer que agora podemos usar a entidade FullAdder1 diretamente no Adder ? N\u00e3o ainda! O componente Adder n\u00e3o conhece nenhum FullAdder1 ! para poder usar. Por isto devemos declarar na arquitetura do Adder que existe um componente com este nome e com tais entradas e sa\u00eddas dispon\u00edveis para uso! Para isso usamos a declara\u00e7\u00e3o component do VHDL, permitindo especificar os nomes e entradas. architecture archAdder of Adder is component FullAdder1 port ( -- Input ports X : in std_logic ; Y : in std_logic ; Cin : in std_logic ; -- Output ports Z : out std_logic ; Cout : out std_logic ); end component ; begin end archAdder ; Pronto! Agora podemos usar o componente FullAdder1 , na verdade, podemos usar v\u00e1rios! Isso mesmo, podemos criar v\u00e1rias inst\u00e2ncias deste FullAdder1 , vamos precisar de 4. A forma de fazer isto em VHDL, \u00e9 usar definir um nome de instancia, nome do componente e suas liga\u00e7\u00f5es (port-map). Sintaxe: < instance_name > : < component_name > port map ( < formal_input > => < signal > , < formal_output > => < signal > ); Exemplo para os nosso 4 FAs (por enquanto vamos ligar apenas as entradas X, Y e sa\u00eddas Z sem se preocupar com os Cin/Cout). A0 : FullAdder1 port map ( X => X ( 0 ), Y => Y ( 0 ), Z => Z ( 0 ) ); A1 : FullAdder1 port map ( X => X ( 1 ), Y => Y ( 1 ), Z => Z ( 1 ) ); A2 : FullAdder1 port map ( X => X ( 2 ), Y => Y ( 2 ), Z => Z ( 2 ) ); A3 : FullAdder1 port map ( X => X ( 3 ), Y => Y ( 3 ), Z => Z ( 3 ) ); Observe que conseguimos facilmente instanciar 4 somadores de 1-bit! Outro detalhe importante no port-map \u00e9 que sempre o sinal a esquerda pertence ao componente e este \u00e9 conectado ao sinal da direita (pertence ao arquivo atual). Por isto podemos ligar X a X(0), sem dar erro de nome duplicado, pois o VHDL \u00e9 espertinho e sabe que o primeiro X se refere ao X do componente e o segundo, ao do nosso Adder de 4-bits. Agora precisamos ligar os Carrys para que nosso somador some corretamente, lembre, o primeiro somador (bit 0), ter\u00e1 carry de entrada (Cin) zero (0), e os demais somadores receberam o carry de sa\u00edda (Cout) do somador anterior. No entanto no VHDL n\u00e3o \u00e9 poss\u00edvel ligar diretamente entre componentes diferentes!! E agora? Existem no VHDL, sinais virtuais, literalmente chamados signals , podemos pensar nestes sinais como um fio , cuidado, eles n\u00e3o s\u00e3o variav\u00e9is (o VHDL possui elas, por\u00e9m tem algumas pecularidades diferentes que n\u00e3o iremos abordar aqui) Os sinais devem serem declarados dentro de um arquitetura com a seguinte sintaxe signal < name > : < type > ; Como teremos 4 carrys de sa\u00edda, podemos usar ent\u00e3o signal carry : std_logic_vector ( 3 downto 0 ); Agora basta ligar o carry dos somadores intermediarios e o final, no anterior (n\u00e3o esquece de ligar o carry de entrada e sa\u00edda). Exemplo dos dois primeiros somadores. A0 : FullAdder1 port map ( X => X ( 0 ), Y => Y ( 0 ), Cin => '0' , Z => Z ( 0 ), Cout => carry ( 0 ) ); A1 : FullAdder1 port map ( X => X ( 1 ), Y => Y ( 1 ), Cin => carry ( 0 ), Z => Z ( 1 ), Cout => carry ( 1 ) ); ... Feito isto, seu somador est\u00e1 completo, basta utiliza-lo em um TopLevel ou outro VHDL que desejar para ver os resultados!","title":"Vers\u00e3o Texto - Exemplo: Construindo um Adder de 4-bits usando FullAdder de 1-bit"},{"location":"VMtranslator-Lab-1-old/","text":"Lab 18: Vm Translator \u00b6 O VMTranslator \u00e9 um programa escrito em Java que faz a tradu\u00e7\u00e3o de c\u00f3digos escrito na linguagem VM definida no curso e traduz para linguagem Assembly do computador Z01. Testando \u00b6 Para testar, basta executar o comando: $ ./testeVMtraslator.py O teste executa: genJAR.py | | V VMTranslator Assembler Z01-Simulator ------------------ arquivo.vm -------------> .nasm -----------> .hack > ------------> - Verifica sa\u00edda - ------------------ ^ | |- Desenvolvido no projeto I Para isso foi criado alguns programas ( H-VM/src/vmExamples/ ) em VM muito espec\u00edficos que testam somente um comando, ou uma parte da tradu\u00e7\u00e3o do VMTranslator . Por exemplo o teste SimpleAdd possui somente a seguinte linha: add Esse teste foi criado para testar o Code.writeArithmetic no caso de um comando add . Para isso, antes da execu\u00e7\u00e3o desse c\u00f3digo, o simulador faz a inicializa\u00e7\u00e3o da RAM, simulando valores na pilha e j\u00e1 configurando o SP para uma situa\u00e7\u00e3o real. A mem\u00f3ria antes da execu\u00e7\u00e3o da instru\u00e7\u00e3o add \u00e9 a seguinte: 0 : 0000000100000010; 256 : 0000000000000010; 257 : 0000000000000100; 258 : 0000000000000000; Note I-VM/tests/tst/SimpleAdd/SimpleAdd0_in.mif Espera-se o resultado final ap\u00f3s a execu\u00e7\u00e3o do comando add : 0 : 0000000100000001 256 : 0000000000000110 A seguir uma lista de como cada parte do VMTranslator \u00e9 testado: code.writePushPop pop SimplePopTemp : pop temp ... SimplePopLocal : pop local ... SimplePopThat : pop that ... SimplePopThis : pop this ... push SimplePushConst : push constant .... SimplePushTemp : push tempo .... SimplePushLocal : push local .... SimplePushArg : push argument ... SimplePushThis : push this ... SimplePushThat : push that ... code.writeArithmetic SimpleAdd : add SimpleNeg : neg SimpleSub : sub SimpleEq : eq SimpleGt : gt SimpleLt : lt SimpleAnd : and SimpleOr : or Implementando \u00b6 Vamos agora fazer a implementa\u00e7\u00e3o do comando push constant 3 no VMtranslator. Crie o projeto no IntelliJ da mesma maneira que do projeto do Assembler o arquivo maven est\u00e1 na pasta I-VMTranslator/VMtranslator Nesse projeto voc\u00eas ter\u00e3o que mexer apenas no code.java , os demais m\u00f3dulos j\u00e1 est\u00e3o prontos (similar ao projeto do Assembler, temos nesse o parser , VMTranslator , ...). Editando o code.java \u00b6 No code.java encontre a implementa\u00e7\u00e3o do m\u00e9todo push , linha 121 public void writePushPop ( Parser . CommandType command , String segment , Integer index ) { ... ... ... else if ( command == Parser . CommandType . C_PUSH ) { commands . add ( String . format ( \"; %d - PUSH %s %d\" , lineCode ++ , segment , index )); if ( segment . equals ( \"constant\" )) { } Essa m\u00e9todo \u00e9 chamado sempre que um comando push/pop for interpretado, exemplo: push constant 3 Os par\u00e2metros recebidos s\u00e3o: command: C_PUSH segment: constant Index: 3 Precisamos agora traduzir a execu\u00e7\u00e3o desse comando em vm para nasm para que ele possa ser executado no nosso hardawre, isso \u00e9 pode ser feito seguindos os passos a seguir: Carregar o valor da constante em um registrador dispon\u00edvel Busca no StackPointer(SP) o endere\u00e7o da posi\u00e7\u00e3o vazia da stack Mover o valor do Index (no caso 3) para essa posi\u00e7\u00e3o vazia Incrementa SP em um Implementando Fa\u00e7a a tradu\u00e7\u00e3o do comando push constant nnn de VM para nasm, para cada linha nasm voc\u00ea deve chamar a fun\u00e7\u00e3o commands.add , como no exemplo a seguir: commands . add ( \"movw %A, %D\" ); A tradu\u00e7\u00e3o deve ser escrita dentro do if (segment.equals(\"constant\")) {....} Solu\u00e7\u00e3o // carrega a constant em %A e move para %D commands . add ( \"leaw $\" + index + \", %A\" ); commands . add ( \"movw %A, %D\" ); // carrega o calor do SP e move a constant // para o topo da pilha commands . add ( \"leaw $0,%A\" ); commands . add ( \"movw (%A),%A\" ); commands . add ( \"movw %D,(%A)\" ); // altera stack pointer: SP = SP + 1 commands . add ( \"leaw $0,%A\" ); commands . add ( \"movw (%A),%D\" ); commands . add ( \"incw %D\" ); commands . add ( \"movw %D, (%A)\" ); Para testar o projeto VMtranslator, n\u00e3o h\u00e1 testes unit\u00e1rios dispon\u00edveis, no entanto, podemos j\u00e1 realizar o teste de integra\u00e7\u00e3o direto (simula\u00e7\u00e3o), usando o testeVMtranslator.py . No caso do push constant , temos o teste SimplePushConst, bastando apenas habilitar este teste na config ( tests/config.txt ). Se observar o arquivo, ir\u00e1 perceber que existem diversos outros testes b\u00e1sicos, como SimplePushLocal , SimplePopLocal e outros que podem ser habilitados conforme estes recursos forem implementados no seu VMtranslator.","title":"Lab 18: Vm Translator"},{"location":"VMtranslator-Lab-1-old/#lab-18-vm-translator","text":"O VMTranslator \u00e9 um programa escrito em Java que faz a tradu\u00e7\u00e3o de c\u00f3digos escrito na linguagem VM definida no curso e traduz para linguagem Assembly do computador Z01.","title":"Lab 18: Vm Translator"},{"location":"VMtranslator-Lab-1-old/#testando","text":"Para testar, basta executar o comando: $ ./testeVMtraslator.py O teste executa: genJAR.py | | V VMTranslator Assembler Z01-Simulator ------------------ arquivo.vm -------------> .nasm -----------> .hack > ------------> - Verifica sa\u00edda - ------------------ ^ | |- Desenvolvido no projeto I Para isso foi criado alguns programas ( H-VM/src/vmExamples/ ) em VM muito espec\u00edficos que testam somente um comando, ou uma parte da tradu\u00e7\u00e3o do VMTranslator . Por exemplo o teste SimpleAdd possui somente a seguinte linha: add Esse teste foi criado para testar o Code.writeArithmetic no caso de um comando add . Para isso, antes da execu\u00e7\u00e3o desse c\u00f3digo, o simulador faz a inicializa\u00e7\u00e3o da RAM, simulando valores na pilha e j\u00e1 configurando o SP para uma situa\u00e7\u00e3o real. A mem\u00f3ria antes da execu\u00e7\u00e3o da instru\u00e7\u00e3o add \u00e9 a seguinte: 0 : 0000000100000010; 256 : 0000000000000010; 257 : 0000000000000100; 258 : 0000000000000000; Note I-VM/tests/tst/SimpleAdd/SimpleAdd0_in.mif Espera-se o resultado final ap\u00f3s a execu\u00e7\u00e3o do comando add : 0 : 0000000100000001 256 : 0000000000000110 A seguir uma lista de como cada parte do VMTranslator \u00e9 testado: code.writePushPop pop SimplePopTemp : pop temp ... SimplePopLocal : pop local ... SimplePopThat : pop that ... SimplePopThis : pop this ... push SimplePushConst : push constant .... SimplePushTemp : push tempo .... SimplePushLocal : push local .... SimplePushArg : push argument ... SimplePushThis : push this ... SimplePushThat : push that ... code.writeArithmetic SimpleAdd : add SimpleNeg : neg SimpleSub : sub SimpleEq : eq SimpleGt : gt SimpleLt : lt SimpleAnd : and SimpleOr : or","title":"Testando"},{"location":"VMtranslator-Lab-1-old/#implementando","text":"Vamos agora fazer a implementa\u00e7\u00e3o do comando push constant 3 no VMtranslator. Crie o projeto no IntelliJ da mesma maneira que do projeto do Assembler o arquivo maven est\u00e1 na pasta I-VMTranslator/VMtranslator Nesse projeto voc\u00eas ter\u00e3o que mexer apenas no code.java , os demais m\u00f3dulos j\u00e1 est\u00e3o prontos (similar ao projeto do Assembler, temos nesse o parser , VMTranslator , ...).","title":"Implementando"},{"location":"VMtranslator-Lab-1-old/#editando-o-codejava","text":"No code.java encontre a implementa\u00e7\u00e3o do m\u00e9todo push , linha 121 public void writePushPop ( Parser . CommandType command , String segment , Integer index ) { ... ... ... else if ( command == Parser . CommandType . C_PUSH ) { commands . add ( String . format ( \"; %d - PUSH %s %d\" , lineCode ++ , segment , index )); if ( segment . equals ( \"constant\" )) { } Essa m\u00e9todo \u00e9 chamado sempre que um comando push/pop for interpretado, exemplo: push constant 3 Os par\u00e2metros recebidos s\u00e3o: command: C_PUSH segment: constant Index: 3 Precisamos agora traduzir a execu\u00e7\u00e3o desse comando em vm para nasm para que ele possa ser executado no nosso hardawre, isso \u00e9 pode ser feito seguindos os passos a seguir: Carregar o valor da constante em um registrador dispon\u00edvel Busca no StackPointer(SP) o endere\u00e7o da posi\u00e7\u00e3o vazia da stack Mover o valor do Index (no caso 3) para essa posi\u00e7\u00e3o vazia Incrementa SP em um Implementando Fa\u00e7a a tradu\u00e7\u00e3o do comando push constant nnn de VM para nasm, para cada linha nasm voc\u00ea deve chamar a fun\u00e7\u00e3o commands.add , como no exemplo a seguir: commands . add ( \"movw %A, %D\" ); A tradu\u00e7\u00e3o deve ser escrita dentro do if (segment.equals(\"constant\")) {....} Solu\u00e7\u00e3o // carrega a constant em %A e move para %D commands . add ( \"leaw $\" + index + \", %A\" ); commands . add ( \"movw %A, %D\" ); // carrega o calor do SP e move a constant // para o topo da pilha commands . add ( \"leaw $0,%A\" ); commands . add ( \"movw (%A),%A\" ); commands . add ( \"movw %D,(%A)\" ); // altera stack pointer: SP = SP + 1 commands . add ( \"leaw $0,%A\" ); commands . add ( \"movw (%A),%D\" ); commands . add ( \"incw %D\" ); commands . add ( \"movw %D, (%A)\" ); Para testar o projeto VMtranslator, n\u00e3o h\u00e1 testes unit\u00e1rios dispon\u00edveis, no entanto, podemos j\u00e1 realizar o teste de integra\u00e7\u00e3o direto (simula\u00e7\u00e3o), usando o testeVMtranslator.py . No caso do push constant , temos o teste SimplePushConst, bastando apenas habilitar este teste na config ( tests/config.txt ). Se observar o arquivo, ir\u00e1 perceber que existem diversos outros testes b\u00e1sicos, como SimplePushLocal , SimplePopLocal e outros que podem ser habilitados conforme estes recursos forem implementados no seu VMtranslator.","title":"Editando o code.java"},{"location":"VMtranslator-Lab-1/","text":"Lab 18: Vm Translator - Praticando \u00b6 O VMTranslator \u00e9 um programa escrito em Java que faz a tradu\u00e7\u00e3o de c\u00f3digos escrito na linguagem VM definida no curso e traduz para linguagem Assembly do computador Z01. Praticando pilha \u00b6 Acesse a planilha no google sheets , fa\u00e7a uma c\u00f3pia para a sua conta e comece a estudar e modificar ela, a primeira parte \u00e9 para voc\u00eas trabalharem com o conceito de pilha e frame, para isso, fa\u00e7a apenas a primeira aba (pilha). Quando acabar volte para esse lab (\u00e9 para fazer a primeira aba apenas) Praticando tradu\u00e7\u00e3o VM -> nasm \u00b6 Antes de come\u00e7ar Esse laborat\u00f3rio n\u00e3o faz parte de um projeto, mas ser\u00e1 necess\u00e1rio atualizar o reposit\u00f3rio de voc\u00eas com o Z01 para buscarem a nova pasta ( upstream ). Escolham um do grupo para fazer isso, ele n\u00e3o ser\u00e1 um scrum master! N\u00e3o seguir sem realizar a etapa anterior. Abra novamente a planilha , agora v\u00e1 para a aba Translator e siga os passos ali indicados. Como o teste funciona? O teste executa: genJAR.py | | V VMTranslator Assembler Z01-Simulator ------------------ arquivo.vm -------------> .nasm -----------> .hack > ------------> - Verifica sa\u00edda - ------------------ ^ | |- Desenvolvido no projeto I Para isso foi criado alguns programas ( H-VM/src/vmExamples/ ) em VM muito espec\u00edficos que testam somente um comando, ou uma parte da tradu\u00e7\u00e3o do VMTranslator . Por exemplo o teste SimpleAdd possui somente a seguinte linha: add Esse teste foi criado para testar o Code.writeArithmetic no caso de um comando add . Para isso, antes da execu\u00e7\u00e3o desse c\u00f3digo, o simulador faz a inicializa\u00e7\u00e3o da RAM, simulando valores na pilha e j\u00e1 configurando o SP para uma situa\u00e7\u00e3o real. A mem\u00f3ria antes da execu\u00e7\u00e3o da instru\u00e7\u00e3o add \u00e9 a seguinte: 0 : 0000000100000010; 256 : 0000000000000010; 257 : 0000000000000100; 258 : 0000000000000000; Note I-VM/tests/tst/SimpleAdd/SimpleAdd0_in.mif Espera-se o resultado final ap\u00f3s a execu\u00e7\u00e3o do comando add : 0 : 0000000100000001 256 : 0000000000000110 Nesse projeto voc\u00eas ter\u00e3o que mexer apenas no code.java , os demais m\u00f3dulos j\u00e1 est\u00e3o prontos (similar ao projeto do Assembler, temos nesse o parser , VMTranslator , ...).","title":"Lab 18: Vm Translator - Praticando"},{"location":"VMtranslator-Lab-1/#lab-18-vm-translator-praticando","text":"O VMTranslator \u00e9 um programa escrito em Java que faz a tradu\u00e7\u00e3o de c\u00f3digos escrito na linguagem VM definida no curso e traduz para linguagem Assembly do computador Z01.","title":"Lab 18: Vm Translator - Praticando"},{"location":"VMtranslator-Lab-1/#praticando-pilha","text":"Acesse a planilha no google sheets , fa\u00e7a uma c\u00f3pia para a sua conta e comece a estudar e modificar ela, a primeira parte \u00e9 para voc\u00eas trabalharem com o conceito de pilha e frame, para isso, fa\u00e7a apenas a primeira aba (pilha). Quando acabar volte para esse lab (\u00e9 para fazer a primeira aba apenas)","title":"Praticando pilha"},{"location":"VMtranslator-Lab-1/#praticando-traducao-vm-nasm","text":"Antes de come\u00e7ar Esse laborat\u00f3rio n\u00e3o faz parte de um projeto, mas ser\u00e1 necess\u00e1rio atualizar o reposit\u00f3rio de voc\u00eas com o Z01 para buscarem a nova pasta ( upstream ). Escolham um do grupo para fazer isso, ele n\u00e3o ser\u00e1 um scrum master! N\u00e3o seguir sem realizar a etapa anterior. Abra novamente a planilha , agora v\u00e1 para a aba Translator e siga os passos ali indicados. Como o teste funciona? O teste executa: genJAR.py | | V VMTranslator Assembler Z01-Simulator ------------------ arquivo.vm -------------> .nasm -----------> .hack > ------------> - Verifica sa\u00edda - ------------------ ^ | |- Desenvolvido no projeto I Para isso foi criado alguns programas ( H-VM/src/vmExamples/ ) em VM muito espec\u00edficos que testam somente um comando, ou uma parte da tradu\u00e7\u00e3o do VMTranslator . Por exemplo o teste SimpleAdd possui somente a seguinte linha: add Esse teste foi criado para testar o Code.writeArithmetic no caso de um comando add . Para isso, antes da execu\u00e7\u00e3o desse c\u00f3digo, o simulador faz a inicializa\u00e7\u00e3o da RAM, simulando valores na pilha e j\u00e1 configurando o SP para uma situa\u00e7\u00e3o real. A mem\u00f3ria antes da execu\u00e7\u00e3o da instru\u00e7\u00e3o add \u00e9 a seguinte: 0 : 0000000100000010; 256 : 0000000000000010; 257 : 0000000000000100; 258 : 0000000000000000; Note I-VM/tests/tst/SimpleAdd/SimpleAdd0_in.mif Espera-se o resultado final ap\u00f3s a execu\u00e7\u00e3o do comando add : 0 : 0000000100000001 256 : 0000000000000110 Nesse projeto voc\u00eas ter\u00e3o que mexer apenas no code.java , os demais m\u00f3dulos j\u00e1 est\u00e3o prontos (similar ao projeto do Assembler, temos nesse o parser , VMTranslator , ...).","title":"Praticando tradu\u00e7\u00e3o VM -&gt; nasm"},{"location":"X-Processadores-Projeto/","text":"Mundo Real \u00b6 Entregar at\u00e9 dia 09/12 HW SW 10 10 Esse projeto extra optativo (individual) fornece 10 pontos extras de Hardware e 10 pontos extras de Software . (10 HW) Processadores \u00b6 Voc\u00ea dever\u00e1 escolher um dos processadores listados a seguir: ARM Cortex M0 RISC V AVR Microchip PIC PowerPC SPARC V8 ZIP CPU OpenRISC Intel 8051 ESP8266 PIC16x Warning N\u00e3o pode repetir dentro do grupo! DPs: N\u00e3o pode ser o mesmo do semestre passado Voc\u00eas devem entregar um v\u00eddeo que explica a CPU em quest\u00e3o, neste v\u00eddeo (de no m\u00e1ximo 10 minutos) voc\u00eas devem explicar: Hist\u00f3rico Hist\u00f3ria da arquitetura Pessoas/ empresas respons\u00e1veis Impacto hist\u00f3rico, impacto nos concorrentes/ comunidade/ Curiosidades Uso atual Dispositivos e empresas que ainda fazem uso da arquitetura Arquitetura Descreva a arquitetura interna da CPU Quantos bits de largura? 8/16/32/.. Quantidade de registradores Opera\u00e7\u00f5es da ULA (se for muitas, pode pegar algumas) A arquitetura \u00e9 CISC ou RISC? Como o Program Counter (PC) funciona? Como \u00e9 realizado o acesso a mem\u00f3ria nessa arquitetura? (registrador-registrador, registrador-mem\u00f3ria, mem\u00f3ria-mem\u00f3ria) Pode fazer opera\u00e7\u00f5es direto na mem\u00f3ria? Ou temos que carregar para os registradores antes? Especificidades Compara\u00e7\u00e3o com o Z01.1 Muito importante sempre que poss\u00edvel realizar uma compara\u00e7\u00e3o com a nossa CPU Instru\u00e7\u00f5es Descritivo das instru\u00e7\u00f5es e seus padr\u00f5es Quantidade total de instru\u00e7\u00f5es Diferen\u00e7a com rela\u00e7\u00e3o ao Z01.1 ( 10 SW ) Comentar c\u00f3digo \u00b6 Voc\u00ea deve pegar um c\u00f3digo de exemplo do assembly da CPU escolhida e comentar ele no v\u00eddeo, explicando o que est\u00e1 fazendo. Explicar o que cada instru\u00e7\u00e3o est\u00e1 fazendo O impacto dela no hardware Muitas arquitetura possuem simulador! Interessante usar, mas n\u00e3o \u00e9 necess\u00e1rio Entrega \u00b6 Link para entrega","title":"Mundo Real"},{"location":"X-Processadores-Projeto/#mundo-real","text":"Entregar at\u00e9 dia 09/12 HW SW 10 10 Esse projeto extra optativo (individual) fornece 10 pontos extras de Hardware e 10 pontos extras de Software .","title":"Mundo Real"},{"location":"X-Processadores-Projeto/#10-hw-processadores","text":"Voc\u00ea dever\u00e1 escolher um dos processadores listados a seguir: ARM Cortex M0 RISC V AVR Microchip PIC PowerPC SPARC V8 ZIP CPU OpenRISC Intel 8051 ESP8266 PIC16x Warning N\u00e3o pode repetir dentro do grupo! DPs: N\u00e3o pode ser o mesmo do semestre passado Voc\u00eas devem entregar um v\u00eddeo que explica a CPU em quest\u00e3o, neste v\u00eddeo (de no m\u00e1ximo 10 minutos) voc\u00eas devem explicar: Hist\u00f3rico Hist\u00f3ria da arquitetura Pessoas/ empresas respons\u00e1veis Impacto hist\u00f3rico, impacto nos concorrentes/ comunidade/ Curiosidades Uso atual Dispositivos e empresas que ainda fazem uso da arquitetura Arquitetura Descreva a arquitetura interna da CPU Quantos bits de largura? 8/16/32/.. Quantidade de registradores Opera\u00e7\u00f5es da ULA (se for muitas, pode pegar algumas) A arquitetura \u00e9 CISC ou RISC? Como o Program Counter (PC) funciona? Como \u00e9 realizado o acesso a mem\u00f3ria nessa arquitetura? (registrador-registrador, registrador-mem\u00f3ria, mem\u00f3ria-mem\u00f3ria) Pode fazer opera\u00e7\u00f5es direto na mem\u00f3ria? Ou temos que carregar para os registradores antes? Especificidades Compara\u00e7\u00e3o com o Z01.1 Muito importante sempre que poss\u00edvel realizar uma compara\u00e7\u00e3o com a nossa CPU Instru\u00e7\u00f5es Descritivo das instru\u00e7\u00f5es e seus padr\u00f5es Quantidade total de instru\u00e7\u00f5es Diferen\u00e7a com rela\u00e7\u00e3o ao Z01.1","title":"(10 HW) Processadores"},{"location":"X-Processadores-Projeto/#10-sw-comentar-codigo","text":"Voc\u00ea deve pegar um c\u00f3digo de exemplo do assembly da CPU escolhida e comentar ele no v\u00eddeo, explicando o que est\u00e1 fazendo. Explicar o que cada instru\u00e7\u00e3o est\u00e1 fazendo O impacto dela no hardware Muitas arquitetura possuem simulador! Interessante usar, mas n\u00e3o \u00e9 necess\u00e1rio","title":"(10 SW) Comentar c\u00f3digo"},{"location":"X-Processadores-Projeto/#entrega","text":"Link para entrega","title":"Entrega"},{"location":"assembler-Dicas-Macro/","text":"H - Assembler - Dica Macro \u00b6 Suponha o seguinte arquivo .nasm : % macro name nPar ... .. % endmacro name : Nome do macro nPar : Quantidade de par\u00e2metros (0, 1, 2), acess\u00edvel via : par0, par1 O macro serve para facilitar o reaproveitamento de c\u00f3digos, diferente de uma fun\u00e7\u00e3o que altera o fluxo de execu\u00e7\u00e3o do c\u00f3digo para o endere\u00e7o que a fun\u00e7\u00e3o est\u00e1 salva, o macro funciona copiando o macro para a onde ele foi chamado, como no exemplo a seguir: C\u00f3digo sem macro : ; carrega 5 em D leaw $5 , %A movw %A , %D ; salva valor em RAM8 leaw $8 , %A movw %D , ( %A ) C\u00f3digo com 2 macros definidos : movCntToReg : Move uma constante (par0) para uma registrador (par1) movRegtoRAM : Move um registrador (par0) para o endere\u00e7o de mem\u00f3ria (par1). % macro movCntToReg 2 leaw par0 , %A movw %A , par1 % endmacro % macro movRegtoRAM 2 leaw par0 , %A movw par1 , ( %A ) % endmacro ; carrega 5 em D movCntToReg $D , % 5 ; chama macro para salvar em RAM 8 movRegtoRAM %D , $8","title":"H - Assembler - Dica Macro"},{"location":"assembler-Dicas-Macro/#h-assembler-dica-macro","text":"Suponha o seguinte arquivo .nasm : % macro name nPar ... .. % endmacro name : Nome do macro nPar : Quantidade de par\u00e2metros (0, 1, 2), acess\u00edvel via : par0, par1 O macro serve para facilitar o reaproveitamento de c\u00f3digos, diferente de uma fun\u00e7\u00e3o que altera o fluxo de execu\u00e7\u00e3o do c\u00f3digo para o endere\u00e7o que a fun\u00e7\u00e3o est\u00e1 salva, o macro funciona copiando o macro para a onde ele foi chamado, como no exemplo a seguir: C\u00f3digo sem macro : ; carrega 5 em D leaw $5 , %A movw %A , %D ; salva valor em RAM8 leaw $8 , %A movw %D , ( %A ) C\u00f3digo com 2 macros definidos : movCntToReg : Move uma constante (par0) para uma registrador (par1) movRegtoRAM : Move um registrador (par0) para o endere\u00e7o de mem\u00f3ria (par1). % macro movCntToReg 2 leaw par0 , %A movw %A , par1 % endmacro % macro movRegtoRAM 2 leaw par0 , %A movw par1 , ( %A ) % endmacro ; carrega 5 em D movCntToReg $D , % 5 ; chama macro para salvar em RAM 8 movRegtoRAM %D , $8","title":"H - Assembler - Dica Macro"},{"location":"assembler-Dicas-SymbolTable/","text":"Tabela de S\u00edmbolos \u00b6 O Z01 possui alguns s\u00edmbolos definidos para facilitar o desenvolvimento de um programa em assembly, por exemplo, n\u00e3o \u00e9 preciso saber de cor que o LCD come\u00e7a no endere\u00e7o 16384, basta usarmos o s\u00edmbolo SCREEN no c\u00f3digo que o mesmo ser\u00e1 substitu\u00eddo pelo valor 16384. Al\u00e9m de facilitar o desenvolvimento, possibilita uma maior portabilidade j\u00e1 que o compilador que \u00e9 encarregado de substituir o valor, se o endere\u00e7o uma maior portabilidade do c\u00f3digo. S\u00edmbolos padr\u00f5es \u00b6 Esse s\u00e3o os s\u00edmbolos que s\u00e3o definidos estaticamente, sempre devem existir. Eles indicam um endere\u00e7o da mem\u00f3ria RAM. Exemplo : leaw $LED , %A movd %D , ( %A ) Simb Endere\u00e7o R0-R15 0-15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185 Labels \u00b6 S\u00e3o os s\u00edmbolos que indicam um endere\u00e7o da mem\u00f3ria ROM, s\u00e3o utilizados pelas opera\u00e7\u00f5es de salto para indicar o seu destino : LOOP: leaw $LOOP , %A jmp Endere\u00e7os de mem\u00f3ria \u00b6 S\u00e3o endere\u00e7os de mem\u00f3ria criados automaticamente pelo assembler, ser\u00e1 utilizado pela VM e futuramente pelo compilador para alocar vari\u00e1veis no START_RAM_ADDRESS computador. Funciona da seguinte maneira : leaw $var , %A movw %D , ( %A ) O Assembler deve alocar um endere\u00e7o automaticamente ainda n\u00e3o utilizado para var0 , o valor a ser alocado \u00e9 a partir do endere\u00e7o 16 da RAM. Simb valor var0 16 O nome da vari\u00e1vel pode ser qualquer uma, desde que n\u00e3o repita um nome de label. Exemplo \u00b6 Vamos supor o c\u00f3digo (que n\u00e3o faz nada coerente) a seguir: 0: leaw $x, %A 1: movw $1, (%A) 2: LOOP: 3: leaw $UPDATE, %A 4: je %D 5: nop 6: leaw $temp, %A 7: movw (%A), %A 8: addw %A, %S, %S 9: decw %D 10: leaw $LOOP, %A 11: jmp 12: nop 13: UPDATE: 14: leaw $3, %A 15: movw %S, (%A) 16: END: 17: leaw $END, %A 18: jmp 19: nop A tabela de s\u00edmbolos gerada deveria ser: S\u00edmbolos Valor R0 0 R1 1 ... ... R15 15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185 ------------ -------- x 16 y 17 LOOP 2 UPDATE 12 END 14","title":"Tabela de S\u00edmbolos"},{"location":"assembler-Dicas-SymbolTable/#tabela-de-simbolos","text":"O Z01 possui alguns s\u00edmbolos definidos para facilitar o desenvolvimento de um programa em assembly, por exemplo, n\u00e3o \u00e9 preciso saber de cor que o LCD come\u00e7a no endere\u00e7o 16384, basta usarmos o s\u00edmbolo SCREEN no c\u00f3digo que o mesmo ser\u00e1 substitu\u00eddo pelo valor 16384. Al\u00e9m de facilitar o desenvolvimento, possibilita uma maior portabilidade j\u00e1 que o compilador que \u00e9 encarregado de substituir o valor, se o endere\u00e7o uma maior portabilidade do c\u00f3digo.","title":"Tabela de S\u00edmbolos"},{"location":"assembler-Dicas-SymbolTable/#simbolos-padroes","text":"Esse s\u00e3o os s\u00edmbolos que s\u00e3o definidos estaticamente, sempre devem existir. Eles indicam um endere\u00e7o da mem\u00f3ria RAM. Exemplo : leaw $LED , %A movd %D , ( %A ) Simb Endere\u00e7o R0-R15 0-15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185","title":"S\u00edmbolos padr\u00f5es"},{"location":"assembler-Dicas-SymbolTable/#labels","text":"S\u00e3o os s\u00edmbolos que indicam um endere\u00e7o da mem\u00f3ria ROM, s\u00e3o utilizados pelas opera\u00e7\u00f5es de salto para indicar o seu destino : LOOP: leaw $LOOP , %A jmp","title":"Labels"},{"location":"assembler-Dicas-SymbolTable/#enderecos-de-memoria","text":"S\u00e3o endere\u00e7os de mem\u00f3ria criados automaticamente pelo assembler, ser\u00e1 utilizado pela VM e futuramente pelo compilador para alocar vari\u00e1veis no START_RAM_ADDRESS computador. Funciona da seguinte maneira : leaw $var , %A movw %D , ( %A ) O Assembler deve alocar um endere\u00e7o automaticamente ainda n\u00e3o utilizado para var0 , o valor a ser alocado \u00e9 a partir do endere\u00e7o 16 da RAM. Simb valor var0 16 O nome da vari\u00e1vel pode ser qualquer uma, desde que n\u00e3o repita um nome de label.","title":"Endere\u00e7os de mem\u00f3ria"},{"location":"assembler-Dicas-SymbolTable/#exemplo","text":"Vamos supor o c\u00f3digo (que n\u00e3o faz nada coerente) a seguir: 0: leaw $x, %A 1: movw $1, (%A) 2: LOOP: 3: leaw $UPDATE, %A 4: je %D 5: nop 6: leaw $temp, %A 7: movw (%A), %A 8: addw %A, %S, %S 9: decw %D 10: leaw $LOOP, %A 11: jmp 12: nop 13: UPDATE: 14: leaw $3, %A 15: movw %S, (%A) 16: END: 17: leaw $END, %A 18: jmp 19: nop A tabela de s\u00edmbolos gerada deveria ser: S\u00edmbolos Valor R0 0 R1 1 ... ... R15 15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185 ------------ -------- x 16 y 17 LOOP 2 UPDATE 12 END 14","title":"Exemplo"},{"location":"assembler-Lab-1-parte-1/","text":"parte 1 \u00b6 Agora iremos desenvolver um programa em java que ser\u00e1 capaz de ler nossos programas .nasm e converter eles para .hack (bin\u00e1rio). Nosso arquivo .hack \u00e9 um arquivo de texto que possui apenas 1 s e 0 s. Cada linha desse arquivo .hack \u00e9 uma instru\u00e7\u00e3o a ser armazenada na mem\u00f3ria ROM e executado pela CPU. Exemplo de um arquivo .hack : 000000000000000101 100101100000010000 000000000000000001 100000000000100000 000000000000001011 Voc\u00ea pode abrir seus arquivos .hack, basta ir em E-Assembly/bin/hack/ que vai encontrar seus bin\u00e1rios (execut\u00e1veis). O arquivo .hack \u00e9 um formato que n\u00e3o conseguimos fazer o download para a FPGA, ent\u00e3o \u00e9 necess\u00e1rio convertemos esse formato em um que o Quartus entenda. Esse formato do Quartus \u00e9 chamado de .mif e \u00e9 gerado automaticamente pelos scripts de teste, esse arquivo .mif \u00e9 similar ao .hack salvo um cabe\u00e7alho e a indica\u00e7\u00e3o do endere\u00e7o na qual a linha deve ser salva: WIDTH=18; DEPTH=5; ADDRESS_RADIX=UNS; DATA_RADIX=BIN; CONTENT BEGIN 0 : 000000000000000101; 1 : 100101100000010000; 2 : 000000000000000001; 3 : 100000000000100000; 4 : 000000000000001011; END; Info O Assembler de voc\u00eas deve gerar um arquivo .hack . A convers\u00e3o para o .mif \u00e9 feita pelos scripts em python j\u00e1 fornecidos ( ./testeAssembly.py ) assembler script python .nasm ---------> .hack --------> .mif v |---------> FPGA |---------> SIMULADOR Assembler \u00b6 O assembler ser\u00e1 um programa escrito em java e que foi estruturado em quatro classes : Assemble Arquivo : Assemble.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo de m\u00e1quina, ela que efetivamente faz a varredura do arquivo .nasm de entrada e escreve o arquivo .hack de sa\u00edda, gerando o c\u00f3digo de m\u00e1quina. Depend\u00eancias : Code.java , Parser.java , SymbolTable.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz mnem\u00f4nicos da linguagem assembly para c\u00f3digos bin\u00e1rios da arquitetura Z0. Depend\u00eancias : none Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem assembly, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none SymbolTable Arquivo : SymbolTable.java Descri\u00e7\u00e3o : Mant\u00e9m uma tabela com a correspond\u00eancia entre os r\u00f3tulos simb\u00f3licos e endere\u00e7os num\u00e9ricos de mem\u00f3ria. Depend\u00eancias : none Note que o 'orquestrador' da montagem (esse \u00e9 o termo em portugu\u00eas utilizado) \u00e9 a classe 'Assemble', nela que estar\u00e1 toda a l\u00f3gica de montagem acessoada pelas demais classes. Pr\u00f3ximos passos \u00b6 Agora vamos configurar a ide para podermos trabalhar no c\u00f3digo java, siga para a pr\u00f3xima parte.","title":"parte 1"},{"location":"assembler-Lab-1-parte-1/#parte-1","text":"Agora iremos desenvolver um programa em java que ser\u00e1 capaz de ler nossos programas .nasm e converter eles para .hack (bin\u00e1rio). Nosso arquivo .hack \u00e9 um arquivo de texto que possui apenas 1 s e 0 s. Cada linha desse arquivo .hack \u00e9 uma instru\u00e7\u00e3o a ser armazenada na mem\u00f3ria ROM e executado pela CPU. Exemplo de um arquivo .hack : 000000000000000101 100101100000010000 000000000000000001 100000000000100000 000000000000001011 Voc\u00ea pode abrir seus arquivos .hack, basta ir em E-Assembly/bin/hack/ que vai encontrar seus bin\u00e1rios (execut\u00e1veis). O arquivo .hack \u00e9 um formato que n\u00e3o conseguimos fazer o download para a FPGA, ent\u00e3o \u00e9 necess\u00e1rio convertemos esse formato em um que o Quartus entenda. Esse formato do Quartus \u00e9 chamado de .mif e \u00e9 gerado automaticamente pelos scripts de teste, esse arquivo .mif \u00e9 similar ao .hack salvo um cabe\u00e7alho e a indica\u00e7\u00e3o do endere\u00e7o na qual a linha deve ser salva: WIDTH=18; DEPTH=5; ADDRESS_RADIX=UNS; DATA_RADIX=BIN; CONTENT BEGIN 0 : 000000000000000101; 1 : 100101100000010000; 2 : 000000000000000001; 3 : 100000000000100000; 4 : 000000000000001011; END; Info O Assembler de voc\u00eas deve gerar um arquivo .hack . A convers\u00e3o para o .mif \u00e9 feita pelos scripts em python j\u00e1 fornecidos ( ./testeAssembly.py ) assembler script python .nasm ---------> .hack --------> .mif v |---------> FPGA |---------> SIMULADOR","title":"parte 1"},{"location":"assembler-Lab-1-parte-1/#assembler","text":"O assembler ser\u00e1 um programa escrito em java e que foi estruturado em quatro classes : Assemble Arquivo : Assemble.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo de m\u00e1quina, ela que efetivamente faz a varredura do arquivo .nasm de entrada e escreve o arquivo .hack de sa\u00edda, gerando o c\u00f3digo de m\u00e1quina. Depend\u00eancias : Code.java , Parser.java , SymbolTable.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz mnem\u00f4nicos da linguagem assembly para c\u00f3digos bin\u00e1rios da arquitetura Z0. Depend\u00eancias : none Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem assembly, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none SymbolTable Arquivo : SymbolTable.java Descri\u00e7\u00e3o : Mant\u00e9m uma tabela com a correspond\u00eancia entre os r\u00f3tulos simb\u00f3licos e endere\u00e7os num\u00e9ricos de mem\u00f3ria. Depend\u00eancias : none Note que o 'orquestrador' da montagem (esse \u00e9 o termo em portugu\u00eas utilizado) \u00e9 a classe 'Assemble', nela que estar\u00e1 toda a l\u00f3gica de montagem acessoada pelas demais classes.","title":"Assembler"},{"location":"assembler-Lab-1-parte-1/#proximos-passos","text":"Agora vamos configurar a ide para podermos trabalhar no c\u00f3digo java, siga para a pr\u00f3xima parte.","title":"Pr\u00f3ximos passos"},{"location":"assembler-Lab-1-parte-2/","text":"parte 2 \u00b6 Warning Todos devem realizar de forma individual! Iremos realizar o desenvolvimento do Assembler na IDE do Intellij, para isso precisamos importar um projeto do tipo maven. Import Project: \u00b6 Importe o arquivo .mvn que est\u00e1 dentro da pasta G-Assebler/Assembler : final \u00b6 Voc\u00ea deve obter um projeto importado no intellij: Verificando sdk \u00b6 Verifique se o intellij associou um SDK ao projeto: Pr\u00f3ximos passos \u00b6 Agora vamos come\u00e7ar a trabalhar no c\u00f3digo java. Siga para a pr\u00f3xima parte.","title":"parte 2"},{"location":"assembler-Lab-1-parte-2/#parte-2","text":"Warning Todos devem realizar de forma individual! Iremos realizar o desenvolvimento do Assembler na IDE do Intellij, para isso precisamos importar um projeto do tipo maven.","title":"parte 2"},{"location":"assembler-Lab-1-parte-2/#import-project","text":"Importe o arquivo .mvn que est\u00e1 dentro da pasta G-Assebler/Assembler :","title":"Import Project:"},{"location":"assembler-Lab-1-parte-2/#final","text":"Voc\u00ea deve obter um projeto importado no intellij:","title":"final"},{"location":"assembler-Lab-1-parte-2/#verificando-sdk","text":"Verifique se o intellij associou um SDK ao projeto:","title":"Verificando sdk"},{"location":"assembler-Lab-1-parte-2/#proximos-passos","text":"Agora vamos come\u00e7ar a trabalhar no c\u00f3digo java. Siga para a pr\u00f3xima parte.","title":"Pr\u00f3ximos passos"},{"location":"assembler-Lab-1-parte-3/","text":"parte 3 \u00b6 Deve ser realizado individual (por\u00e9m discutindo no grupo) Iremos agora implementar um dos m\u00e9todos da classe Code , a parte respons\u00e1vel por gerar os tr\u00eas bits referentes ao jump : No Intellij abra o c\u00f3digo code.java e procure pelo m\u00e9todo jump : /** * Retorna o c\u00f3digo bin\u00e1rio do mnem\u00f4nico para realizar uma opera\u00e7\u00e3o de jump (salto). * @param mnemnonic vetor de mnem\u00f4nicos \"instru\u00e7\u00e3o\" a ser analisada. * @return Opcode (String de 3 bits) com c\u00f3digo em linguagem de m\u00e1quina para a instru\u00e7\u00e3o. */ public static String jump ( String [] mnemnonic ) { return \"\" ; } Note que o input dessa fun\u00e7\u00e3o \u00e9 um array de strings, chamado mnemnonic e seu retorno \u00e9 uma string. No mnemnonic ser\u00e1 passado a instru\u00e7\u00e3o a ser executada da seguinte forma: {\"jmp\"} {\"jge\", \"S\"} {\"jg\", \"%D\"} ... E deve retornar o bin\u00e1rio correspondente aos bits j2, j1 e j0 do comando de jump : 111 , 011 , 010 , .... Note que aesa classe n\u00e3o precisa se preocupar com a origem do jump (%S, %D, ...) apenas com o seu tipo jmp , jge , ... Implementando \u00b6 Vamos implementar algo bem simples que est\u00e1 incompleto, mas vai servir para entendermos o fluxo. Modifique o c\u00f3digo com o exemplo a seguir : public static String jump ( String [] mnemnonic ) { switch ( mnemnonic [ 0 ] ){ case \"jmp\" : return \"111\" ; default : return \"000\" ; } } Com a classe implementada, podemos executar o teste unit\u00e1rio dela. No Intellij: Com o bot\u00e3o direito no test/java/assembler/CodeTest Note que o teste falhou, j\u00e1 que a nossa implementa\u00e7\u00e3o est\u00e1 incompleta. terminando \u00b6 Retorne a classe jump e termine sua implementa\u00e7\u00e3o. Execute novamente o teste at\u00e9 passar. Antes de continuar Termine de implementar essa classe Continuando \u00b6 Siga para a pr\u00f3xima parte.","title":"parte 3"},{"location":"assembler-Lab-1-parte-3/#parte-3","text":"Deve ser realizado individual (por\u00e9m discutindo no grupo) Iremos agora implementar um dos m\u00e9todos da classe Code , a parte respons\u00e1vel por gerar os tr\u00eas bits referentes ao jump : No Intellij abra o c\u00f3digo code.java e procure pelo m\u00e9todo jump : /** * Retorna o c\u00f3digo bin\u00e1rio do mnem\u00f4nico para realizar uma opera\u00e7\u00e3o de jump (salto). * @param mnemnonic vetor de mnem\u00f4nicos \"instru\u00e7\u00e3o\" a ser analisada. * @return Opcode (String de 3 bits) com c\u00f3digo em linguagem de m\u00e1quina para a instru\u00e7\u00e3o. */ public static String jump ( String [] mnemnonic ) { return \"\" ; } Note que o input dessa fun\u00e7\u00e3o \u00e9 um array de strings, chamado mnemnonic e seu retorno \u00e9 uma string. No mnemnonic ser\u00e1 passado a instru\u00e7\u00e3o a ser executada da seguinte forma: {\"jmp\"} {\"jge\", \"S\"} {\"jg\", \"%D\"} ... E deve retornar o bin\u00e1rio correspondente aos bits j2, j1 e j0 do comando de jump : 111 , 011 , 010 , .... Note que aesa classe n\u00e3o precisa se preocupar com a origem do jump (%S, %D, ...) apenas com o seu tipo jmp , jge , ...","title":"parte 3"},{"location":"assembler-Lab-1-parte-3/#implementando","text":"Vamos implementar algo bem simples que est\u00e1 incompleto, mas vai servir para entendermos o fluxo. Modifique o c\u00f3digo com o exemplo a seguir : public static String jump ( String [] mnemnonic ) { switch ( mnemnonic [ 0 ] ){ case \"jmp\" : return \"111\" ; default : return \"000\" ; } } Com a classe implementada, podemos executar o teste unit\u00e1rio dela. No Intellij: Com o bot\u00e3o direito no test/java/assembler/CodeTest Note que o teste falhou, j\u00e1 que a nossa implementa\u00e7\u00e3o est\u00e1 incompleta.","title":"Implementando"},{"location":"assembler-Lab-1-parte-3/#terminando","text":"Retorne a classe jump e termine sua implementa\u00e7\u00e3o. Execute novamente o teste at\u00e9 passar. Antes de continuar Termine de implementar essa classe","title":"terminando"},{"location":"assembler-Lab-1-parte-3/#continuando","text":"Siga para a pr\u00f3xima parte.","title":"Continuando"},{"location":"assembler-Lab-1-parte-4/","text":"parte 4 \u00b6 Desenvolvimento baseado em testes \u00e9 uma t\u00e9cnica que temos utilizado at\u00e9 agora para os nosso projetos, nesse m\u00e9todo fragmentando o desenvolvimento em pequenos m\u00f3dulos que s\u00e3o testados de forma individual, por testes unit\u00e1rios. O desenvolvimento \u00e9 focado em fazer com que os m\u00f3dulos passem nos testes. Como os testes n\u00e3o s\u00e3o perfeitos e n\u00e3o conseguem cobrir toda a funcionalidade do m\u00f3dulo, \u00e9 necess\u00e1rio realizarmos o teste de integra\u00e7\u00e3o, onde juntamos todas as pe\u00e7as e testamos o sistema como um todo. Utilizaremos o mesmo recurso agora em java, onde cada m\u00f3dulo (m\u00e9todo) possui um teste e quando todos os m\u00f3dulos estivem implementados e funcionando realizamos um teste de integra\u00e7\u00e3o que valida tudo. Os testes unit\u00e1rios foram feitos com o JUnit e est\u00e3o na pasta do projeto: G-Assembler/Assembler/test/java/assembler . Os testes cobrem todas os m\u00e9todos do projeto. Exemplo parser \u00b6 Os testes s\u00e3o uma guia do que cada m\u00e9todo deve fazer, e eles servir\u00e3o como complemento da documenta\u00e7\u00e3o do m\u00f3dulo. Iremos seguir o fluxo: Ler descri\u00e7\u00e3o do m\u00e9todo Abrir teste unit\u00e1rio e entender o que \u00e9 passado e o que \u00e9 esperado Desenvolver m\u00e9todo Testar Falhou? Volte para 1. Vamos pegar como exemplo o m\u00e9todo commandType do parser : /** * Retorna o tipo da instru\u00e7\u00e3o passada no argumento: * A_COMMAND para leaw, por exemplo leaw $1,%A * L_COMMAND para labels, por exemplo Xyz: , onde Xyz \u00e9 um s\u00edmbolo. * C_COMMAND para todos os outros comandos * @param command instru\u00e7\u00e3o a ser analisada. * @return o tipo da instru\u00e7\u00e3o. */ public CommandType commandType ( String command ) { return null ; } E seu teste unit\u00e1rio: /** * Teste para a instru\u00e7\u00e3o commandType */ @Test public void testParser_commandType () { try { assertTrue ( \"leaw $0,%A\" , parser . commandType ( \"leaw $0,%A\" ) == Parser . CommandType . A_COMMAND ); assertTrue ( \"abc:\" , parser . commandType ( \"abc:\" ) == Parser . CommandType . L_COMMAND ); assertTrue ( \"movw %A,%D\" , parser . commandType ( \"movw %A,%D\" ) == Parser . CommandType . C_COMMAND ); .... .... } } Vamos analisar o primeiro teste: assertTrue ( \"leaw $0,%A\" , parser . commandType ( \"leaw $0,%A\" ) == Parser . CommandType . A_COMMAND ); ` Nesse teste \u00e9 passado a string \"leaw $0,%A\" para o m\u00e9todo parser.commandType e esperasse na sa\u00edda A_COMMAND . Com essa informa\u00e7\u00e3o complementar conseguimos iniciar o desenvolvimento dessa classe. Antes de continuar Implemente a classe parser.commandType Execute o teste unit\u00e1rio do parser at\u00e9 que o comandType passe nos testes. Continuando \u00b6 Siga para a pr\u00f3xima parte.","title":"parte 4"},{"location":"assembler-Lab-1-parte-4/#parte-4","text":"Desenvolvimento baseado em testes \u00e9 uma t\u00e9cnica que temos utilizado at\u00e9 agora para os nosso projetos, nesse m\u00e9todo fragmentando o desenvolvimento em pequenos m\u00f3dulos que s\u00e3o testados de forma individual, por testes unit\u00e1rios. O desenvolvimento \u00e9 focado em fazer com que os m\u00f3dulos passem nos testes. Como os testes n\u00e3o s\u00e3o perfeitos e n\u00e3o conseguem cobrir toda a funcionalidade do m\u00f3dulo, \u00e9 necess\u00e1rio realizarmos o teste de integra\u00e7\u00e3o, onde juntamos todas as pe\u00e7as e testamos o sistema como um todo. Utilizaremos o mesmo recurso agora em java, onde cada m\u00f3dulo (m\u00e9todo) possui um teste e quando todos os m\u00f3dulos estivem implementados e funcionando realizamos um teste de integra\u00e7\u00e3o que valida tudo. Os testes unit\u00e1rios foram feitos com o JUnit e est\u00e3o na pasta do projeto: G-Assembler/Assembler/test/java/assembler . Os testes cobrem todas os m\u00e9todos do projeto.","title":"parte 4"},{"location":"assembler-Lab-1-parte-4/#exemplo-parser","text":"Os testes s\u00e3o uma guia do que cada m\u00e9todo deve fazer, e eles servir\u00e3o como complemento da documenta\u00e7\u00e3o do m\u00f3dulo. Iremos seguir o fluxo: Ler descri\u00e7\u00e3o do m\u00e9todo Abrir teste unit\u00e1rio e entender o que \u00e9 passado e o que \u00e9 esperado Desenvolver m\u00e9todo Testar Falhou? Volte para 1. Vamos pegar como exemplo o m\u00e9todo commandType do parser : /** * Retorna o tipo da instru\u00e7\u00e3o passada no argumento: * A_COMMAND para leaw, por exemplo leaw $1,%A * L_COMMAND para labels, por exemplo Xyz: , onde Xyz \u00e9 um s\u00edmbolo. * C_COMMAND para todos os outros comandos * @param command instru\u00e7\u00e3o a ser analisada. * @return o tipo da instru\u00e7\u00e3o. */ public CommandType commandType ( String command ) { return null ; } E seu teste unit\u00e1rio: /** * Teste para a instru\u00e7\u00e3o commandType */ @Test public void testParser_commandType () { try { assertTrue ( \"leaw $0,%A\" , parser . commandType ( \"leaw $0,%A\" ) == Parser . CommandType . A_COMMAND ); assertTrue ( \"abc:\" , parser . commandType ( \"abc:\" ) == Parser . CommandType . L_COMMAND ); assertTrue ( \"movw %A,%D\" , parser . commandType ( \"movw %A,%D\" ) == Parser . CommandType . C_COMMAND ); .... .... } } Vamos analisar o primeiro teste: assertTrue ( \"leaw $0,%A\" , parser . commandType ( \"leaw $0,%A\" ) == Parser . CommandType . A_COMMAND ); ` Nesse teste \u00e9 passado a string \"leaw $0,%A\" para o m\u00e9todo parser.commandType e esperasse na sa\u00edda A_COMMAND . Com essa informa\u00e7\u00e3o complementar conseguimos iniciar o desenvolvimento dessa classe. Antes de continuar Implemente a classe parser.commandType Execute o teste unit\u00e1rio do parser at\u00e9 que o comandType passe nos testes.","title":"Exemplo parser"},{"location":"assembler-Lab-1-parte-4/#continuando","text":"Siga para a pr\u00f3xima parte.","title":"Continuando"},{"location":"assembler-Lab-1-parte-5/","text":"parte 5 \u00b6 Implemente o m\u00e9todo initialize da classe SymbolTable utilizando os conceitos visto nos outros labs. O initialize utiliza outros m\u00e9todos dessa classe, edite eles: public void addEntry ( String symbol , int address ) { symbolTable . put ( symbol , address ); } public Boolean contains ( String symbol ) { return symbolTable . containsKey ( symbol ); } public Integer getAddress ( String symbol ) { return symbolTable . get ( symbol ); } Agora com os demais m\u00e9todos implementando fa\u00e7a o initialize . Tip Use os testes para ajudar entender o que o m\u00e9todo faz. Tabela de s\u00edmbolos? De uma lida na teoria/Tabela de S\u00edmbolos","title":"parte 5"},{"location":"assembler-Lab-1-parte-5/#parte-5","text":"Implemente o m\u00e9todo initialize da classe SymbolTable utilizando os conceitos visto nos outros labs. O initialize utiliza outros m\u00e9todos dessa classe, edite eles: public void addEntry ( String symbol , int address ) { symbolTable . put ( symbol , address ); } public Boolean contains ( String symbol ) { return symbolTable . containsKey ( symbol ); } public Integer getAddress ( String symbol ) { return symbolTable . get ( symbol ); } Agora com os demais m\u00e9todos implementando fa\u00e7a o initialize . Tip Use os testes para ajudar entender o que o m\u00e9todo faz. Tabela de s\u00edmbolos? De uma lida na teoria/Tabela de S\u00edmbolos","title":"parte 5"},{"location":"assembler-Lab-1/","text":"Introdu\u00e7\u00e3o \u00b6 Esse laborat\u00f3rio introduz uma s\u00e9rie de conceitos e ferramentas e deve ser realizado individualmente ou em dupla (como indicado no come\u00e7o de cada parte). Ao final do laborat\u00f3rio voc\u00ea dever\u00e1: Entender o que \u00e9 um arquivo .hack e .mif Ter um projeto importado no Intellij Ter o m\u00e9todo code.jump implementando Saber como executar os testes unit\u00e1rios Ter o m\u00e9todo parser.commandType implementando Saber como extrair informa\u00e7\u00f5es dos testes unit\u00e1rios Ter o fillSymbolTable.initialize implementando Antes de come\u00e7ar \u00b6 Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. Warning N\u00e3o seguir sem realizar a etapa anterior.","title":"Introdu\u00e7\u00e3o"},{"location":"assembler-Lab-1/#introducao","text":"Esse laborat\u00f3rio introduz uma s\u00e9rie de conceitos e ferramentas e deve ser realizado individualmente ou em dupla (como indicado no come\u00e7o de cada parte). Ao final do laborat\u00f3rio voc\u00ea dever\u00e1: Entender o que \u00e9 um arquivo .hack e .mif Ter um projeto importado no Intellij Ter o m\u00e9todo code.jump implementando Saber como executar os testes unit\u00e1rios Ter o m\u00e9todo parser.commandType implementando Saber como extrair informa\u00e7\u00f5es dos testes unit\u00e1rios Ter o fillSymbolTable.initialize implementando","title":"Introdu\u00e7\u00e3o"},{"location":"assembler-Lab-1/#antes-de-comecar","text":"Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. Warning N\u00e3o seguir sem realizar a etapa anterior.","title":"Antes de come\u00e7ar"},{"location":"assembler-Prerequisitos/","text":"(contanto com o restante da infra j\u00e1 esteja funcionando) Java JDK 8 Maven https://maven.apache.org/install.html IDE Intellij Se voc\u00ea est\u00e1 usando o SSD fornecido, precisa apenas executar os comandos a seguir: $ sudo apt install maven $ python3 -m pip install joblib --user $ sudo snap install intellij-idea-community --classic --edge Caso contr\u00e1rio precisa instalar o JAVA 8 oficial (o open n\u00e3o funciona).","title":"assembler Prerequisitos"},{"location":"assembler-Projeto/","text":"G - Assembler \u00b6 Entrega 25/11 - Sexta Nesse projeto iremos criar o programa assembler que \u00e9 respons\u00e1vel por traduzir os c\u00f3digos escrito em Assembly para a linguagem de m\u00e1quina. Instru\u00e7\u00f5es \u00b6 As instru\u00e7\u00f5es t\u00e9cnicas de como come\u00e7ar o projeto est\u00e3o no laborat\u00f3rio 16. M\u00f3dulos a serem implementados \u00b6 O projeto no total possui 5 m\u00f3dulos, sendo que o m\u00f3dulo AssemblerZ01.java j\u00e1 est\u00e1 pronto. Tip Os m\u00f3dulos est\u00e3o listados de maneira Top - Down AssemblerZ01 Arquivo : AssemblerZ01.java Descri\u00e7\u00e3o : Main do projeto. Recebe como par\u00e2metro o nome do arquivo .nasm e o nome do arquivo bin\u00e1rio de m\u00e1quina .hack . a ser escrito, passa essas informa\u00e7\u00f5es para a classe Assemble. Essa classe que inicializa a tabela de s\u00edmbolo ( fillSymbolTable ) e chama o m\u00e9todo generateMachineCode para efetivamente gerar o arquivo de sa\u00edda. Depend\u00eancias : Assemble.java Tip J\u00e1 est\u00e1 pronto, n\u00e3o precisa mexer. Assemble Arquivo : Assemble.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo de m\u00e1quina, ela que efetivamente faz a varredura do arquivo .nasm de entrada e escreve o arquivo .hack de sa\u00edda, gerando o c\u00f3digo de m\u00e1quina. Depend\u00eancias : Code.java , Parser.java , SymbolTable.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz mnem\u00f4nicos da linguagem assembly para c\u00f3digos bin\u00e1rios da arquitetura Z0. Depend\u00eancias : none Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem assembly, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none SymbolTable Arquivo : SymbolTable.java Descri\u00e7\u00e3o : Mant\u00e9m uma tabela com a correspond\u00eancia entre os r\u00f3tulos simb\u00f3licos e endere\u00e7os num\u00e9ricos de mem\u00f3ria. Depend\u00eancias : none Rubrica \u00b6 Conceito A - Insere automaticamente um NOP ap\u00f3s instru\u00e7\u00e3o de JUMP que n\u00e3o \u00e9 seguida de nop. - Imprime mensagem de alerta que isso foi feito. B - Verifica se instru\u00e7\u00e3o de jump \u00e9 seguida de NOP, caso contr\u00e1rio d\u00e1 erro C - Criado assembler a partir de estrutura de c\u00f3digo disponibilizada - Todos os testes unit\u00e1rios passam no teste - Os testes de integra\u00e7\u00e3o passam nos testes - Actions configurado corretamente D - Teste unit\u00e1rio ou Teste integra\u00e7\u00e3o n\u00e3o passa I - Menos da metade dos m\u00f3dulos funcionando Formul\u00e1rios \u00b6 Scrum Master Desenvolvedores","title":"G - Assembler"},{"location":"assembler-Projeto/#g-assembler","text":"Entrega 25/11 - Sexta Nesse projeto iremos criar o programa assembler que \u00e9 respons\u00e1vel por traduzir os c\u00f3digos escrito em Assembly para a linguagem de m\u00e1quina.","title":"G - Assembler"},{"location":"assembler-Projeto/#instrucoes","text":"As instru\u00e7\u00f5es t\u00e9cnicas de como come\u00e7ar o projeto est\u00e3o no laborat\u00f3rio 16.","title":"Instru\u00e7\u00f5es"},{"location":"assembler-Projeto/#modulos-a-serem-implementados","text":"O projeto no total possui 5 m\u00f3dulos, sendo que o m\u00f3dulo AssemblerZ01.java j\u00e1 est\u00e1 pronto. Tip Os m\u00f3dulos est\u00e3o listados de maneira Top - Down AssemblerZ01 Arquivo : AssemblerZ01.java Descri\u00e7\u00e3o : Main do projeto. Recebe como par\u00e2metro o nome do arquivo .nasm e o nome do arquivo bin\u00e1rio de m\u00e1quina .hack . a ser escrito, passa essas informa\u00e7\u00f5es para a classe Assemble. Essa classe que inicializa a tabela de s\u00edmbolo ( fillSymbolTable ) e chama o m\u00e9todo generateMachineCode para efetivamente gerar o arquivo de sa\u00edda. Depend\u00eancias : Assemble.java Tip J\u00e1 est\u00e1 pronto, n\u00e3o precisa mexer. Assemble Arquivo : Assemble.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo de m\u00e1quina, ela que efetivamente faz a varredura do arquivo .nasm de entrada e escreve o arquivo .hack de sa\u00edda, gerando o c\u00f3digo de m\u00e1quina. Depend\u00eancias : Code.java , Parser.java , SymbolTable.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz mnem\u00f4nicos da linguagem assembly para c\u00f3digos bin\u00e1rios da arquitetura Z0. Depend\u00eancias : none Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem assembly, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none SymbolTable Arquivo : SymbolTable.java Descri\u00e7\u00e3o : Mant\u00e9m uma tabela com a correspond\u00eancia entre os r\u00f3tulos simb\u00f3licos e endere\u00e7os num\u00e9ricos de mem\u00f3ria. Depend\u00eancias : none","title":"M\u00f3dulos a serem implementados"},{"location":"assembler-Projeto/#rubrica","text":"Conceito A - Insere automaticamente um NOP ap\u00f3s instru\u00e7\u00e3o de JUMP que n\u00e3o \u00e9 seguida de nop. - Imprime mensagem de alerta que isso foi feito. B - Verifica se instru\u00e7\u00e3o de jump \u00e9 seguida de NOP, caso contr\u00e1rio d\u00e1 erro C - Criado assembler a partir de estrutura de c\u00f3digo disponibilizada - Todos os testes unit\u00e1rios passam no teste - Os testes de integra\u00e7\u00e3o passam nos testes - Actions configurado corretamente D - Teste unit\u00e1rio ou Teste integra\u00e7\u00e3o n\u00e3o passa I - Menos da metade dos m\u00f3dulos funcionando","title":"Rubrica"},{"location":"assembler-Projeto/#formularios","text":"Scrum Master Desenvolvedores","title":"Formul\u00e1rios"},{"location":"assembler-Testando/","text":"A pasta do projeto H, possui a seguinte estrutura: scripts: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; compileNasmMyAssembler : Compila os nasms do projeto F-Assembly com o assembler do grupo e salva o resultado em bin/hack/ testeAssembler : Compila os nasms com o assembler do grupo e executa a simula\u00e7\u00e3o no Z01.1 ( standard-professor ). testeAssemblerMyCPU : Compila os nasms com o assembler do grupo e executa a simula\u00e7\u00e3o no Z01.1 do grupo ( projeto G-CPU ). genJAR : Gera um Jar que ser\u00e1 utilizado pelos testes anteriores a partir das fontes em Assembler/src/main/ -> Salva em Assembler/Z01-Assembler.jar . Esses scripts de testes utilizam o projeto F-Assembly! bin/hack/*.hack : Arquivos .hack convertidos via Z01-Assembler.jar Assembler/src/main/java/assembler : C\u00f3digo fonte em java do assembler, que deve ser implementando por voc\u00eas! Testes \u00b6 \u00c9 disponibilizado dois tipos de testes: Unit\u00e1rio para as classes em java e de Integra\u00e7\u00e3o para o Assembler como um todo. Os testes unit\u00e1rios das classes est\u00e3o localizados em Assembler/src/tests/ e pode ser executado de duas maneiras: Via IDE (Intellij) Via maven na gera\u00e7\u00e3o do jar (`genJAR.py**) J\u00e1 o teste de integra\u00e7\u00e3o que considera como as classes foram utilizadas para a gera\u00e7\u00e3o do Assembler \u00e9 executado via script testeAssembler.py , executando os seguintes passos : Gera o jar ( genJAR.py ) input : Assembler/src/main/java/assembler/*.java* output: Z01-Assembler.jar Compila os nasms input: F-Assembly/src/nasm/*.nasm* output: H-Assembler/bin/hack/*.mif* Executa os testes no hardware (usando o hardware de refer\u00eancia) input: F-Assembly/tests/* input: H-Assembler/bin/hack/*.mif* output: F-Assembly/tests/tst/name/*_end.mif* Compara resultado com esperado input : F-Assembly/tests/tst/name/*_tst.mif* output: Terminal","title":"assembler Testando"},{"location":"assembler-Testando/#testes","text":"\u00c9 disponibilizado dois tipos de testes: Unit\u00e1rio para as classes em java e de Integra\u00e7\u00e3o para o Assembler como um todo. Os testes unit\u00e1rios das classes est\u00e3o localizados em Assembler/src/tests/ e pode ser executado de duas maneiras: Via IDE (Intellij) Via maven na gera\u00e7\u00e3o do jar (`genJAR.py**) J\u00e1 o teste de integra\u00e7\u00e3o que considera como as classes foram utilizadas para a gera\u00e7\u00e3o do Assembler \u00e9 executado via script testeAssembler.py , executando os seguintes passos : Gera o jar ( genJAR.py ) input : Assembler/src/main/java/assembler/*.java* output: Z01-Assembler.jar Compila os nasms input: F-Assembly/src/nasm/*.nasm* output: H-Assembler/bin/hack/*.mif* Executa os testes no hardware (usando o hardware de refer\u00eancia) input: F-Assembly/tests/* input: H-Assembler/bin/hack/*.mif* output: F-Assembly/tests/tst/name/*_end.mif* Compara resultado com esperado input : F-Assembly/tests/tst/name/*_tst.mif* output: Terminal","title":"Testes"},{"location":"assembly-Dicas/","text":"F - Assembly - Dicas \u00b6 A seguir algumas dicas para atingir os conceitos B e A nessa entrega. Rubrica - B \u00b6 Fa\u00e7a um programa em python que gere automaticamente um c\u00f3digo em assembly de um texto. Existem v\u00e1rias alternativas: A entrada do programa \u00e9 um .png e a sa\u00edda \u00e9 um c\u00f3digo em nasm A entrada do programa \u00e9 uma tabela do excel e a sa\u00edda \u00e9 um c\u00f3digo em nasm Rubrica - A \u00b6 N\u00e3o precisa ser um jogo complexo, pode ser algo como um \"Genius\" com os LEDs e bot\u00f5es.","title":"F - Assembly - Dicas"},{"location":"assembly-Dicas/#f-assembly-dicas","text":"A seguir algumas dicas para atingir os conceitos B e A nessa entrega.","title":"F - Assembly - Dicas"},{"location":"assembly-Dicas/#rubrica-b","text":"Fa\u00e7a um programa em python que gere automaticamente um c\u00f3digo em assembly de um texto. Existem v\u00e1rias alternativas: A entrada do programa \u00e9 um .png e a sa\u00edda \u00e9 um c\u00f3digo em nasm A entrada do programa \u00e9 uma tabela do excel e a sa\u00edda \u00e9 um c\u00f3digo em nasm","title":"Rubrica - B"},{"location":"assembly-Dicas/#rubrica-a","text":"N\u00e3o precisa ser um jogo complexo, pode ser algo como um \"Genius\" com os LEDs e bot\u00f5es.","title":"Rubrica - A"},{"location":"assembly-Lab-1/","text":"Lab 10: Assembly \u00b6 Ao final desse lab voc\u00ea deve ser capaz de: Usar o simulador gr\u00e1fico Fazer pequenas modifica\u00e7\u00f5es em um c\u00f3digo assembly Executar script de teste do projeto E - Assembly Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. Tip Atualizem o Z01-Tools! submodule antes de come\u00e7ar. Simulador \u00b6 Nosso c\u00f3digo assembly pode ser executado em hardware de verdade (FPGA) por\u00e9m nesse primeiro momento iremos trabalhar em um ambiente simulado que nos dar\u00e1 maior facilidade de programa\u00e7\u00e3o e depura\u00e7\u00e3o. Um pouco de contexto: O livro texto (The Elements Of Computer System) disponibiliza um simulador da CPU original todo escrito em java, esse c\u00f3digo \u00e9 fechado e n\u00e3o permite nenhuma customiza\u00e7\u00e3o. Em 2017 o Prof. Luciano Pereira iniciou a cria\u00e7\u00e3o de um simulador Z0 (vers\u00e3o anterior) tamb\u00e9m em Java, onde ter\u00edamos controle total do software. Percebemos alguns pontos negativos de utilizar um simulador em Java sendo o principal: Qualquer altera\u00e7\u00e3o no Hardware iria demandar uma altera\u00e7\u00e3o no simulador, sendo necess\u00e1rio mantermos dois projetos independentes e sincronizados. Nesta vers\u00e3o do curso iremos utilizar um simulador que utiliza o nosso pr\u00f3prio c\u00f3digo VHDL como descri\u00e7\u00e3o da CPU (e de tudo envolvido), uma altera\u00e7\u00e3o no hardware (VHDL) ir\u00e1 automaticamente alterar o simulador e o comportamento do computador. Para isso, fazemos uso do ModelSim, um software da Mentor Graphics que executa simula\u00e7\u00f5es em VHDL (o mesmo utilizado nos projetos anteriores), desenvolvemos uma s\u00e9rie de APIs e configura\u00e7\u00f5es desse simulador para funcionar para a disciplina. As APIS de interface do simulador foram desenvolvidas pelo Prof. Rafael Corsi (vhdl/ tcl/ python) e a interface gr\u00e1fica pelo Prof. Eduardo Marossi (python/ qt5). De uma olhada na pasta Z01-Tools na sua home, est\u00e1 tudo l\u00e1! O simulador possui a estrutura ilustrada a seguir: O simulador possui como entradas (para cada simula\u00e7\u00e3o): a arquitetura do computador (hardware); o conte\u00fado da mem\u00f3ria RAM o conte\u00fado da mem\u00f3ria ROM e um tempo de execu\u00e7\u00e3o. Ap\u00f3s o t\u00e9rmino da simula\u00e7\u00e3o \u00e9 exportado diversos sinais internos da CPU, o estado final da mem\u00f3ria RAM e ROM. Esses sinais s\u00e3o ent\u00e3o lidos pela interface gr\u00e1fica e exibida de uma forma amig\u00e1vel, ou usados nos testes. Arquivos \u00b6 O simulador est\u00e1 localizado nas pastas Z01-tools/ : Z01-Simulator-GUI : Parte gr\u00e1fica do simulador Z01-Simulator-RTL : Hardware a ser executado no modelsim para executar o programa. Para inicializar o simulador basta executar o script localizado na pasta do projeto E: $ python3 E-Assembly/Z01simulador.py Interface do Simulador \u00b6 O simulador possui a interface a seguir, onde a coluna da esquerda \u00e9 referente a mem\u00f3ria ROM (programa), a coluna da direita referente a mem\u00f3ria RAM (dados). Toda vez que houver uma altera\u00e7\u00e3o em algum dos par\u00e2metros do simulador (RAM/ROM/Instru\u00e7\u00f5es,...) o programa ser\u00e1 novamente executado no simulador para obtermos um resultado atualizado. Isso pode dar a sensa\u00e7\u00e3o de \"lerdeza\" mas lembre da complexidade do sistema: estamos executando um programa em um hardware inteiramente simulado no computador de voc\u00eas. Programando \u00b6 Abra o simulador e insira o seguinte c\u00f3digo nasm (na parte referente a ROM), uma instru\u00e7\u00e3o por linha: leaw $ 1 , % A ; carrega a constant 1 em %A movw ( % A ), % D ; move o valor da RAM[%A] para %D leaw $ 0 , % A ; carrega a constant 0 em %A addw ( % A ), % D , % D ; faz RAM[%A] + %D e salva em %D leaw $ 2 , % A ; carrega a constant 2 em %A movw % D , ( % A ) ; copia o valor de %D para RAM[%A] Esse c\u00f3digo soma o valor que est\u00e1 salvo na mem\u00f3ria RAM endere\u00e7o 0 com o valor da mem\u00f3ria RAM endere\u00e7o 1 e salva no endere\u00e7o RAM[2]: RAM[2] = RAM[0] + RAM[1] mov A opera\u00e7\u00e3o de movw n\u00e3o 'move' o dado de um lugar para outro, ela copia. O valor no destino n\u00e3o \u00e9 apagado, por exemplo: leaw $ 10 , % A movw % A , % D Ao final dessas opera\u00e7\u00f5es os registradores %A e %D possui o valor 10. labels R0, R1, .., R15 , ... s\u00e3o nomes pr\u00e9 definidos de endere\u00e7os de mem\u00f3ria. O R0 indica o endere\u00e7o de mem\u00f3ria 0, R1 o endere\u00e7o de mem\u00f3ria 1 e assim por diante at\u00e9 o R15 . O mesmo c\u00f3digo pode ser escrito como: leaw $ R1 , % A movw ( % A ), % D leaw $ R0 , % A addw ( % A ), % D , % D leaw $ R2 , % A movw % D , ( % A ) Para testarmos esse c\u00f3digo ser\u00e1 necess\u00e1rio colocarmos valores iniciais na mem\u00f3ria RAM para validarmos o nosso c\u00f3digo, para isso altere a mem\u00f3ria RAM como demonstrado a seguir: Endere\u00e7o 0 = 5 Endere\u00e7o 1 = 8 Executando Com a mem\u00f3ria alterada voc\u00ea pode agora executar a simula\u00e7\u00e3o Verifique se o valor da mem\u00f3ria 2 \u00e9 a soma dos endere\u00e7os 0 e 1. Brinque com esses valores... Treinando \u00b6 Vamos praticar um pouco agora programar em assembly, no come\u00e7o parece bem dif\u00edcil, mas com a pr\u00e1tica as coisas v\u00e3o ficando mais f\u00e1ceis. Use o resumo das instru\u00e7\u00f5es: AssemblyZ01 para saber as instru\u00e7\u00f5es dispon\u00edveis. Altere o c\u00f3digo para armazenar o resultado no endere\u00e7o RAM[5] Solu\u00e7\u00e3o leaw $ 1 , % A movw ( % A ), % D leaw $ 0 , % A addw ( % A ), % D , % D leaw $ 5 , % A ; <- alterado essa linha para 5! movw % D , ( % A ) Altere o c\u00f3digo para armazenar o negativo da opera\u00e7\u00e3o entre RAM[0] + RAM[1] no endere\u00e7o RAM[5] (dica: tem uma opera\u00e7\u00e3o de NEG ). solu\u00e7\u00e3o leaw $ 1 , % A movw ( % A ), % D leaw $ 0 , % A addw ( % A ), % D , % D negw % D ; aqui eu fa\u00e7o %D = - %D leaw $ 5 , % A movw % D , ( % A ) Script autom\u00e1tico de testes \u00b6 Al\u00e9m da interface gr\u00e1fica do simulador, possu\u00edmos um script de teste automatizado (similar ao do VHDL), esse script: E-Assembly/testeAssembly.py compila os c\u00f3digos que est\u00e3o na pasta E-Assembly/src/ para a pasta E-Assembly/bin/hack e executa os testes localizados em E-Assembly/tests/ . Somente os arquivos configurados no config_testes_nasm.txt ser\u00e3o testados. config_testes_nasm.txt \u00b6 O arquivo de configura\u00e7\u00e3o dos testes \u00e9 um pouco diferente, possui al\u00e9m do nome do m\u00f3dulo que ser\u00e1 testado um segundo par\u00e2metro que indica quantos testes ser\u00e3o executados para esse m\u00f3dulo e quantos microsegundos ele ficar\u00e1 na simula\u00e7\u00e3o (microsegundos suposto de um sistema real). Exemplo do config_testes_nasm.txt # nome | quantidade de testes | us de execucao #add 1 1000 Implementando o add.nasm \u00b6 Os arquivos a serem implementando est\u00e3o na pasta E-Assembly/src/ l\u00e1 voc\u00ea vai encontrar todos os c\u00f3digos fontes que dever\u00e3o ser feitos nesse projeto. Tarefa Edite o arquivo add.nasm realizando a implementa\u00e7\u00e3o que ele pede no coment\u00e1rio do arquivo (j\u00e1 foi feito nesse lab) vscode Abra o arquivo add.nasm no VsCode. Agora com o m\u00f3dulo implementando podemos testar seu funcionamento. Para isso execute o script testeAssembly.py . Esse script ir\u00e1 compilar o nasm e gerar os arquivos .hack e .mif (salvos no /bin/hack/ ) que ser\u00e3o carregados no simulador junto com uma configura\u00e7\u00e3o inicial da mem\u00f3ria RAM (como no gui do simulador), ao t\u00e9rmino da simula\u00e7\u00e3o um arquivo com o estado final da RAM \u00e9 salvo na pasta /tests/add/add0_end.mif . Executamos um script que compara o estado final da RAM com o um esperado ( add0_tst.mif ), em caso de algum erro, o script ir\u00e1 reportar falha. Se tudo ocorrer bem voc\u00ea dever\u00e1 ter a seguinte sa\u00edda : - Testando .... ------------------------- Starting add0 .... pass add0 ==== Summary =================================== + pass add teste: 0 Implementando outros m\u00f3dulos \u00b6 Vamos implementar outros m\u00f3dulos: sub.nasm e mov.nasm . Para cada m\u00f3dulo descomente o teste no config_tests_nasm.txt e leia o que deve ser feito nos coment\u00e1rios de cada arquivo. Tarefa Implementar o sub.nasm e testar Implementar o mov.nasm e testar","title":"Lab 10: Assembly"},{"location":"assembly-Lab-1/#lab-10-assembly","text":"Ao final desse lab voc\u00ea deve ser capaz de: Usar o simulador gr\u00e1fico Fazer pequenas modifica\u00e7\u00f5es em um c\u00f3digo assembly Executar script de teste do projeto E - Assembly Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. Tip Atualizem o Z01-Tools! submodule antes de come\u00e7ar.","title":"Lab 10: Assembly"},{"location":"assembly-Lab-1/#simulador","text":"Nosso c\u00f3digo assembly pode ser executado em hardware de verdade (FPGA) por\u00e9m nesse primeiro momento iremos trabalhar em um ambiente simulado que nos dar\u00e1 maior facilidade de programa\u00e7\u00e3o e depura\u00e7\u00e3o. Um pouco de contexto: O livro texto (The Elements Of Computer System) disponibiliza um simulador da CPU original todo escrito em java, esse c\u00f3digo \u00e9 fechado e n\u00e3o permite nenhuma customiza\u00e7\u00e3o. Em 2017 o Prof. Luciano Pereira iniciou a cria\u00e7\u00e3o de um simulador Z0 (vers\u00e3o anterior) tamb\u00e9m em Java, onde ter\u00edamos controle total do software. Percebemos alguns pontos negativos de utilizar um simulador em Java sendo o principal: Qualquer altera\u00e7\u00e3o no Hardware iria demandar uma altera\u00e7\u00e3o no simulador, sendo necess\u00e1rio mantermos dois projetos independentes e sincronizados. Nesta vers\u00e3o do curso iremos utilizar um simulador que utiliza o nosso pr\u00f3prio c\u00f3digo VHDL como descri\u00e7\u00e3o da CPU (e de tudo envolvido), uma altera\u00e7\u00e3o no hardware (VHDL) ir\u00e1 automaticamente alterar o simulador e o comportamento do computador. Para isso, fazemos uso do ModelSim, um software da Mentor Graphics que executa simula\u00e7\u00f5es em VHDL (o mesmo utilizado nos projetos anteriores), desenvolvemos uma s\u00e9rie de APIs e configura\u00e7\u00f5es desse simulador para funcionar para a disciplina. As APIS de interface do simulador foram desenvolvidas pelo Prof. Rafael Corsi (vhdl/ tcl/ python) e a interface gr\u00e1fica pelo Prof. Eduardo Marossi (python/ qt5). De uma olhada na pasta Z01-Tools na sua home, est\u00e1 tudo l\u00e1! O simulador possui a estrutura ilustrada a seguir: O simulador possui como entradas (para cada simula\u00e7\u00e3o): a arquitetura do computador (hardware); o conte\u00fado da mem\u00f3ria RAM o conte\u00fado da mem\u00f3ria ROM e um tempo de execu\u00e7\u00e3o. Ap\u00f3s o t\u00e9rmino da simula\u00e7\u00e3o \u00e9 exportado diversos sinais internos da CPU, o estado final da mem\u00f3ria RAM e ROM. Esses sinais s\u00e3o ent\u00e3o lidos pela interface gr\u00e1fica e exibida de uma forma amig\u00e1vel, ou usados nos testes.","title":"Simulador"},{"location":"assembly-Lab-1/#arquivos","text":"O simulador est\u00e1 localizado nas pastas Z01-tools/ : Z01-Simulator-GUI : Parte gr\u00e1fica do simulador Z01-Simulator-RTL : Hardware a ser executado no modelsim para executar o programa. Para inicializar o simulador basta executar o script localizado na pasta do projeto E: $ python3 E-Assembly/Z01simulador.py","title":"Arquivos"},{"location":"assembly-Lab-1/#interface-do-simulador","text":"O simulador possui a interface a seguir, onde a coluna da esquerda \u00e9 referente a mem\u00f3ria ROM (programa), a coluna da direita referente a mem\u00f3ria RAM (dados). Toda vez que houver uma altera\u00e7\u00e3o em algum dos par\u00e2metros do simulador (RAM/ROM/Instru\u00e7\u00f5es,...) o programa ser\u00e1 novamente executado no simulador para obtermos um resultado atualizado. Isso pode dar a sensa\u00e7\u00e3o de \"lerdeza\" mas lembre da complexidade do sistema: estamos executando um programa em um hardware inteiramente simulado no computador de voc\u00eas.","title":"Interface do Simulador"},{"location":"assembly-Lab-1/#programando","text":"Abra o simulador e insira o seguinte c\u00f3digo nasm (na parte referente a ROM), uma instru\u00e7\u00e3o por linha: leaw $ 1 , % A ; carrega a constant 1 em %A movw ( % A ), % D ; move o valor da RAM[%A] para %D leaw $ 0 , % A ; carrega a constant 0 em %A addw ( % A ), % D , % D ; faz RAM[%A] + %D e salva em %D leaw $ 2 , % A ; carrega a constant 2 em %A movw % D , ( % A ) ; copia o valor de %D para RAM[%A] Esse c\u00f3digo soma o valor que est\u00e1 salvo na mem\u00f3ria RAM endere\u00e7o 0 com o valor da mem\u00f3ria RAM endere\u00e7o 1 e salva no endere\u00e7o RAM[2]: RAM[2] = RAM[0] + RAM[1] mov A opera\u00e7\u00e3o de movw n\u00e3o 'move' o dado de um lugar para outro, ela copia. O valor no destino n\u00e3o \u00e9 apagado, por exemplo: leaw $ 10 , % A movw % A , % D Ao final dessas opera\u00e7\u00f5es os registradores %A e %D possui o valor 10. labels R0, R1, .., R15 , ... s\u00e3o nomes pr\u00e9 definidos de endere\u00e7os de mem\u00f3ria. O R0 indica o endere\u00e7o de mem\u00f3ria 0, R1 o endere\u00e7o de mem\u00f3ria 1 e assim por diante at\u00e9 o R15 . O mesmo c\u00f3digo pode ser escrito como: leaw $ R1 , % A movw ( % A ), % D leaw $ R0 , % A addw ( % A ), % D , % D leaw $ R2 , % A movw % D , ( % A ) Para testarmos esse c\u00f3digo ser\u00e1 necess\u00e1rio colocarmos valores iniciais na mem\u00f3ria RAM para validarmos o nosso c\u00f3digo, para isso altere a mem\u00f3ria RAM como demonstrado a seguir: Endere\u00e7o 0 = 5 Endere\u00e7o 1 = 8 Executando Com a mem\u00f3ria alterada voc\u00ea pode agora executar a simula\u00e7\u00e3o Verifique se o valor da mem\u00f3ria 2 \u00e9 a soma dos endere\u00e7os 0 e 1. Brinque com esses valores...","title":"Programando"},{"location":"assembly-Lab-1/#treinando","text":"Vamos praticar um pouco agora programar em assembly, no come\u00e7o parece bem dif\u00edcil, mas com a pr\u00e1tica as coisas v\u00e3o ficando mais f\u00e1ceis. Use o resumo das instru\u00e7\u00f5es: AssemblyZ01 para saber as instru\u00e7\u00f5es dispon\u00edveis. Altere o c\u00f3digo para armazenar o resultado no endere\u00e7o RAM[5] Solu\u00e7\u00e3o leaw $ 1 , % A movw ( % A ), % D leaw $ 0 , % A addw ( % A ), % D , % D leaw $ 5 , % A ; <- alterado essa linha para 5! movw % D , ( % A ) Altere o c\u00f3digo para armazenar o negativo da opera\u00e7\u00e3o entre RAM[0] + RAM[1] no endere\u00e7o RAM[5] (dica: tem uma opera\u00e7\u00e3o de NEG ). solu\u00e7\u00e3o leaw $ 1 , % A movw ( % A ), % D leaw $ 0 , % A addw ( % A ), % D , % D negw % D ; aqui eu fa\u00e7o %D = - %D leaw $ 5 , % A movw % D , ( % A )","title":"Treinando"},{"location":"assembly-Lab-1/#script-automatico-de-testes","text":"Al\u00e9m da interface gr\u00e1fica do simulador, possu\u00edmos um script de teste automatizado (similar ao do VHDL), esse script: E-Assembly/testeAssembly.py compila os c\u00f3digos que est\u00e3o na pasta E-Assembly/src/ para a pasta E-Assembly/bin/hack e executa os testes localizados em E-Assembly/tests/ . Somente os arquivos configurados no config_testes_nasm.txt ser\u00e3o testados.","title":"Script autom\u00e1tico de testes"},{"location":"assembly-Lab-1/#config_testes_nasmtxt","text":"O arquivo de configura\u00e7\u00e3o dos testes \u00e9 um pouco diferente, possui al\u00e9m do nome do m\u00f3dulo que ser\u00e1 testado um segundo par\u00e2metro que indica quantos testes ser\u00e3o executados para esse m\u00f3dulo e quantos microsegundos ele ficar\u00e1 na simula\u00e7\u00e3o (microsegundos suposto de um sistema real). Exemplo do config_testes_nasm.txt # nome | quantidade de testes | us de execucao #add 1 1000","title":"config_testes_nasm.txt"},{"location":"assembly-Lab-1/#implementando-o-addnasm","text":"Os arquivos a serem implementando est\u00e3o na pasta E-Assembly/src/ l\u00e1 voc\u00ea vai encontrar todos os c\u00f3digos fontes que dever\u00e3o ser feitos nesse projeto. Tarefa Edite o arquivo add.nasm realizando a implementa\u00e7\u00e3o que ele pede no coment\u00e1rio do arquivo (j\u00e1 foi feito nesse lab) vscode Abra o arquivo add.nasm no VsCode. Agora com o m\u00f3dulo implementando podemos testar seu funcionamento. Para isso execute o script testeAssembly.py . Esse script ir\u00e1 compilar o nasm e gerar os arquivos .hack e .mif (salvos no /bin/hack/ ) que ser\u00e3o carregados no simulador junto com uma configura\u00e7\u00e3o inicial da mem\u00f3ria RAM (como no gui do simulador), ao t\u00e9rmino da simula\u00e7\u00e3o um arquivo com o estado final da RAM \u00e9 salvo na pasta /tests/add/add0_end.mif . Executamos um script que compara o estado final da RAM com o um esperado ( add0_tst.mif ), em caso de algum erro, o script ir\u00e1 reportar falha. Se tudo ocorrer bem voc\u00ea dever\u00e1 ter a seguinte sa\u00edda : - Testando .... ------------------------- Starting add0 .... pass add0 ==== Summary =================================== + pass add teste: 0","title":"Implementando o add.nasm"},{"location":"assembly-Lab-1/#implementando-outros-modulos","text":"Vamos implementar outros m\u00f3dulos: sub.nasm e mov.nasm . Para cada m\u00f3dulo descomente o teste no config_tests_nasm.txt e leia o que deve ser feito nos coment\u00e1rios de cada arquivo. Tarefa Implementar o sub.nasm e testar Implementar o mov.nasm e testar","title":"Implementando outros m\u00f3dulos"},{"location":"assembly-Lab-2/","text":"Lab 11: Perif\u00e9ricos \u00b6 Ao final desse lab voc\u00ea deve ser capaz de: Escrever nos LEDs do nosso Z01 Ler das chaves (SW) do nosso Z01 Escrever no LCD do nosso Z01 Tip Para fazer esse lab, voc\u00ea deve ter lido a teoria sobre mapa de mem\u00f3ria Note D\u00favidas sobre assembly? Z01->Resumo Assembly Esse lab deve ser feito no Z01Simulador, para abrir o programa basta executar o script Z01simulador.py dentro da pasta do projeto E-Assembly Todos os arquivos possuem teste, ap\u00f3s programar no Simulador execute o teste LEDs \u00b6 Problemas relacionados ao LED do nosso Z01 Lembrando... Pergunta Qual endere\u00e7o de mem\u00f3ria para acessar os leds do Z01? Resposta 21184 led1.nasm E-Assembly/src/labs/led1.nasm Fa\u00e7a o LED0 acender resultado esperado resposta leaw $ 1 , % A movw % A , % D leaw $ 21184 , % A movw % D , ( % A ) led2.nasm E-Assembly/src/labs/led2.nasm Fa\u00e7a os LEDs: 9,7,5,3,1 acenderem resultado esperado dica Voc\u00ea precisa escrever a palavra 0b 1010101010 nos LEDs, converta para decimal e carrega na CPU com leaw Use uma calculadora/google para isso no google: bin 1010101010 to dec SW \u00b6 Problemas relacionado a chave do nosso Z01 Lembrando... Pergunta Qual endere\u00e7o de mem\u00f3ria para acessar as chaves SW do Z01? Resposta 21185 sw1.nasm E-Assembly/src/labs/sw1.nasm Fa\u00e7a os LEDs serem o valor das chaves: LED = SW configurando Antes de iniciar a simula\u00e7\u00e3o, voc\u00ea deve configurar as chaves: resultado esperado resposta leaw $ 21185 , % A movw ( % A ), % D leaw $ 21184 , % A movw % D , ( % A ) sw2.nasm E-Assembly/src/labs/sw2.nasm Fa\u00e7a os LEDs serem o contr\u00e1rio do valor das chaves: LED = !SW configurando Antes de iniciar a simula\u00e7\u00e3o, voc\u00ea deve configurar as chaves: resultado esperado dica Utilize a instru\u00e7\u00e3o notw %D para inverter o valor salvo no registrador %D LCD \u00b6 Trabalhando com o LCD. LCD Linhas 6-7 do arquivo E-Assembly/src/labs/lcd2.nasm \u2192 Acione os 16 primeiros pxs do LCD. resultado esperado dica leaw $ 16384 , % A movw $ - 1 , ( % A ) movw $-1, (%A) : Gera o vetor 1111111111111 e grava no endere\u00e7o que %A aponta (primeiros pxs do LCD) lcd2.nasm E-Assembly/src/labs/lcd2.nasm Acione todos os pxs da primeira posi\u00e7\u00e3o de mem\u00f3ria do LCD, do meio do LCD e da \u00faltima posi\u00e7\u00e3o de mem\u00f3ria do LCD. resultado esperado dica O endere\u00e7o central do LCD voc\u00eas podem calcular por: LCD = 320x240 1. enderecos_porLinha = 320/16 = 20 2. offset_linhaCentral = 20*240/2 = 2400 3. endereco_linhaCentral = 16384 + 2400 = 18784 4. px_central = 18784 + 10 = 18794","title":"Lab 11: Perif\u00e9ricos"},{"location":"assembly-Lab-2/#lab-11-perifericos","text":"Ao final desse lab voc\u00ea deve ser capaz de: Escrever nos LEDs do nosso Z01 Ler das chaves (SW) do nosso Z01 Escrever no LCD do nosso Z01 Tip Para fazer esse lab, voc\u00ea deve ter lido a teoria sobre mapa de mem\u00f3ria Note D\u00favidas sobre assembly? Z01->Resumo Assembly Esse lab deve ser feito no Z01Simulador, para abrir o programa basta executar o script Z01simulador.py dentro da pasta do projeto E-Assembly Todos os arquivos possuem teste, ap\u00f3s programar no Simulador execute o teste","title":"Lab 11: Perif\u00e9ricos"},{"location":"assembly-Lab-2/#leds","text":"Problemas relacionados ao LED do nosso Z01 Lembrando... Pergunta Qual endere\u00e7o de mem\u00f3ria para acessar os leds do Z01? Resposta 21184 led1.nasm E-Assembly/src/labs/led1.nasm Fa\u00e7a o LED0 acender resultado esperado resposta leaw $ 1 , % A movw % A , % D leaw $ 21184 , % A movw % D , ( % A ) led2.nasm E-Assembly/src/labs/led2.nasm Fa\u00e7a os LEDs: 9,7,5,3,1 acenderem resultado esperado dica Voc\u00ea precisa escrever a palavra 0b 1010101010 nos LEDs, converta para decimal e carrega na CPU com leaw Use uma calculadora/google para isso no google: bin 1010101010 to dec","title":"LEDs"},{"location":"assembly-Lab-2/#sw","text":"Problemas relacionado a chave do nosso Z01 Lembrando... Pergunta Qual endere\u00e7o de mem\u00f3ria para acessar as chaves SW do Z01? Resposta 21185 sw1.nasm E-Assembly/src/labs/sw1.nasm Fa\u00e7a os LEDs serem o valor das chaves: LED = SW configurando Antes de iniciar a simula\u00e7\u00e3o, voc\u00ea deve configurar as chaves: resultado esperado resposta leaw $ 21185 , % A movw ( % A ), % D leaw $ 21184 , % A movw % D , ( % A ) sw2.nasm E-Assembly/src/labs/sw2.nasm Fa\u00e7a os LEDs serem o contr\u00e1rio do valor das chaves: LED = !SW configurando Antes de iniciar a simula\u00e7\u00e3o, voc\u00ea deve configurar as chaves: resultado esperado dica Utilize a instru\u00e7\u00e3o notw %D para inverter o valor salvo no registrador %D","title":"SW"},{"location":"assembly-Lab-2/#lcd","text":"Trabalhando com o LCD. LCD Linhas 6-7 do arquivo E-Assembly/src/labs/lcd2.nasm \u2192 Acione os 16 primeiros pxs do LCD. resultado esperado dica leaw $ 16384 , % A movw $ - 1 , ( % A ) movw $-1, (%A) : Gera o vetor 1111111111111 e grava no endere\u00e7o que %A aponta (primeiros pxs do LCD) lcd2.nasm E-Assembly/src/labs/lcd2.nasm Acione todos os pxs da primeira posi\u00e7\u00e3o de mem\u00f3ria do LCD, do meio do LCD e da \u00faltima posi\u00e7\u00e3o de mem\u00f3ria do LCD. resultado esperado dica O endere\u00e7o central do LCD voc\u00eas podem calcular por: LCD = 320x240 1. enderecos_porLinha = 320/16 = 20 2. offset_linhaCentral = 20*240/2 = 2400 3. endereco_linhaCentral = 16384 + 2400 = 18784 4. px_central = 18784 + 10 = 18794","title":"LCD"},{"location":"assembly-Lab-3/","text":"Lab 12: saltos (jump) \u00b6 Ao final desse lab voc\u00ea deve ser capaz de: Escrever programas complexos em assembly que envolvem acesso a mem\u00f3ria e saltos (condicionais e incondicionais) Tip Para fazer esse lab, voc\u00ea deve ter lido a teoria sobre: mapa de mem\u00f3ria jump Note D\u00favidas sobre assembly? Z01->Resumo Assembly Esse lab deve ser feito no Z01Simulador, para abrir o programa basta executar o script Z01simulador.py dentro da pasta do projeto E-Assembly Incondicional \u00b6 lcd1.nasm E-Assembly/src/labs/lcd1.nasm Preencha todos os px do LCD de preto! configura\u00e7\u00e3o No Z01Simulador, abra as configura\u00e7\u00f5es e coloque o tempo de simula\u00e7\u00e3o em 40000 resultado esperado nasm Irei usar o RAM[0] para salvar o contador, que ser\u00e1 incrementado a partir do ende\u00e7o base do LCD 16384 at\u00e9 a onde o programa executar. Neste exemplo, o valor final do loop n\u00e3o est\u00e1 sendo controlado!! leaw $ 16384 , % A movw % A , % D leaw $ 0 , % A movw % D , ( % A ) LOOP: leaw $ 0 , % A movw ( % A ), % D addw $ 1 , % D , ( % A ) movw % D , % A movw $ - 1 , ( % A ) leaw $ LOOP , % A jmp nop Condicional \u00b6 Saltos condicionais s\u00e3o utilizados para verificarmos condi\u00e7\u00f5es no programa, vamos trabalhar um pouco com isso. jmp1.nasm E-Assembly/src/labs/jmp1.nasm Implemente o pseudo c\u00f3digo a seguir em nasm: if RAM [ 1 ] == 0 : RAM [ 0 ] = 1 else RAM [ 0 ] = 2 configura\u00e7\u00e3o Teste o programa com diferentes valores na RAM[1]: Teste 1: RAM[1] = 3 Teste 2: RAM[1] = 0 resultado esperado Teste 1: RAM[0] = 2 Teste 2: RAM[0] = 1 dica Podemos reescrever o c\u00f3digo para ficar: RAM [ 0 ] = 2 if RAM [ 1 ] == 0 : RAM [ 0 ] = 1 nasm leaw $ 2 , % A movw % A , % D leaw $ 0 , % A movw % D , ( % A ) ; RAM[0] = 2 leaw $ 1 , % A movw ( % A ), % D ; busca valor verificar (RAM[1]) leaw $ END , % A ; prepara salto jne ; RAM[1] == 0? nop leaw $ 1 , % A movw $ 1 , ( % A ) ; RAM[=] = 1 END: jmp3.nasm E-Assembly/src/labs/jmp3.nasm Implemente o pseudo c\u00f3digo a seguir em nasm: if RAM [ 1 ] == 3 : RAM [ 0 ] = 1 else RAM [ 0 ] = 2 configura\u00e7\u00e3o Teste o programa com diferentes valores na RAM: Teste 1: RAM[1] = 3 Teste 2: RAM[1] = 0 resultado esperado Teste 1: RAM[0] = 1 Teste 2: RAM[0] = 2 dica N\u00e3o temos uma instru\u00e7\u00e3o de jmp que verifica se o valor de %D \u00e9 igual a 3, por\u00e9m podemos subtrair 3 do calor salvo em RAM[1] e verificar se o resultado \u00e9 igual a 0: RAM [ 0 ] = 2 if RAM [ 1 ] - 3 == 0 : RAM [ 0 ] = 1 leaw $ 1 , % A movw ( % A ), % D leaw $ 3 , % A subw % D , % A , % D ; %D = RAM[1] - 3 jmp4.nasm Criar o arquivo E-Assembly/src/labs/jmp4.nasm Implemente o pseudo c\u00f3digo a seguir em nasm: if RAM [ 1 ] + RAM [ 2 ] >= 3 : RAM [ 0 ] = 1 else RAM [ 0 ] = 2 configura\u00e7\u00e3o Teste o programa com diferentes valores na RAM: Teste 1: RAM[1] = 1 / RAM[2] = 4 Teste 2: RAM[1] = 1 / RAM[2] = 1 resultado esperado Teste 1: RAM[0] = 1 Teste 2: RAM[0] = 2 jmp5.nasm Criar o arquivo E-Assembly/src/labs/jmp5.nasm Acione a metade superior dos pxs do LCD de preto. configura\u00e7\u00e3o No Z01Simulador, abra as configura\u00e7\u00f5es e coloque o tempo de simula\u00e7\u00e3o em 40000 resultado esperado","title":"Lab 12: saltos (jump)"},{"location":"assembly-Lab-3/#lab-12-saltos-jump","text":"Ao final desse lab voc\u00ea deve ser capaz de: Escrever programas complexos em assembly que envolvem acesso a mem\u00f3ria e saltos (condicionais e incondicionais) Tip Para fazer esse lab, voc\u00ea deve ter lido a teoria sobre: mapa de mem\u00f3ria jump Note D\u00favidas sobre assembly? Z01->Resumo Assembly Esse lab deve ser feito no Z01Simulador, para abrir o programa basta executar o script Z01simulador.py dentro da pasta do projeto E-Assembly","title":"Lab 12: saltos (jump)"},{"location":"assembly-Lab-3/#incondicional","text":"lcd1.nasm E-Assembly/src/labs/lcd1.nasm Preencha todos os px do LCD de preto! configura\u00e7\u00e3o No Z01Simulador, abra as configura\u00e7\u00f5es e coloque o tempo de simula\u00e7\u00e3o em 40000 resultado esperado nasm Irei usar o RAM[0] para salvar o contador, que ser\u00e1 incrementado a partir do ende\u00e7o base do LCD 16384 at\u00e9 a onde o programa executar. Neste exemplo, o valor final do loop n\u00e3o est\u00e1 sendo controlado!! leaw $ 16384 , % A movw % A , % D leaw $ 0 , % A movw % D , ( % A ) LOOP: leaw $ 0 , % A movw ( % A ), % D addw $ 1 , % D , ( % A ) movw % D , % A movw $ - 1 , ( % A ) leaw $ LOOP , % A jmp nop","title":"Incondicional"},{"location":"assembly-Lab-3/#condicional","text":"Saltos condicionais s\u00e3o utilizados para verificarmos condi\u00e7\u00f5es no programa, vamos trabalhar um pouco com isso. jmp1.nasm E-Assembly/src/labs/jmp1.nasm Implemente o pseudo c\u00f3digo a seguir em nasm: if RAM [ 1 ] == 0 : RAM [ 0 ] = 1 else RAM [ 0 ] = 2 configura\u00e7\u00e3o Teste o programa com diferentes valores na RAM[1]: Teste 1: RAM[1] = 3 Teste 2: RAM[1] = 0 resultado esperado Teste 1: RAM[0] = 2 Teste 2: RAM[0] = 1 dica Podemos reescrever o c\u00f3digo para ficar: RAM [ 0 ] = 2 if RAM [ 1 ] == 0 : RAM [ 0 ] = 1 nasm leaw $ 2 , % A movw % A , % D leaw $ 0 , % A movw % D , ( % A ) ; RAM[0] = 2 leaw $ 1 , % A movw ( % A ), % D ; busca valor verificar (RAM[1]) leaw $ END , % A ; prepara salto jne ; RAM[1] == 0? nop leaw $ 1 , % A movw $ 1 , ( % A ) ; RAM[=] = 1 END: jmp3.nasm E-Assembly/src/labs/jmp3.nasm Implemente o pseudo c\u00f3digo a seguir em nasm: if RAM [ 1 ] == 3 : RAM [ 0 ] = 1 else RAM [ 0 ] = 2 configura\u00e7\u00e3o Teste o programa com diferentes valores na RAM: Teste 1: RAM[1] = 3 Teste 2: RAM[1] = 0 resultado esperado Teste 1: RAM[0] = 1 Teste 2: RAM[0] = 2 dica N\u00e3o temos uma instru\u00e7\u00e3o de jmp que verifica se o valor de %D \u00e9 igual a 3, por\u00e9m podemos subtrair 3 do calor salvo em RAM[1] e verificar se o resultado \u00e9 igual a 0: RAM [ 0 ] = 2 if RAM [ 1 ] - 3 == 0 : RAM [ 0 ] = 1 leaw $ 1 , % A movw ( % A ), % D leaw $ 3 , % A subw % D , % A , % D ; %D = RAM[1] - 3 jmp4.nasm Criar o arquivo E-Assembly/src/labs/jmp4.nasm Implemente o pseudo c\u00f3digo a seguir em nasm: if RAM [ 1 ] + RAM [ 2 ] >= 3 : RAM [ 0 ] = 1 else RAM [ 0 ] = 2 configura\u00e7\u00e3o Teste o programa com diferentes valores na RAM: Teste 1: RAM[1] = 1 / RAM[2] = 4 Teste 2: RAM[1] = 1 / RAM[2] = 1 resultado esperado Teste 1: RAM[0] = 1 Teste 2: RAM[0] = 2 jmp5.nasm Criar o arquivo E-Assembly/src/labs/jmp5.nasm Acione a metade superior dos pxs do LCD de preto. configura\u00e7\u00e3o No Z01Simulador, abra as configura\u00e7\u00f5es e coloque o tempo de simula\u00e7\u00e3o em 40000 resultado esperado","title":"Condicional"},{"location":"assembly-Lab-4/","text":"Lab 13: praticando nasm \u00b6 Ao final desse lab voc\u00ea deve ser capaz de: Fazer programas complexos em assembly Os seguintes programas s\u00e3o contemplados nesse lab: mov max abs mult (muito importante estudar!) Os problemas desse lab possuem teste unit\u00e1rio, para isso voc\u00ea deve editar o arquivo de configura\u00e7\u00f5es de teste: config_testes_nasm.txt e descomentar o m\u00f3dulo que est\u00e1 implementando. E ent\u00e3o executar o script testeAssembly.py mov.nasm E-Assembly/src/mov.nasm Movimenta\u00e7\u00e3o de dados da memoria RAM RAM[0] = RAM[1] RAM[1] = RAM[0] RAM[3] = 1 max.nasm E-Assembly/src/max.nasm RAM2 = max(RAM[0], RAM[1]) ou seja, o maior valor que estiver, ou em R0 ou R1 sera copiado para R2 Estamos considerando n\u00famero inteiros. abs.nasm E-Assembly/src/abs.nasm Copia o valor de RAM[1] para RAM[0] deixando o valor sempre positivo. mult.nasm E-Assembly/src/mult.nasm Multiplica o valor de RAM[1] com RAM[0] salvando em RAM[3]","title":"Lab 13: praticando nasm"},{"location":"assembly-Lab-4/#lab-13-praticando-nasm","text":"Ao final desse lab voc\u00ea deve ser capaz de: Fazer programas complexos em assembly Os seguintes programas s\u00e3o contemplados nesse lab: mov max abs mult (muito importante estudar!) Os problemas desse lab possuem teste unit\u00e1rio, para isso voc\u00ea deve editar o arquivo de configura\u00e7\u00f5es de teste: config_testes_nasm.txt e descomentar o m\u00f3dulo que est\u00e1 implementando. E ent\u00e3o executar o script testeAssembly.py mov.nasm E-Assembly/src/mov.nasm Movimenta\u00e7\u00e3o de dados da memoria RAM RAM[0] = RAM[1] RAM[1] = RAM[0] RAM[3] = 1 max.nasm E-Assembly/src/max.nasm RAM2 = max(RAM[0], RAM[1]) ou seja, o maior valor que estiver, ou em R0 ou R1 sera copiado para R2 Estamos considerando n\u00famero inteiros. abs.nasm E-Assembly/src/abs.nasm Copia o valor de RAM[1] para RAM[0] deixando o valor sempre positivo. mult.nasm E-Assembly/src/mult.nasm Multiplica o valor de RAM[1] com RAM[0] salvando em RAM[3]","title":"Lab 13: praticando nasm"},{"location":"assembly-Projeto/","text":"E - Assembly \u00b6 Entrega 04/11 - Sexta Nesse projeto cada grupo ter\u00e1 que implementar diversos c\u00f3digos em assembly a fim de entendermos a linguagem e as limita\u00e7\u00f5es do hardware propostos. Instru\u00e7\u00f5es \u00b6 Seguir as instru\u00e7\u00f5es a seguir para desenvolvimento do projeto. Entendendo a Organiza\u00e7\u00e3o do Projeto \u00b6 A pasta do projeto E, no reposit\u00f3rio Z01, possui a seguinte estrutura: E-Assembly/ testeAssembly.py Z01simulator.py /Quartus /src /nasm *.nasm /tests /tst /abs /add .... Quartus : Projeto Quartus para gravar o computador na FPGA *.py : Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/nasm/*.nasm : Arquivos ASSEMBLY que ser\u00e3o implementados pelo grupo; tests/tst/* : Arquivos que realizam o teste nos arquivos c\u00f3digos do rtl. Executando o Script de Teste \u00b6 Abra o terminal na pasta E-Assembly/ e execute o script python localizado nessa pasta: $ ./testeAssembly.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.nasm e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Esse comando executa um teste unit\u00e1rio em cada um dos m\u00f3dulos, verificando se sua implementa\u00e7\u00e3o est\u00e1 correta. O resultado \u00e9 exibido na tela como pass ou fail . Tip O arquivo config_testes_nasm.txt define quais testes ser\u00e3o executados. Projeto \u00b6 Deve-se implementar diversos programas na linguagem de m\u00e1quina do Z01 que ir\u00e3o manipular a mem\u00f3ria RAM a fim de implementar o que \u00e9 pedido. A descri\u00e7\u00e3o a seguir est\u00e1 classificada em ordem de dificuldade, come\u00e7ando pelos mais simples. M\u00f3dulos \u00b6 Esses arquivos est\u00e3o localizados em E-Assembly/src/ A descri\u00e7\u00e3o de cada m\u00f3dulo est\u00e1 localizada no cabe\u00e7alho do arquivo. add Arquivo : add.nasm ( lab 10 ) sub Arquivo : sub.nasm ( lab 10 ) mov Arquivo : mov.nasm ( lab 10 ) abs Arquivo : abs.nasm ( lab 12 ) max Arquivo : max.nasm ( lab 12 ) mult Arquivo : mult.nasm ( lab 12 ) mod Arquivo : mod.nasm div Arquivo : div.nasm pow Arquivo : pow.nasm \u00c9 par Arquivo : isEven.nasm String length Arquivo : stringLength.nasm Conceito B \u00b6 Palindromo Arquivo : palindromo.nasm fatorial Arquivo : fatorial.nasm Mean Arquivo : vectorMean.nasm Chaves e Leds Arquivo : SWeLED.nasm Conceito A \u00b6 Linha Arquivo : LCDlinha.nasm Edite o arquivo para desenhar uma linha completa Quadrado Arquivo : quadrado.nasm Letra Grupo Arquivo : LCDletraGrupo.nasm O funcionamento dos arquivos que envolvem SWs, LEDs e LCD deve ser demonstrado na FPGA. Extra \u00b6 SWeLED2 Arquivo : SWeLED2.nasm Nome grupo Arquivo : LCDnomeGrupo.nasm excelToLCD.py Arquivo : excelToLCD.py Criar um programa em python que converte um tabela do excel (onde cada c\u00e9lula equivale a um px pintado) em um c\u00f3digo nasm que executa no Z01 e gera a imagem da tabela Formul\u00e1rios \u00b6 Scrum Master Desenvolvedores","title":"E - Assembly"},{"location":"assembly-Projeto/#e-assembly","text":"Entrega 04/11 - Sexta Nesse projeto cada grupo ter\u00e1 que implementar diversos c\u00f3digos em assembly a fim de entendermos a linguagem e as limita\u00e7\u00f5es do hardware propostos.","title":"E - Assembly"},{"location":"assembly-Projeto/#instrucoes","text":"Seguir as instru\u00e7\u00f5es a seguir para desenvolvimento do projeto.","title":"Instru\u00e7\u00f5es"},{"location":"assembly-Projeto/#entendendo-a-organizacao-do-projeto","text":"A pasta do projeto E, no reposit\u00f3rio Z01, possui a seguinte estrutura: E-Assembly/ testeAssembly.py Z01simulator.py /Quartus /src /nasm *.nasm /tests /tst /abs /add .... Quartus : Projeto Quartus para gravar o computador na FPGA *.py : Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/nasm/*.nasm : Arquivos ASSEMBLY que ser\u00e3o implementados pelo grupo; tests/tst/* : Arquivos que realizam o teste nos arquivos c\u00f3digos do rtl.","title":"Entendendo a Organiza\u00e7\u00e3o do Projeto"},{"location":"assembly-Projeto/#executando-o-script-de-teste","text":"Abra o terminal na pasta E-Assembly/ e execute o script python localizado nessa pasta: $ ./testeAssembly.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.nasm e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Esse comando executa um teste unit\u00e1rio em cada um dos m\u00f3dulos, verificando se sua implementa\u00e7\u00e3o est\u00e1 correta. O resultado \u00e9 exibido na tela como pass ou fail . Tip O arquivo config_testes_nasm.txt define quais testes ser\u00e3o executados.","title":"Executando o Script de Teste"},{"location":"assembly-Projeto/#projeto","text":"Deve-se implementar diversos programas na linguagem de m\u00e1quina do Z01 que ir\u00e3o manipular a mem\u00f3ria RAM a fim de implementar o que \u00e9 pedido. A descri\u00e7\u00e3o a seguir est\u00e1 classificada em ordem de dificuldade, come\u00e7ando pelos mais simples.","title":"Projeto"},{"location":"assembly-Projeto/#modulos","text":"Esses arquivos est\u00e3o localizados em E-Assembly/src/ A descri\u00e7\u00e3o de cada m\u00f3dulo est\u00e1 localizada no cabe\u00e7alho do arquivo. add Arquivo : add.nasm ( lab 10 ) sub Arquivo : sub.nasm ( lab 10 ) mov Arquivo : mov.nasm ( lab 10 ) abs Arquivo : abs.nasm ( lab 12 ) max Arquivo : max.nasm ( lab 12 ) mult Arquivo : mult.nasm ( lab 12 ) mod Arquivo : mod.nasm div Arquivo : div.nasm pow Arquivo : pow.nasm \u00c9 par Arquivo : isEven.nasm String length Arquivo : stringLength.nasm","title":"M\u00f3dulos"},{"location":"assembly-Projeto/#conceito-b","text":"Palindromo Arquivo : palindromo.nasm fatorial Arquivo : fatorial.nasm Mean Arquivo : vectorMean.nasm Chaves e Leds Arquivo : SWeLED.nasm","title":"Conceito B"},{"location":"assembly-Projeto/#conceito-a","text":"Linha Arquivo : LCDlinha.nasm Edite o arquivo para desenhar uma linha completa Quadrado Arquivo : quadrado.nasm Letra Grupo Arquivo : LCDletraGrupo.nasm O funcionamento dos arquivos que envolvem SWs, LEDs e LCD deve ser demonstrado na FPGA.","title":"Conceito A"},{"location":"assembly-Projeto/#extra","text":"SWeLED2 Arquivo : SWeLED2.nasm Nome grupo Arquivo : LCDnomeGrupo.nasm excelToLCD.py Arquivo : excelToLCD.py Criar um programa em python que converte um tabela do excel (onde cada c\u00e9lula equivale a um px pintado) em um c\u00f3digo nasm que executa no Z01 e gera a imagem da tabela","title":"Extra"},{"location":"assembly-Projeto/#formularios","text":"Scrum Master Desenvolvedores","title":"Formul\u00e1rios"},{"location":"assembly-lab-HW/","text":"Programando FPGA \u00b6 Ao final desse lab voc\u00ea deve ser capaz de: Conectar o LCD na FPGA Programar a FPGA com o Z01.1 Programar um programa em nasm no Z01.1 Conectando o LCD \u00b6 Programando a FPGA \u00b6 A FPGA \u00e9 um hardware que pode sr configur\u00e1vel para implementar 'qualquer' sistema digital, incluindo um computador. Iremos primeiramente prograr a FPGA com o Hardware do Z01 para ent\u00e3o podermos programar o nosso c\u00f3digo em assembly. Para isso, execute o script python: $ ./programFPGA.py Esse script ir\u00e1 carregar na FPGA o hardware do Z01.1 Note Nossa FPGA \u00e9 dita do tipo vol\u00e1til, ela perde a configura\u00e7\u00e3o sempre que for desligada! Essa etapa deve ser realizada sempre que ela desligar. Programando o Z01.1 \u00b6 Agora com o Z01.1 configurado na FPGA podemos executar nosso programa no hardware, basta chamar o script programSoftware.py com o par\u00e2metro -n e o caminho para o c\u00f3digo nasm . Como no exemplo a seguir: ./programSoftware.py -n src/examples/R-LCD.nasm O mesmo deve executar um c\u00f3digo no Z01 que escreve a letra R no LCD. Programe os exemplos a seguir: pxLCD.nasm : Escreve apenas 16 pixels no LCD (um ponto) testeLED.nasm : Um programa que exibe um contador bin\u00e1rio nos LEDs da FPGA testeSW.nasm : Um programa que l\u00ea as chaves da FPGA e aciona os LEDs com base no seus resultados. Praticando \u00b6 Grave na FPGA o programa testeSW.nasm Mexa nas chaves SW e veja o que acontece com os LEDS. Altere o programa para ser o inverso do que foi programado. Quando as chaves estiverem para baixo, o respectivo LED acende e quando a chave estiver para cima o LED apaga. Tip Valide na FPGA!","title":"Programando FPGA"},{"location":"assembly-lab-HW/#programando-fpga","text":"Ao final desse lab voc\u00ea deve ser capaz de: Conectar o LCD na FPGA Programar a FPGA com o Z01.1 Programar um programa em nasm no Z01.1","title":"Programando FPGA"},{"location":"assembly-lab-HW/#conectando-o-lcd","text":"","title":"Conectando o LCD"},{"location":"assembly-lab-HW/#programando-a-fpga","text":"A FPGA \u00e9 um hardware que pode sr configur\u00e1vel para implementar 'qualquer' sistema digital, incluindo um computador. Iremos primeiramente prograr a FPGA com o Hardware do Z01 para ent\u00e3o podermos programar o nosso c\u00f3digo em assembly. Para isso, execute o script python: $ ./programFPGA.py Esse script ir\u00e1 carregar na FPGA o hardware do Z01.1 Note Nossa FPGA \u00e9 dita do tipo vol\u00e1til, ela perde a configura\u00e7\u00e3o sempre que for desligada! Essa etapa deve ser realizada sempre que ela desligar.","title":"Programando a FPGA"},{"location":"assembly-lab-HW/#programando-o-z011","text":"Agora com o Z01.1 configurado na FPGA podemos executar nosso programa no hardware, basta chamar o script programSoftware.py com o par\u00e2metro -n e o caminho para o c\u00f3digo nasm . Como no exemplo a seguir: ./programSoftware.py -n src/examples/R-LCD.nasm O mesmo deve executar um c\u00f3digo no Z01 que escreve a letra R no LCD. Programe os exemplos a seguir: pxLCD.nasm : Escreve apenas 16 pixels no LCD (um ponto) testeLED.nasm : Um programa que exibe um contador bin\u00e1rio nos LEDs da FPGA testeSW.nasm : Um programa que l\u00ea as chaves da FPGA e aciona os LEDs com base no seus resultados.","title":"Programando o Z01.1"},{"location":"assembly-lab-HW/#praticando","text":"Grave na FPGA o programa testeSW.nasm Mexa nas chaves SW e veja o que acontece com os LEDS. Altere o programa para ser o inverso do que foi programado. Quando as chaves estiverem para baixo, o respectivo LED acende e quando a chave estiver para cima o LED apaga. Tip Valide na FPGA!","title":"Praticando"},{"location":"cpu-DicasBeA/","text":"Dicas B/A \u00b6 B \u00b6 N\u00e3o vamos ter o teste do memoryIO nem do controlUnit adequados para as mudan\u00e7as, ser\u00e1 necess\u00e1rio testar direto no Hardware: Abrir Quartus e compilar projeto Executar programMyFPGA.py Como voc\u00eas alteraram o InstructionSet, ser\u00e1 necess\u00e1rio escrever um programa em linguagem de m\u00e1quina, para isso: Altere o arquivo: testeComputador.mif com suas opera\u00e7\u00f5es Execute ./programSoftware.py -m testeComputador.mif para programar a ROM do Z01.1 com seu programa. Note que o arquivo testeComputador.mif possui um campo que \u00e9 DEPTH=30; Voc\u00ea deve alterar esse valor para a quantidade de linhas que seu programa possui! A \u00b6 Para inserir o display sete segmentos (7s) ser\u00e1 necess\u00e1rio: Modificar o memoryIO Adicionar novas sa\u00eddas na entity Adicionar perif\u00e9rico que recebe vetor de bits e converte para sinais do 7s Decoder Modificar Computador.vhd Deve-se agora rotear os novos sinais do memoryIO para os pinos da FPGA, para isso modifique a entity do Computador.vhd para entity Computador is generic( IS_SIMULATION : std_logic := '0' ); port( -- Sistema CLOCK_50 : in std_logic; RESET_N : in std_logic; LEDR : out std_logic_vector(9 downto 0); SW : in std_logic_vector(9 downto 0); -- LCD EXTERNAL I/OS LCD_CS_N : out std_logic; LCD_D : inout std_logic_vector(15 downto 0); LCD_RD_N : out std_logic; LCD_RESET_N : out std_logic; LCD_RS : out std_logic; LCD_WR_N : out std_logic; LCD_ON : out std_logic; + --- Seven Seg + HEX0 : out std_logic_vector(6 downto 0); -- 7seg0 + HEX1 : out std_logic_vector(6 downto 0); -- 7seg1 + HEX2 : out std_logic_vector(6 downto 0); -- 7seg2 + HEX3 : out std_logic_vector(6 downto 0) -- 7seg3 ); end entity; Programando ROM com linguagem de m\u00e1quina \u00b6 Uma vez implementando as modifica\u00e7\u00f5es no HW n\u00e3o temos mais como realizar os testes l\u00f3gicos na CPU ( testeHW e testeAssemblyMyCPU ), j\u00e1 que o nosso Assembler n\u00e3o est\u00e1 adequado para essas modifica\u00e7\u00f5es. Uma alternativa para verificarmos se a altera\u00e7\u00e3o est\u00e1 certa \u00e9: 1. Compilar no Quartus o novo computador 1. Programar a FPGA com o novo HW ./programMyFPGA.py 1. Escreva um programa em linguagem de m\u00e1quina (adequado ao novo Instruction Set) que teste as novas funcionalidades. - Programa j\u00e1 em bin\u00e1rio, extens\u00e3o: .mif - Exemplo na pasta: Projeto/G-CPU/testeComputador.mif 1. Programar a mem\u00f3ria da ROM com arquivo .mif : ./programSoftware -m Arquivo.mif 1. Verificar a funcionalidade das modifica\u00e7\u00f5es. Arquivo .mif \u00b6 O .mif \u00e9 um formato de arquivo que possibilita carregarmos uma mem\u00f3ria na FPGA, ele possui a seguinte estrutura: WIDTH=18; DEPTH=5; ADDRESS_RADIX=UNS; DATA_RADIX=BIN; CONTENT BEGIN 0 : 000000000000000101; 1 : 100101100000010000; 2 : 000000000000000001; 3 : 100000000000100000; 4 : 000000000000001011; END; Voc\u00ea deve editar a linha DEPTH=5; para a quantidade de linhas que seu programa possui! Esse arquivo \u00e9 geralmente gerado pelo Assembler : assembler .nasm ---------> .mif v |---------> FPGA |---------> SIMULADOR Teclado como perif\u00e9rico \u00b6 Adicionar os seguintes sinais na entidade do Computador.vhd e do memoryIO.vhd PS2_CLK : in std_logic; PS2_DAT : in std_logic; E implementar a leitura das teclas no memoryIO . Dica: https://www.digikey.com/eewiki/pages/viewpage.action?pageId=28278929","title":"Dicas B/A"},{"location":"cpu-DicasBeA/#dicas-ba","text":"","title":"Dicas B/A"},{"location":"cpu-DicasBeA/#b","text":"N\u00e3o vamos ter o teste do memoryIO nem do controlUnit adequados para as mudan\u00e7as, ser\u00e1 necess\u00e1rio testar direto no Hardware: Abrir Quartus e compilar projeto Executar programMyFPGA.py Como voc\u00eas alteraram o InstructionSet, ser\u00e1 necess\u00e1rio escrever um programa em linguagem de m\u00e1quina, para isso: Altere o arquivo: testeComputador.mif com suas opera\u00e7\u00f5es Execute ./programSoftware.py -m testeComputador.mif para programar a ROM do Z01.1 com seu programa. Note que o arquivo testeComputador.mif possui um campo que \u00e9 DEPTH=30; Voc\u00ea deve alterar esse valor para a quantidade de linhas que seu programa possui!","title":"B"},{"location":"cpu-DicasBeA/#a","text":"Para inserir o display sete segmentos (7s) ser\u00e1 necess\u00e1rio: Modificar o memoryIO Adicionar novas sa\u00eddas na entity Adicionar perif\u00e9rico que recebe vetor de bits e converte para sinais do 7s Decoder Modificar Computador.vhd Deve-se agora rotear os novos sinais do memoryIO para os pinos da FPGA, para isso modifique a entity do Computador.vhd para entity Computador is generic( IS_SIMULATION : std_logic := '0' ); port( -- Sistema CLOCK_50 : in std_logic; RESET_N : in std_logic; LEDR : out std_logic_vector(9 downto 0); SW : in std_logic_vector(9 downto 0); -- LCD EXTERNAL I/OS LCD_CS_N : out std_logic; LCD_D : inout std_logic_vector(15 downto 0); LCD_RD_N : out std_logic; LCD_RESET_N : out std_logic; LCD_RS : out std_logic; LCD_WR_N : out std_logic; LCD_ON : out std_logic; + --- Seven Seg + HEX0 : out std_logic_vector(6 downto 0); -- 7seg0 + HEX1 : out std_logic_vector(6 downto 0); -- 7seg1 + HEX2 : out std_logic_vector(6 downto 0); -- 7seg2 + HEX3 : out std_logic_vector(6 downto 0) -- 7seg3 ); end entity;","title":"A"},{"location":"cpu-DicasBeA/#programando-rom-com-linguagem-de-maquina","text":"Uma vez implementando as modifica\u00e7\u00f5es no HW n\u00e3o temos mais como realizar os testes l\u00f3gicos na CPU ( testeHW e testeAssemblyMyCPU ), j\u00e1 que o nosso Assembler n\u00e3o est\u00e1 adequado para essas modifica\u00e7\u00f5es. Uma alternativa para verificarmos se a altera\u00e7\u00e3o est\u00e1 certa \u00e9: 1. Compilar no Quartus o novo computador 1. Programar a FPGA com o novo HW ./programMyFPGA.py 1. Escreva um programa em linguagem de m\u00e1quina (adequado ao novo Instruction Set) que teste as novas funcionalidades. - Programa j\u00e1 em bin\u00e1rio, extens\u00e3o: .mif - Exemplo na pasta: Projeto/G-CPU/testeComputador.mif 1. Programar a mem\u00f3ria da ROM com arquivo .mif : ./programSoftware -m Arquivo.mif 1. Verificar a funcionalidade das modifica\u00e7\u00f5es.","title":"Programando ROM com linguagem de m\u00e1quina"},{"location":"cpu-DicasBeA/#arquivo-mif","text":"O .mif \u00e9 um formato de arquivo que possibilita carregarmos uma mem\u00f3ria na FPGA, ele possui a seguinte estrutura: WIDTH=18; DEPTH=5; ADDRESS_RADIX=UNS; DATA_RADIX=BIN; CONTENT BEGIN 0 : 000000000000000101; 1 : 100101100000010000; 2 : 000000000000000001; 3 : 100000000000100000; 4 : 000000000000001011; END; Voc\u00ea deve editar a linha DEPTH=5; para a quantidade de linhas que seu programa possui! Esse arquivo \u00e9 geralmente gerado pelo Assembler : assembler .nasm ---------> .mif v |---------> FPGA |---------> SIMULADOR","title":"Arquivo .mif"},{"location":"cpu-DicasBeA/#teclado-como-periferico","text":"Adicionar os seguintes sinais na entidade do Computador.vhd e do memoryIO.vhd PS2_CLK : in std_logic; PS2_DAT : in std_logic; E implementar a leitura das teclas no memoryIO . Dica: https://www.digikey.com/eewiki/pages/viewpage.action?pageId=28278929","title":"Teclado como perif\u00e9rico"},{"location":"cpu-Projeto/","text":"Projeto \u00b6 Entrega 17/11 - Quinta Nesse projeto cada grupo ter\u00e1 que implementar sua pr\u00f3pria CPU do Z01. Come\u00e7ando \u00b6 A seguir explica\u00e7\u00f5es de como come\u00e7ar o projeto. Entendendo a Organiza\u00e7\u00e3o do Projeto \u00b6 A pasta do projeto F no reposit\u00f3rio Z01, possui a seguinte estrutura: F-Computador/ testeHW.py Z01SimuladorMyCPU.py src/ Quartus/ Z01-Simulator-RTL/ testeHW.py : Testa o controlUnit.vhd , memoryIO.vhd e todo o HW do computador ( CPU.vhd ) Z01SimuladorMyCPU.py : Abre o simulador gr\u00e1fico do Z01.1 com o HW do grupo Z01-Simulator-RTL : Pasta com o simulador do computador Testando HW (ControlUnit e MemoryIO) \u00b6 Abra o terminal na pasta F-Computador , deixe descomentado apenas as linhas referentes ao ControlUnit.vhd e ao MemoryIO.vhd no arquivo config_testes.txt e execute o script python: $ ./testeHW.py Testando o projeto completo \u00b6 Para testar se o computador est\u00e1 correto, iremos executar alguns programas realizados na APS E-Assembly por\u00e9m agora no Harware que voc\u00eas montaram. Apenas execute esse teste ap\u00f3s a implementa\u00e7\u00e3o dos tr\u00eas m\u00f3dulos solicitados no projeto. Para isso, descomente a linha referente ao CPU.vhd no arquivo config_testes.txt execute. $ ./testeHW.py Todos os m\u00f3dulos vhdl (desde o projeto B) ser\u00e3o compilados e o CPU.vhd ser\u00e1 executado. Todos os programas em Assembly que estiverem descomentados no arquivo config_testes_nasm.txt na pasta E-Assembly ser\u00e3o verificados. Na sequ\u00eancia, iremos comparar se a resposta (mem\u00f3ria RAM) possui o resultado esperado. Como os programas s\u00e3o complexos, esperamos com isso conseguir testar a totalidade do projeto. Tip Temos uma p\u00e1gina inteira detalhando como debugamos esse teste: Testando CPU Actions \u00b6 Adicione ao Actions o teste: testeHW.py Tip No Actions voc\u00ea tem que colocar o caminho completo: F-Computador/... Projeto \u00b6 Deve-se implementar o Control Unit e integrar os m\u00f3dulos: MemoryIO e CPU . O HDL que descreve o Computador j\u00e1 foi fornecido pronto. M\u00f3dulos \u00b6 Note Esses arquivos est\u00e3o localizados em F-Computador/src/ Os m\u00f3dulos est\u00e3o listados de maneira Top - Down Computador ( j\u00e1 est\u00e1 pronto! N\u00e3o precisa mexer , mas \u00e9 legal ver!) Arquivo : computador.vhd Descri\u00e7\u00e3o : TopLevel do projeto, entidade que integra a mem\u00f3ria ROM o MemoryIO, CPU e PLL Depend\u00eancias : Dispositivos/ROM/ROM32K.vhd : ROM a ser utilizada no projeto (j\u00e1 foi dado pronto) Dispositivos/PLL/PLL.vhd : PLL a ser utilizada no projeto (j\u00e1 foi dado pronto) MemoryIO Arquivo : MemoryIO.vhd Descri\u00e7\u00e3o : Faz o mapa de mem\u00f3ria para a CPU. Depend\u00eancias : Dispositivos/RAM/RAM16K.vhd : RAM a ser utilizada no projeto (j\u00e1 foi dado pronto) Dispositivos/Screen/Screen.vhd : Controlador do LCD a ser utilizada no projeto (j\u00e1 foi dado pronto) CPU Arquivo : CPU.vhd Descri\u00e7\u00e3o : CPU do Z01 integra registradores, controlUnit, ULA e PC. Depend\u00eancias : ControlUnit.vhd : Unidade de controle a ser implementada ULA.vhd : Unidade l\u00f3gica desenvolvida no projeto D PC.vhd : Program counter do projeto E register16.vhd , mux16.vhd : Componentes do projeto C e D ControlUnit Arquivo : ControlUnit.vhd Descri\u00e7\u00e3o : Unidade de controle da CPU do Z01. Depend\u00eancias : n\u00e3o h\u00e1 Diagramas \u00b6 Rubrica do projeto \u00b6 Warning Os conceitos B e A devem ser feitos em um outro branch! git checkout -B CPU-Extras Conceito I Menos da metade dos m\u00f3dulos funcionando D Ao menos um m\u00f3dulo n\u00e3o est\u00e1 feito e n\u00e3o passa no testes. C Construiu com os m\u00f3dulos do grupo o seu pr\u00f3prio computador Todos os m\u00f3dulos sendo testados no Actions. Todos os m\u00f3dulos passam nos testes. B Adiciona um novo registrador a CPU ( %S ) Modifica os testes para testar esse novo recurso! A Possibilita realizar carregamento efetivo em %D ( leaw $5, %D ) Modifica os testes para testar esse novo recurso! Formul\u00e1rios \u00b6 Scrum Master Desenvolvedores","title":"Projeto"},{"location":"cpu-Projeto/#projeto","text":"Entrega 17/11 - Quinta Nesse projeto cada grupo ter\u00e1 que implementar sua pr\u00f3pria CPU do Z01.","title":"Projeto"},{"location":"cpu-Projeto/#comecando","text":"A seguir explica\u00e7\u00f5es de como come\u00e7ar o projeto.","title":"Come\u00e7ando"},{"location":"cpu-Projeto/#entendendo-a-organizacao-do-projeto","text":"A pasta do projeto F no reposit\u00f3rio Z01, possui a seguinte estrutura: F-Computador/ testeHW.py Z01SimuladorMyCPU.py src/ Quartus/ Z01-Simulator-RTL/ testeHW.py : Testa o controlUnit.vhd , memoryIO.vhd e todo o HW do computador ( CPU.vhd ) Z01SimuladorMyCPU.py : Abre o simulador gr\u00e1fico do Z01.1 com o HW do grupo Z01-Simulator-RTL : Pasta com o simulador do computador","title":"Entendendo a Organiza\u00e7\u00e3o do Projeto"},{"location":"cpu-Projeto/#testando-hw-controlunit-e-memoryio","text":"Abra o terminal na pasta F-Computador , deixe descomentado apenas as linhas referentes ao ControlUnit.vhd e ao MemoryIO.vhd no arquivo config_testes.txt e execute o script python: $ ./testeHW.py","title":"Testando HW (ControlUnit e MemoryIO)"},{"location":"cpu-Projeto/#testando-o-projeto-completo","text":"Para testar se o computador est\u00e1 correto, iremos executar alguns programas realizados na APS E-Assembly por\u00e9m agora no Harware que voc\u00eas montaram. Apenas execute esse teste ap\u00f3s a implementa\u00e7\u00e3o dos tr\u00eas m\u00f3dulos solicitados no projeto. Para isso, descomente a linha referente ao CPU.vhd no arquivo config_testes.txt execute. $ ./testeHW.py Todos os m\u00f3dulos vhdl (desde o projeto B) ser\u00e3o compilados e o CPU.vhd ser\u00e1 executado. Todos os programas em Assembly que estiverem descomentados no arquivo config_testes_nasm.txt na pasta E-Assembly ser\u00e3o verificados. Na sequ\u00eancia, iremos comparar se a resposta (mem\u00f3ria RAM) possui o resultado esperado. Como os programas s\u00e3o complexos, esperamos com isso conseguir testar a totalidade do projeto. Tip Temos uma p\u00e1gina inteira detalhando como debugamos esse teste: Testando CPU","title":"Testando o projeto completo"},{"location":"cpu-Projeto/#actions","text":"Adicione ao Actions o teste: testeHW.py Tip No Actions voc\u00ea tem que colocar o caminho completo: F-Computador/...","title":"Actions"},{"location":"cpu-Projeto/#projeto_1","text":"Deve-se implementar o Control Unit e integrar os m\u00f3dulos: MemoryIO e CPU . O HDL que descreve o Computador j\u00e1 foi fornecido pronto.","title":"Projeto"},{"location":"cpu-Projeto/#modulos","text":"Note Esses arquivos est\u00e3o localizados em F-Computador/src/ Os m\u00f3dulos est\u00e3o listados de maneira Top - Down Computador ( j\u00e1 est\u00e1 pronto! N\u00e3o precisa mexer , mas \u00e9 legal ver!) Arquivo : computador.vhd Descri\u00e7\u00e3o : TopLevel do projeto, entidade que integra a mem\u00f3ria ROM o MemoryIO, CPU e PLL Depend\u00eancias : Dispositivos/ROM/ROM32K.vhd : ROM a ser utilizada no projeto (j\u00e1 foi dado pronto) Dispositivos/PLL/PLL.vhd : PLL a ser utilizada no projeto (j\u00e1 foi dado pronto) MemoryIO Arquivo : MemoryIO.vhd Descri\u00e7\u00e3o : Faz o mapa de mem\u00f3ria para a CPU. Depend\u00eancias : Dispositivos/RAM/RAM16K.vhd : RAM a ser utilizada no projeto (j\u00e1 foi dado pronto) Dispositivos/Screen/Screen.vhd : Controlador do LCD a ser utilizada no projeto (j\u00e1 foi dado pronto) CPU Arquivo : CPU.vhd Descri\u00e7\u00e3o : CPU do Z01 integra registradores, controlUnit, ULA e PC. Depend\u00eancias : ControlUnit.vhd : Unidade de controle a ser implementada ULA.vhd : Unidade l\u00f3gica desenvolvida no projeto D PC.vhd : Program counter do projeto E register16.vhd , mux16.vhd : Componentes do projeto C e D ControlUnit Arquivo : ControlUnit.vhd Descri\u00e7\u00e3o : Unidade de controle da CPU do Z01. Depend\u00eancias : n\u00e3o h\u00e1","title":"M\u00f3dulos"},{"location":"cpu-Projeto/#diagramas","text":"","title":"Diagramas"},{"location":"cpu-Projeto/#rubrica-do-projeto","text":"Warning Os conceitos B e A devem ser feitos em um outro branch! git checkout -B CPU-Extras Conceito I Menos da metade dos m\u00f3dulos funcionando D Ao menos um m\u00f3dulo n\u00e3o est\u00e1 feito e n\u00e3o passa no testes. C Construiu com os m\u00f3dulos do grupo o seu pr\u00f3prio computador Todos os m\u00f3dulos sendo testados no Actions. Todos os m\u00f3dulos passam nos testes. B Adiciona um novo registrador a CPU ( %S ) Modifica os testes para testar esse novo recurso! A Possibilita realizar carregamento efetivo em %D ( leaw $5, %D ) Modifica os testes para testar esse novo recurso!","title":"Rubrica do projeto"},{"location":"cpu-Projeto/#formularios","text":"Scrum Master Desenvolvedores","title":"Formul\u00e1rios"},{"location":"cpu-Testando/","text":"Testando \u00b6 Para testar o projeto F-Computador \u00e9 necess\u00e1rio: Testar o controUnit e o memoryIo descomentando apenas as respectivas linhas no config_testes.txt : $ ./testeHW.py Somente ap\u00f3s passar os testes anteriores e com a CPU implementada: Testar o computador ( CPU , controlUnit e memoryIo ) com a execu\u00e7\u00e3o de c\u00f3digos em assembly: $ ./testeHW.py ap\u00f3s descomentar a linha referente ao CPU.vhd no config_testes.txt . Tip SE O TESTE TRAVAR: VERIFICAR DICAS AO FINAL DESSA P\u00c1GINA Se o teste do CPU travar \u00b6 Se por algum motivo o teste do CPU travar no primeiro teste, isso \u00e9 sin\u00f4nimo de que algo est\u00e1 errado com o seu HDL. Esse teste faz o seguinte para cada arquivo .nasm incluso no arquivo de configura\u00e7\u00e3o do Projeto E : Compila o .nasm gerando o bin\u00e1rio .mif Carrega na ROM do seu computador ( Projeto F ) o bin\u00e1rio Executa o c\u00f3digo Verifica se o resultado est\u00e1 certo Se por algum motivo algum m\u00f3dulo estiver com problema esse teste pode falhar, o que \u00e9 aconselhado fazer: Comente todos os teste do Projeto E no arquivo de configura\u00e7\u00e3o ( E-Assembly/tests/config_testes_nasm.txt ) com exce\u00e7\u00e3o o mov.nasm Esse m\u00f3dulo testa todos os registradores Execute o teste: ./testeHW.py e analise o waveform com o GTKWave An\u00e1lise as mensagens no terminal em busca de erros! Analise o que est\u00e1 acontecendo com o seu hardware, verifique a instru\u00e7\u00e3o que est\u00e1 entrando e o que deveria acontecer. Corrija o HW quando encontrar o problema, teste novamente. Descomente os m\u00f3dulos: abs.nasm e teste para saber se est\u00e1 :ok Esse m\u00f3dulo testa o loadPC e sa\u00eddas da ULA (ng e zr) Descomente os demais m\u00f3dulos e teste tudo.","title":"Testando"},{"location":"cpu-Testando/#testando","text":"Para testar o projeto F-Computador \u00e9 necess\u00e1rio: Testar o controUnit e o memoryIo descomentando apenas as respectivas linhas no config_testes.txt : $ ./testeHW.py Somente ap\u00f3s passar os testes anteriores e com a CPU implementada: Testar o computador ( CPU , controlUnit e memoryIo ) com a execu\u00e7\u00e3o de c\u00f3digos em assembly: $ ./testeHW.py ap\u00f3s descomentar a linha referente ao CPU.vhd no config_testes.txt . Tip SE O TESTE TRAVAR: VERIFICAR DICAS AO FINAL DESSA P\u00c1GINA","title":"Testando"},{"location":"cpu-Testando/#se-o-teste-do-cpu-travar","text":"Se por algum motivo o teste do CPU travar no primeiro teste, isso \u00e9 sin\u00f4nimo de que algo est\u00e1 errado com o seu HDL. Esse teste faz o seguinte para cada arquivo .nasm incluso no arquivo de configura\u00e7\u00e3o do Projeto E : Compila o .nasm gerando o bin\u00e1rio .mif Carrega na ROM do seu computador ( Projeto F ) o bin\u00e1rio Executa o c\u00f3digo Verifica se o resultado est\u00e1 certo Se por algum motivo algum m\u00f3dulo estiver com problema esse teste pode falhar, o que \u00e9 aconselhado fazer: Comente todos os teste do Projeto E no arquivo de configura\u00e7\u00e3o ( E-Assembly/tests/config_testes_nasm.txt ) com exce\u00e7\u00e3o o mov.nasm Esse m\u00f3dulo testa todos os registradores Execute o teste: ./testeHW.py e analise o waveform com o GTKWave An\u00e1lise as mensagens no terminal em busca de erros! Analise o que est\u00e1 acontecendo com o seu hardware, verifique a instru\u00e7\u00e3o que est\u00e1 entrando e o que deveria acontecer. Corrija o HW quando encontrar o problema, teste novamente. Descomente os m\u00f3dulos: abs.nasm e teste para saber se est\u00e1 :ok Esse m\u00f3dulo testa o loadPC e sa\u00eddas da ULA (ng e zr) Descomente os demais m\u00f3dulos e teste tudo.","title":"Se o teste do CPU travar"},{"location":"cpu-lab-1/","text":"Lab 15: Control Unit \u00b6 Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. A unidade de controle \u00e9 o perif\u00e9rico da CPU respons\u00e1vel por decodificar uma instru\u00e7\u00e3o (linguagem de m\u00e1quina) e realizar as modifica\u00e7\u00f5es necess\u00e1rias no HW (mux, load, ULA, registradores, PC) a fim de executar tal opera\u00e7\u00e3o. O control unit controla todos os componentes internos da nossa CPU, \u00e9 ele que por exemplo seleciona como vai estar os sinais do seletor dos mux ( muxALUI/I / muxAM/D , qual opera\u00e7\u00e3o a ULA ir\u00e1 executar ( zr.nx.zy.ny.f.no ), onde o dado ser\u00e1 salvo ( loadD , loadA , writeM , loadPC ) e se \u00e9 para executar uma opera\u00e7\u00e3o de salto ( loadPC ). A figura a baixo ilustra tudo que o control unit controla . Note Note que os sinais do comparador da ULA: zr e ng tamb\u00e9m v\u00e3o para a unidade de controle. \u00c9 a partir do valor deles que o hardware decide se vai ou n\u00e3o ocorrer uma opera\u00e7\u00e3o de salto. ControlUnit \u00b6 Vamos implementar partes da unidade de controle. loadD (exemplo) \u00b6 Exemplo! Tip Utilize o documento Z01/Instruction Set para resolver esse lab. O sinal loadD indica quando o registrador D deve armazenar um novo sinal. Para isso, devemos verificar se a instru\u00e7\u00e3o em quest\u00e3o que est\u00e1 sendo decodificada pelo 'controlUnit' \u00e9 do tipo comando (C), essa verifica\u00e7\u00e3o \u00e9 feita pelo bit mais significativo da instru\u00e7\u00e3o ( bit17 ). Uma vez que detectado uma instru\u00e7\u00e3o do tipo C, devemos verificar se o comando que ela representa carrega a opera\u00e7\u00e3o de salvar em %D , verificamos isso pelo bit d1 , que indica se ir\u00e1 ou n\u00e3o ocorrer um carregamento em %D . Com esses dados conseguimos criar a tabela verdade a seguir e extrair a equa\u00e7\u00e3o que rege esse sinal. bit 17 bit 4 loadD 0 X 0 1 0 0 1 1 1 Podendo ser traduzido para o c\u00f3digo em VHDL (via soma dos produtos): loadD <= instruction ( 17 ) and instruction ( 4 ); Nesse lab iremos fazer parte do ControlUnit, ele n\u00e3o deve passar em todos os testes. Implementando e testando Abra o arquivo /Projetos/F-Computador/src/controlUnit.vhd Insira a implementa\u00e7\u00e3o anterior do loadD na arquitetura Teste com o comando ./testeHW.py descomentando a respectiva linha em config_testes.txt Deve passar no TESTE 1 e TESTE 2 Deve parar para no TESTE 3 O resultado deve ser como a seguir: loadM \u00b6 Vamos agora implementar o sinal loadM , esse sinal \u00e9 o que controla se ir\u00e1 ocorrer uma opera\u00e7\u00e3o de escrita na mem\u00f3ria RAM. Implementando e testando Entenda os bits envolvidos Escreva uma tabela verdade Encontre a equa\u00e7\u00e3o e implemente no controlUnit.vhd Teste com o comando ./testeHW.py Deve passar no TESTE 3 e TESTE 4 Deve parar para no TESTE 4 loadA \u00b6 Agora implemente o loadA , esse sinal que controla o load do registrador A. Implementando e testando Entenda os bits envolvidos Escreva uma tabela verdade Encontre a equa\u00e7\u00e3o e implemente no controlUnit.vhd Teste com o comando ./testeHW.py Deve passar no TESTE 5 e TESTE 6 Deve parar para no TESTE 7 muxALUI_A \u00b6 Esse sinal ( muxALUI_A ) controla o mux que seleciona qual o sinal que entra no registrador %A , a entrada 0 do mux \u00e9 o sinal que sai da ULA e o sinal 1 do mux s\u00e3o os bits [15..0] da instru\u00e7\u00e3o. Tip Com esse sinal implementando, nossa CPU j\u00e1 suporta a instru\u00e7\u00e3o leaw $x, %A Implementando e testando Entenda os bits envolvidos Escreva uma tabela verdade Encontre a equa\u00e7\u00e3o e implemente no controlUnit.vhd Teste com o comando ./testeHW.py Deve passar no TESTE 7 e TESTE 8 Deve parar para no TESTE 9 zx \u00b6 Agora fa\u00e7a o sinal zx que controla o zerador do sinal x da ULA. Implementando e testando Entenda os bits envolvidos Escreva uma tabela verdade Encontre a equa\u00e7\u00e3o e implemente no controlUnit.vhd Teste com o comando ./testeHW.py Deve passar no TESTE 9 e TESTE 10 Deve parar para no TESTE 11 Memory IO \u00b6 O componente memory IO \u00e9 a 'mem\u00f3ria' do nosso computador. Interno nesse m\u00f3dulo possu\u00edmos al\u00e9m da mem\u00f3ria RAM, outros componentes tais como: tela, chave, leds. Lembrando que para a CPU, n\u00e3o existe separa\u00e7\u00e3o entre o que \u00e9 mem\u00f3ria e o que \u00e9 perif\u00e9rico. Os perif\u00e9ricos internos do memoryIO s\u00e3o: Tela ( screen.vhd ) respons\u00e1vel por controlar o LCD RAM ( ram16k.vhd ) mem\u00f3ria RAM de 16k endere\u00e7os SW chaves da FPGA LED LEDs da FPGA screen e ram16k possuem a interface detalhada a seguir: Note Os sinais do tipo LCD_ da screen s\u00e3o conectados diretamente ao LCD, via portmap . O componente memoryIO possui a seguinte entidade: Estudando! \u00b6 Warning Discuta, pense e escreva a solu\u00e7\u00e3o antes de ver a resposta. Pense e discuta com seus colegas o memoryIO . Dos sinais de entrada do memoryIO qual define qual perif\u00e9rico (RAM/LCD/SW/LED) ser\u00e1 acessado pela CPU? Explique. Resposta O sinal em quest\u00e3o \u00e9 o address , pois os perif\u00e9ricos s\u00e3o mapeados em endere\u00e7os diferentes, e \u00e9 esse sinal que define qual perif\u00e9rico a CPU est\u00e1 querendo acessar. Exemplo: se o sinal address = 1024 , a CPU est\u00e1 realizando uma opera\u00e7\u00e3o na mem\u00f3ria RAM, mas se o sinal address = 21184 isso indica que a CPU est\u00e1 querendo acessar o LED . Para mais informa\u00e7\u00f5es, leia Teoria/Z01 - Mapa de Mem\u00f3ria . Qual sinal informa o memoryIO que a CPU est\u00e1 realizando uma escrita? Resposta \u00c9 o writeM , se 1 indica que a CPU quer realizar uma escrita, caso contr\u00e1rio \u00e9 uma leitura. Quais s\u00e3o suas entradas e sa\u00eddas do LCD que o memoryIO controla? (tudo tirando o que come\u00e7a com LCD_ ) Resposta DISPLAY : Screen port map ( RST => RST , CLK_FAST => CLK_FAST , CLK_SLOW => CLK_SLOW , INPUT => INPUT , LOAD => LOAD_DISPLAY , ADDRESS => ADDRESS ( 13 downto 0 ), LCD_INIT_OK => LCD_INIT_OK , LCD_CS_N => LCD_CS_N , LCD_D => LCD_D , LCD_RD_N => LCD_RD_N , LCD_RESET_N => LCD_RESET_N , LCD_RS => LCD_RS , LCD_WR_N => LCD_WR_N ); input : s\u00e3o os px a serem escritos load : se \u00e9 para atualizar os px adddress : quais px ser\u00e3o escritos Note que esses sinais s\u00e3o os mesmos sinais de uma mem\u00f3ria RAM, por\u00e9m sem a parte de leitura. O LCD como foi implementando, n\u00e3o suporta que realizemos a leitura de seus pxs. Como funciona o LED? Resposta O LED \u00e9 um endere\u00e7o da mem\u00f3ria, como ele 'armazena' o dado, deve ser implementando com um registrador. Fa\u00e7a um esbo\u00e7o (diagrama) de como o memoryIO implementar\u00e1 a sa\u00edda LED | | LOAD ---> | ADDRESS -> | INPUT ---> | | ---> LED | | | | | | | | Pinos do memoryIO : LOAD: indica escrita ADDRESS(16 downto 0): endere\u00e7o da escrita INPUT(16 downto 0): dado a ser escrito LED(9 downto 0): Valor dos LEDs da FPGA CPU \u00b6 Proponha uma modifica\u00e7\u00e3o na CPU do nosso Z01.1 que: Adiciona mais um registrador ( %S ) (onde \u00e9 melhor?) Voc\u00ea teria que modificar a linguagem de m\u00e1quina do nosso HW. Proponha uma solu\u00e7\u00e3o. Possibilita %D endere\u00e7ar a mem\u00f3ria movw %A, (%D) Possibilite fazer carregamento efetivo em %D leaw $5, %D Para cada modifica\u00e7\u00e3o fa\u00e7a o desenho da nova CPU. Extras \u00b6 nop \u00b6 Como o controlUnit controla a CPU para realizar a opera\u00e7\u00e3o de NOP? movw %D, %A e jg %D ao mesmo tempo \u00b6 Nossa CPU suportaria executar simultaneamente a instru\u00e7\u00e3o movw %D, %A e ao mesmo tempo a instru\u00e7\u00e3o jg %D ? loadPC \u00b6 Quais sinais o influenciam?","title":"Lab 15: Control Unit"},{"location":"cpu-lab-1/#lab-15-control-unit","text":"Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. A unidade de controle \u00e9 o perif\u00e9rico da CPU respons\u00e1vel por decodificar uma instru\u00e7\u00e3o (linguagem de m\u00e1quina) e realizar as modifica\u00e7\u00f5es necess\u00e1rias no HW (mux, load, ULA, registradores, PC) a fim de executar tal opera\u00e7\u00e3o. O control unit controla todos os componentes internos da nossa CPU, \u00e9 ele que por exemplo seleciona como vai estar os sinais do seletor dos mux ( muxALUI/I / muxAM/D , qual opera\u00e7\u00e3o a ULA ir\u00e1 executar ( zr.nx.zy.ny.f.no ), onde o dado ser\u00e1 salvo ( loadD , loadA , writeM , loadPC ) e se \u00e9 para executar uma opera\u00e7\u00e3o de salto ( loadPC ). A figura a baixo ilustra tudo que o control unit controla . Note Note que os sinais do comparador da ULA: zr e ng tamb\u00e9m v\u00e3o para a unidade de controle. \u00c9 a partir do valor deles que o hardware decide se vai ou n\u00e3o ocorrer uma opera\u00e7\u00e3o de salto.","title":"Lab 15: Control Unit"},{"location":"cpu-lab-1/#controlunit","text":"Vamos implementar partes da unidade de controle.","title":"ControlUnit"},{"location":"cpu-lab-1/#loadd-exemplo","text":"Exemplo! Tip Utilize o documento Z01/Instruction Set para resolver esse lab. O sinal loadD indica quando o registrador D deve armazenar um novo sinal. Para isso, devemos verificar se a instru\u00e7\u00e3o em quest\u00e3o que est\u00e1 sendo decodificada pelo 'controlUnit' \u00e9 do tipo comando (C), essa verifica\u00e7\u00e3o \u00e9 feita pelo bit mais significativo da instru\u00e7\u00e3o ( bit17 ). Uma vez que detectado uma instru\u00e7\u00e3o do tipo C, devemos verificar se o comando que ela representa carrega a opera\u00e7\u00e3o de salvar em %D , verificamos isso pelo bit d1 , que indica se ir\u00e1 ou n\u00e3o ocorrer um carregamento em %D . Com esses dados conseguimos criar a tabela verdade a seguir e extrair a equa\u00e7\u00e3o que rege esse sinal. bit 17 bit 4 loadD 0 X 0 1 0 0 1 1 1 Podendo ser traduzido para o c\u00f3digo em VHDL (via soma dos produtos): loadD <= instruction ( 17 ) and instruction ( 4 ); Nesse lab iremos fazer parte do ControlUnit, ele n\u00e3o deve passar em todos os testes. Implementando e testando Abra o arquivo /Projetos/F-Computador/src/controlUnit.vhd Insira a implementa\u00e7\u00e3o anterior do loadD na arquitetura Teste com o comando ./testeHW.py descomentando a respectiva linha em config_testes.txt Deve passar no TESTE 1 e TESTE 2 Deve parar para no TESTE 3 O resultado deve ser como a seguir:","title":"loadD (exemplo)"},{"location":"cpu-lab-1/#loadm","text":"Vamos agora implementar o sinal loadM , esse sinal \u00e9 o que controla se ir\u00e1 ocorrer uma opera\u00e7\u00e3o de escrita na mem\u00f3ria RAM. Implementando e testando Entenda os bits envolvidos Escreva uma tabela verdade Encontre a equa\u00e7\u00e3o e implemente no controlUnit.vhd Teste com o comando ./testeHW.py Deve passar no TESTE 3 e TESTE 4 Deve parar para no TESTE 4","title":"loadM"},{"location":"cpu-lab-1/#loada","text":"Agora implemente o loadA , esse sinal que controla o load do registrador A. Implementando e testando Entenda os bits envolvidos Escreva uma tabela verdade Encontre a equa\u00e7\u00e3o e implemente no controlUnit.vhd Teste com o comando ./testeHW.py Deve passar no TESTE 5 e TESTE 6 Deve parar para no TESTE 7","title":"loadA"},{"location":"cpu-lab-1/#muxalui_a","text":"Esse sinal ( muxALUI_A ) controla o mux que seleciona qual o sinal que entra no registrador %A , a entrada 0 do mux \u00e9 o sinal que sai da ULA e o sinal 1 do mux s\u00e3o os bits [15..0] da instru\u00e7\u00e3o. Tip Com esse sinal implementando, nossa CPU j\u00e1 suporta a instru\u00e7\u00e3o leaw $x, %A Implementando e testando Entenda os bits envolvidos Escreva uma tabela verdade Encontre a equa\u00e7\u00e3o e implemente no controlUnit.vhd Teste com o comando ./testeHW.py Deve passar no TESTE 7 e TESTE 8 Deve parar para no TESTE 9","title":"muxALUI_A"},{"location":"cpu-lab-1/#zx","text":"Agora fa\u00e7a o sinal zx que controla o zerador do sinal x da ULA. Implementando e testando Entenda os bits envolvidos Escreva uma tabela verdade Encontre a equa\u00e7\u00e3o e implemente no controlUnit.vhd Teste com o comando ./testeHW.py Deve passar no TESTE 9 e TESTE 10 Deve parar para no TESTE 11","title":"zx"},{"location":"cpu-lab-1/#memory-io","text":"O componente memory IO \u00e9 a 'mem\u00f3ria' do nosso computador. Interno nesse m\u00f3dulo possu\u00edmos al\u00e9m da mem\u00f3ria RAM, outros componentes tais como: tela, chave, leds. Lembrando que para a CPU, n\u00e3o existe separa\u00e7\u00e3o entre o que \u00e9 mem\u00f3ria e o que \u00e9 perif\u00e9rico. Os perif\u00e9ricos internos do memoryIO s\u00e3o: Tela ( screen.vhd ) respons\u00e1vel por controlar o LCD RAM ( ram16k.vhd ) mem\u00f3ria RAM de 16k endere\u00e7os SW chaves da FPGA LED LEDs da FPGA screen e ram16k possuem a interface detalhada a seguir: Note Os sinais do tipo LCD_ da screen s\u00e3o conectados diretamente ao LCD, via portmap . O componente memoryIO possui a seguinte entidade:","title":"Memory IO"},{"location":"cpu-lab-1/#estudando","text":"Warning Discuta, pense e escreva a solu\u00e7\u00e3o antes de ver a resposta. Pense e discuta com seus colegas o memoryIO . Dos sinais de entrada do memoryIO qual define qual perif\u00e9rico (RAM/LCD/SW/LED) ser\u00e1 acessado pela CPU? Explique. Resposta O sinal em quest\u00e3o \u00e9 o address , pois os perif\u00e9ricos s\u00e3o mapeados em endere\u00e7os diferentes, e \u00e9 esse sinal que define qual perif\u00e9rico a CPU est\u00e1 querendo acessar. Exemplo: se o sinal address = 1024 , a CPU est\u00e1 realizando uma opera\u00e7\u00e3o na mem\u00f3ria RAM, mas se o sinal address = 21184 isso indica que a CPU est\u00e1 querendo acessar o LED . Para mais informa\u00e7\u00f5es, leia Teoria/Z01 - Mapa de Mem\u00f3ria . Qual sinal informa o memoryIO que a CPU est\u00e1 realizando uma escrita? Resposta \u00c9 o writeM , se 1 indica que a CPU quer realizar uma escrita, caso contr\u00e1rio \u00e9 uma leitura. Quais s\u00e3o suas entradas e sa\u00eddas do LCD que o memoryIO controla? (tudo tirando o que come\u00e7a com LCD_ ) Resposta DISPLAY : Screen port map ( RST => RST , CLK_FAST => CLK_FAST , CLK_SLOW => CLK_SLOW , INPUT => INPUT , LOAD => LOAD_DISPLAY , ADDRESS => ADDRESS ( 13 downto 0 ), LCD_INIT_OK => LCD_INIT_OK , LCD_CS_N => LCD_CS_N , LCD_D => LCD_D , LCD_RD_N => LCD_RD_N , LCD_RESET_N => LCD_RESET_N , LCD_RS => LCD_RS , LCD_WR_N => LCD_WR_N ); input : s\u00e3o os px a serem escritos load : se \u00e9 para atualizar os px adddress : quais px ser\u00e3o escritos Note que esses sinais s\u00e3o os mesmos sinais de uma mem\u00f3ria RAM, por\u00e9m sem a parte de leitura. O LCD como foi implementando, n\u00e3o suporta que realizemos a leitura de seus pxs. Como funciona o LED? Resposta O LED \u00e9 um endere\u00e7o da mem\u00f3ria, como ele 'armazena' o dado, deve ser implementando com um registrador. Fa\u00e7a um esbo\u00e7o (diagrama) de como o memoryIO implementar\u00e1 a sa\u00edda LED | | LOAD ---> | ADDRESS -> | INPUT ---> | | ---> LED | | | | | | | | Pinos do memoryIO : LOAD: indica escrita ADDRESS(16 downto 0): endere\u00e7o da escrita INPUT(16 downto 0): dado a ser escrito LED(9 downto 0): Valor dos LEDs da FPGA","title":"Estudando!"},{"location":"cpu-lab-1/#cpu","text":"Proponha uma modifica\u00e7\u00e3o na CPU do nosso Z01.1 que: Adiciona mais um registrador ( %S ) (onde \u00e9 melhor?) Voc\u00ea teria que modificar a linguagem de m\u00e1quina do nosso HW. Proponha uma solu\u00e7\u00e3o. Possibilita %D endere\u00e7ar a mem\u00f3ria movw %A, (%D) Possibilite fazer carregamento efetivo em %D leaw $5, %D Para cada modifica\u00e7\u00e3o fa\u00e7a o desenho da nova CPU.","title":"CPU"},{"location":"cpu-lab-1/#extras","text":"","title":"Extras"},{"location":"cpu-lab-1/#nop","text":"Como o controlUnit controla a CPU para realizar a opera\u00e7\u00e3o de NOP?","title":"nop"},{"location":"cpu-lab-1/#movw-d-a-e-jg-d-ao-mesmo-tempo","text":"Nossa CPU suportaria executar simultaneamente a instru\u00e7\u00e3o movw %D, %A e ao mesmo tempo a instru\u00e7\u00e3o jg %D ?","title":"movw %D, %A e jg %D ao mesmo tempo"},{"location":"cpu-lab-1/#loadpc","text":"Quais sinais o influenciam?","title":"loadPC"},{"location":"cpu-lab-2/","text":"Control Unit \u00b6 Considerando a unidade de controle descrita a seguir (entradas e sa\u00eddas), vamos projetar uma l\u00f3gica (em VHDL) para resolver algumas sa\u00eddas da entidade, o resto ser\u00e1 feito no projeto. (exemplo) loadS \u00b6 O sinal loadS indica quando o registrador S deve armazenar um novo sinal. Para isso, devemos verificar se a instru\u00e7\u00e3o em quest\u00e3o que ser\u00e1 decodificada pelo 'controlUnit' \u00e9 do tipo comando (C), essa verifica\u00e7\u00e3o \u00e9 feita pelo bit mais significativo da instru\u00e7\u00e3o (bit17) Uma vez que detectado uma instru\u00e7\u00e3o do tipo C, devemos verificar se o comando que ela representa carrega a opera\u00e7\u00e3o de salvar em %S (bit 5/ d2). Com esses dados conseguimos criar a tabela verdade a seguir e extrair as equa\u00e7\u00f5es. bit 17 bit 5 loadS 0 X 0 1 0 0 1 1 1 Podendo ser traduzido para o c\u00f3digo em VHDL: loadS <= INSTRUCAO(17) and INSTRUCAO(5); \\newpage loadM \u00b6 loadM <= loadA \u00b6 loadA <= zx \u00b6 zx <= muxA/M \u00b6 muxAM <= Valide as respostas com algum professor/ colega. \\newpage Memory IO \u00b6 O componente memory IO \u00e9 a 'mem\u00f3ria' do nosso computador. Interno nesse m\u00f3dulo possu\u00edmos al\u00e9m da mem\u00f3ria RAM, outros componentes tais como: tela, chave, leds. Lembrando que para a CPU, n\u00e3o existe separa\u00e7\u00e3o entre o que \u00e9 mem\u00f3ria e o que \u00e9 hardware externo. Os perif\u00e9ricos internos do memoryIO s\u00e3o: Tela ( screen.vhd ) respons\u00e1vel por controlar o LCD RAM ( ram16k.vhd ) mem\u00f3ria RAM de 16k endere\u00e7os SW chaves da FPGA LED LEDs da FPGA screen e ram16k possuem a interface detalhada a seguir: os sinais do tipo LCD_ da screen s\u00e3o conectados diretamente ao LCD, via portmap. O componente memoryIO possui a seguinte entidade: \\newpage Estudando! \u00b6 Pense e discuta com seus colegas o memoryIO . Dos sinais de entrada do memoryIO qual define qual perif\u00e9rico ser\u00e1 'escrito/lido' pela CPU? Explique. Qual sinal informa o memoryIO que a CPU est\u00e1 realizando uma escrita? Como funciona o LCD? Quais s\u00e3o suas entradas e sa\u00eddas (tirando tudo que come\u00e7a com LCD_ ) Como funciona o LED? Fa\u00e7a um esbo\u00e7o (diagrama) de como o memoryIO implementar\u00e1 a sa\u00edda LED | | LOAD ---> | ADDRESS -> | INPUT ---> | | ---> LED | | | | | | | | Pinos do memoryIO : LOAD: indica escrita ADDRESS(16 downto 0): endere\u00e7o da escrita INPUT(16 downto 0): dado a ser escrito LED(9 downto 0): Valor dos LEDs da FPGA \\newpage CPU \u00b6 Proponha uma modifica\u00e7\u00e3o na CPU do nosso Z01.1 que: Adiciona mais um registrador (onde \u00e9 melhor?) Possibilita %S endere\u00e7ar a mem\u00f3ria movw %D, (%S) Possibilite fazer carregamento efetivo em %D leaw $5, %D Fa\u00e7a o desenho da nova CPU. \\newpage Extras \u00b6 nop \u00b6 movw %S, %D e jg %S \u00b6 Nossa CPU suportaria executar um movw %S, %D e ao mesmo tempo a instru\u00e7\u00e3o jg %D ? loadPC \u00b6 loadPC <= Dissasembly \u00b6 Voc\u00ea teve acesso a um bin\u00e1rio de um programa para o Z01.1: 000000000000000101 100101100000010000 000000000000000001 100000000000100000 000000000000001011 100010011000000001 100001010100000000 100001111110100000 000000000000001100 100000011000000111 100001010100000000 100001010100100000 000000000000000000 100010011000001000 Fa\u00e7a o dissasembly (recuperar a instru\u00e7\u00f5es originais) O que o c\u00f3digo faz?","title":"Control Unit"},{"location":"cpu-lab-2/#control-unit","text":"Considerando a unidade de controle descrita a seguir (entradas e sa\u00eddas), vamos projetar uma l\u00f3gica (em VHDL) para resolver algumas sa\u00eddas da entidade, o resto ser\u00e1 feito no projeto.","title":"Control Unit"},{"location":"cpu-lab-2/#exemplo-loads","text":"O sinal loadS indica quando o registrador S deve armazenar um novo sinal. Para isso, devemos verificar se a instru\u00e7\u00e3o em quest\u00e3o que ser\u00e1 decodificada pelo 'controlUnit' \u00e9 do tipo comando (C), essa verifica\u00e7\u00e3o \u00e9 feita pelo bit mais significativo da instru\u00e7\u00e3o (bit17) Uma vez que detectado uma instru\u00e7\u00e3o do tipo C, devemos verificar se o comando que ela representa carrega a opera\u00e7\u00e3o de salvar em %S (bit 5/ d2). Com esses dados conseguimos criar a tabela verdade a seguir e extrair as equa\u00e7\u00f5es. bit 17 bit 5 loadS 0 X 0 1 0 0 1 1 1 Podendo ser traduzido para o c\u00f3digo em VHDL: loadS <= INSTRUCAO(17) and INSTRUCAO(5); \\newpage","title":"(exemplo) loadS"},{"location":"cpu-lab-2/#loadm","text":"loadM <=","title":"loadM"},{"location":"cpu-lab-2/#loada","text":"loadA <=","title":"loadA"},{"location":"cpu-lab-2/#zx","text":"zx <=","title":"zx"},{"location":"cpu-lab-2/#muxam","text":"muxAM <= Valide as respostas com algum professor/ colega. \\newpage","title":"muxA/M"},{"location":"cpu-lab-2/#memory-io","text":"O componente memory IO \u00e9 a 'mem\u00f3ria' do nosso computador. Interno nesse m\u00f3dulo possu\u00edmos al\u00e9m da mem\u00f3ria RAM, outros componentes tais como: tela, chave, leds. Lembrando que para a CPU, n\u00e3o existe separa\u00e7\u00e3o entre o que \u00e9 mem\u00f3ria e o que \u00e9 hardware externo. Os perif\u00e9ricos internos do memoryIO s\u00e3o: Tela ( screen.vhd ) respons\u00e1vel por controlar o LCD RAM ( ram16k.vhd ) mem\u00f3ria RAM de 16k endere\u00e7os SW chaves da FPGA LED LEDs da FPGA screen e ram16k possuem a interface detalhada a seguir: os sinais do tipo LCD_ da screen s\u00e3o conectados diretamente ao LCD, via portmap. O componente memoryIO possui a seguinte entidade: \\newpage","title":"Memory IO"},{"location":"cpu-lab-2/#estudando","text":"Pense e discuta com seus colegas o memoryIO . Dos sinais de entrada do memoryIO qual define qual perif\u00e9rico ser\u00e1 'escrito/lido' pela CPU? Explique. Qual sinal informa o memoryIO que a CPU est\u00e1 realizando uma escrita? Como funciona o LCD? Quais s\u00e3o suas entradas e sa\u00eddas (tirando tudo que come\u00e7a com LCD_ ) Como funciona o LED? Fa\u00e7a um esbo\u00e7o (diagrama) de como o memoryIO implementar\u00e1 a sa\u00edda LED | | LOAD ---> | ADDRESS -> | INPUT ---> | | ---> LED | | | | | | | | Pinos do memoryIO : LOAD: indica escrita ADDRESS(16 downto 0): endere\u00e7o da escrita INPUT(16 downto 0): dado a ser escrito LED(9 downto 0): Valor dos LEDs da FPGA \\newpage","title":"Estudando!"},{"location":"cpu-lab-2/#cpu","text":"Proponha uma modifica\u00e7\u00e3o na CPU do nosso Z01.1 que: Adiciona mais um registrador (onde \u00e9 melhor?) Possibilita %S endere\u00e7ar a mem\u00f3ria movw %D, (%S) Possibilite fazer carregamento efetivo em %D leaw $5, %D Fa\u00e7a o desenho da nova CPU. \\newpage","title":"CPU"},{"location":"cpu-lab-2/#extras","text":"","title":"Extras"},{"location":"cpu-lab-2/#nop","text":"","title":"nop"},{"location":"cpu-lab-2/#movw-s-d-e-jg-s","text":"Nossa CPU suportaria executar um movw %S, %D e ao mesmo tempo a instru\u00e7\u00e3o jg %D ?","title":"movw %S, %D e jg %S"},{"location":"cpu-lab-2/#loadpc","text":"loadPC <=","title":"loadPC"},{"location":"cpu-lab-2/#dissasembly","text":"Voc\u00ea teve acesso a um bin\u00e1rio de um programa para o Z01.1: 000000000000000101 100101100000010000 000000000000000001 100000000000100000 000000000000001011 100010011000000001 100001010100000000 100001111110100000 000000000000001100 100000011000000111 100001010100000000 100001010100100000 000000000000000000 100010011000001000 Fa\u00e7a o dissasembly (recuperar a instru\u00e7\u00f5es originais) O que o c\u00f3digo faz?","title":"Dissasembly"},{"location":"seq-Lab-1/","text":"Lab 9: L\u00f3gica Sequencial \u00b6 Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. Nesse lab iremos implementar um flip-flop do tipo D e um binary digit. Estudo pr\u00e9vio necess\u00e1rio para realizar esse lab: Leitura L\u00f3gica Sequencial VHDL/Sequencial Implementando um FF tipo D \u00b6 Note Fazer individual Discutir no grupo! Execute Fa\u00e7a uma branch Implemente local no seu PC S\u00f3 um integrante do grupo deve enviar para a main via PR ao final Tip Esse j\u00e1 \u00e9 um dos m\u00f3dulos da entrega do projeto! Warning Antes de seguir voc\u00ea deve fazer uma leitura r\u00e1pida do material de l\u00f3gica sequencial em VHDL VHDL -> Sequencial Vamos agora implementar um FF tipo D em VHDL, para isso iremos modificar o arquivo D-LogicaSequencial/src/FlipFlopD.vhd que declara a entidade de um Flip Flop do tipo D. Reset e Preset \u00b6 Warning Antes de continuar, voc\u00ea deve ter feito a leitura pr\u00e9via sobre L\u00f3gica Sequencial em VHDL, s\u00f3 continue ap\u00f3s ter realizado a leitura: No site da disciplina: VHDL Sequencial Flip Flops possuem normalmente dois outros sinais de controle: Clear e Preset , usados respectivamente para for\u00e7ar '0' ou '1' em sua sa\u00edda. Vamos modificar o c\u00f3digo anterior para suportar essas duas outras funcionalidades. Nesse caso possu\u00edmos duas op\u00e7\u00f5es: Set/Clear : s\u00edncrono Set/Clear : ass\u00edncrono O modo s\u00edncrono seria que o set e o clear s\u00f3 podem ser executado na subida do clock e no ass\u00edncrono em qualquer momento que o sinal se set e clear forem alterados o FF ir\u00e1 responder imediatamente. Nesse caso, iremos implementar o FF com set e reset ass\u00edncrono, para isso utilize a seguinte estrutura a seguir que j\u00e1 implementa o sinal de clear Iremos modificar o c\u00f3digo localizado em D-LogicaSequencial/src/FlipFlopD.vhd que possui a implementa\u00e7\u00e3o parcial de um FF tipo D, mas n\u00e3o tem o preset process ( clock , clear ) begin if ( clear = '1' ) then Q <= '0' ; elsif ( rising_edge ( clock )) then Q <= D ; end if ; end process ; Tarefa: FF completo D-LogicaSequencial/src/FlipFlopD.vhd Implemente o preset (o clear j\u00e1 est\u00e1 feito) Agora voc\u00ea pode executar o script de teste do projeto e verificar se a implementa\u00e7\u00e3o est\u00e1 correta. Tarefa: waveform execute ./testeLogicaSequencial.py analise a forma de onda do teste do FF no GTKWave Tip Discuta no grupo a forma de onda Chame um professor para conversar sobre o entendimento de voc\u00eas Tarefa: RTL Gere o RTL (via quartus) analise o resultado do FF. Salve a forma de onda na pasta src/ do projeto com o nome FlipFlop.png . Agora somente um integrante do grupo deve fazer o envio para a master via PR. Checkpoint \u00b6 Ao final dessa etapa voc\u00ea deve ser capaz de: Saber o que \u00e9 um process em VHDL e o impacto da lista de sensibilidade Saber o que \u00e9 um FlipFlop tipo D Explicar a forma de onda do FlipFlopD gerada no GTKWave Explicar o RTL do FlipFlopD criado pelo Quartus Implementando o binary-digit \u00b6 Com o FFD implementando, voc\u00eas s\u00e3o capazes de implementar o binary-digit, que possui internamente um FF tipo D: Para isso voc\u00eas ter\u00e3o que modificar o arquivo: D-LogicaSequencial/src/BinaryDigit.vhd e utilizando port map criar o componente binaryDigit . Tarefa Implemente o binary-digit Teste Warning Assim como no FFD cada um do grupo vai ter uma implementa\u00e7\u00e3o do binary-digit e s\u00f3 um deve enviar o PR para a main .","title":"Lab 9: L\u00f3gica Sequencial"},{"location":"seq-Lab-1/#lab-9-logica-sequencial","text":"Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. Nesse lab iremos implementar um flip-flop do tipo D e um binary digit. Estudo pr\u00e9vio necess\u00e1rio para realizar esse lab: Leitura L\u00f3gica Sequencial VHDL/Sequencial","title":"Lab 9: L\u00f3gica Sequencial"},{"location":"seq-Lab-1/#implementando-um-ff-tipo-d","text":"Note Fazer individual Discutir no grupo! Execute Fa\u00e7a uma branch Implemente local no seu PC S\u00f3 um integrante do grupo deve enviar para a main via PR ao final Tip Esse j\u00e1 \u00e9 um dos m\u00f3dulos da entrega do projeto! Warning Antes de seguir voc\u00ea deve fazer uma leitura r\u00e1pida do material de l\u00f3gica sequencial em VHDL VHDL -> Sequencial Vamos agora implementar um FF tipo D em VHDL, para isso iremos modificar o arquivo D-LogicaSequencial/src/FlipFlopD.vhd que declara a entidade de um Flip Flop do tipo D.","title":"Implementando um FF tipo D"},{"location":"seq-Lab-1/#reset-e-preset","text":"Warning Antes de continuar, voc\u00ea deve ter feito a leitura pr\u00e9via sobre L\u00f3gica Sequencial em VHDL, s\u00f3 continue ap\u00f3s ter realizado a leitura: No site da disciplina: VHDL Sequencial Flip Flops possuem normalmente dois outros sinais de controle: Clear e Preset , usados respectivamente para for\u00e7ar '0' ou '1' em sua sa\u00edda. Vamos modificar o c\u00f3digo anterior para suportar essas duas outras funcionalidades. Nesse caso possu\u00edmos duas op\u00e7\u00f5es: Set/Clear : s\u00edncrono Set/Clear : ass\u00edncrono O modo s\u00edncrono seria que o set e o clear s\u00f3 podem ser executado na subida do clock e no ass\u00edncrono em qualquer momento que o sinal se set e clear forem alterados o FF ir\u00e1 responder imediatamente. Nesse caso, iremos implementar o FF com set e reset ass\u00edncrono, para isso utilize a seguinte estrutura a seguir que j\u00e1 implementa o sinal de clear Iremos modificar o c\u00f3digo localizado em D-LogicaSequencial/src/FlipFlopD.vhd que possui a implementa\u00e7\u00e3o parcial de um FF tipo D, mas n\u00e3o tem o preset process ( clock , clear ) begin if ( clear = '1' ) then Q <= '0' ; elsif ( rising_edge ( clock )) then Q <= D ; end if ; end process ; Tarefa: FF completo D-LogicaSequencial/src/FlipFlopD.vhd Implemente o preset (o clear j\u00e1 est\u00e1 feito) Agora voc\u00ea pode executar o script de teste do projeto e verificar se a implementa\u00e7\u00e3o est\u00e1 correta. Tarefa: waveform execute ./testeLogicaSequencial.py analise a forma de onda do teste do FF no GTKWave Tip Discuta no grupo a forma de onda Chame um professor para conversar sobre o entendimento de voc\u00eas Tarefa: RTL Gere o RTL (via quartus) analise o resultado do FF. Salve a forma de onda na pasta src/ do projeto com o nome FlipFlop.png . Agora somente um integrante do grupo deve fazer o envio para a master via PR.","title":"Reset e Preset"},{"location":"seq-Lab-1/#checkpoint","text":"Ao final dessa etapa voc\u00ea deve ser capaz de: Saber o que \u00e9 um process em VHDL e o impacto da lista de sensibilidade Saber o que \u00e9 um FlipFlop tipo D Explicar a forma de onda do FlipFlopD gerada no GTKWave Explicar o RTL do FlipFlopD criado pelo Quartus","title":"Checkpoint"},{"location":"seq-Lab-1/#implementando-o-binary-digit","text":"Com o FFD implementando, voc\u00eas s\u00e3o capazes de implementar o binary-digit, que possui internamente um FF tipo D: Para isso voc\u00eas ter\u00e3o que modificar o arquivo: D-LogicaSequencial/src/BinaryDigit.vhd e utilizando port map criar o componente binaryDigit . Tarefa Implemente o binary-digit Teste Warning Assim como no FFD cada um do grupo vai ter uma implementa\u00e7\u00e3o do binary-digit e s\u00f3 um deve enviar o PR para a main .","title":"Implementando o binary-digit"},{"location":"seq-Projeto/","text":"D - L\u00f3gica Sequencial \u00b6 Entrega 21/10 - Sexta Neste projeto voc\u00ea ter\u00e1 que desenvolver os componentes de mem\u00f3ria que ser\u00e3o utilizados no computador Z01. Instru\u00e7\u00f5es \u00b6 A pasta do projeto D-LogicaSequencial no reposit\u00f3rio Z01, possui a seguinte estrutura: /D-LogicaSequencial testeLogicaSequencial.py config_testes.txt /Quartus /src *.vhd /teste_cocotb tests.py Quartus: Projeto Quartus que faz uso dos arquivos VHDL localizados em src/*.vhd ; scripts: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/*.vhd : Arquivos VHDL que ser\u00e3o implementados pelo grupo; teste_cocotb/tests.py : Arquivo que possui os testes l\u00f3gicos dos arquivos do rtl. Executando o Script de Teste \u00b6 Abra o terminal na pasta D-LogicaSequencial e execute o script python localizado nessa pasta: $ python testeLogicaSequencial.py O mesmo ir\u00e1 compilar os arquivos .vhd e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Note Lembre que o arquivo config_testes.txt define quais testes ser\u00e3o executados. Projeto \u00b6 Deve-se gerar uma imagem com a forma de onda desses m\u00f3dulos. Deve-se gerar um RTL para cada m\u00f3dulo do projeto (Lab 4) Note que \u00e9 poss\u00edvel reaproveitar, via port map , os m\u00f3dulos dos projetos anteriores. Para isso basta usar port map. M\u00f3dulos \u00b6 Os modulos a serem desenvolvidos na entrega est\u00e3o detalhados no livro base do curso: Cap\u00edtulo 3 - The Elements of Computing Systems Flip Flop Arquivo : FlipFlopD.vhd Depend\u00eancia : \u00c9 \u00e9 um bloco elementar e sua implementa\u00e7\u00e3o \u00e9 criada no laborat\u00f3rio do projeto . Binary Digit Arquivo : BinaryDigit.vhd Depend\u00eancia : FlipFlopD e Mux2Way Descri\u00e7\u00e3o : \u00c9 um registrador feito para armazenar um \u00fanico bit de informa\u00e7\u00e3o (0 ou 1). A interface do m\u00f3dulo consiste em uma entrada (d) para o bit a ser armazenado, um sinal de load para indicar quando o bit de entrada deve ser armazenado um sinal de clock e a sa\u00edda output* que \u00e9 o bit armazenado: Register 8 Arquivo : Register8.vhd Depend\u00eancia : BinaryDigit Descri\u00e7\u00e3o : \u00c9 um registrador de 8 bits criado a partir do binaryDigit por\u00e9m agora para armazenar um vetor de entrada de 8 bits de tamanho. Register 16 Arquivo : Register16.vhd Depend\u00eancia : Register8 Descri\u00e7\u00e3o : \u00c9 um registrador de 16 bits criado a partir do Register8 por\u00e9m agora para armazenar um vetor de entrada de 16 bits de tamanho. Register 32 Arquivo : Register32.vhd Depend\u00eancia : Register16 Descri\u00e7\u00e3o : \u00c9 um registrador de 32 bits criado a partir do Register16 por\u00e9m agora para armazenar um vetor de entrada de 32 bits de tamanho. Register 64 Arquivo : Register64.vhd Depend\u00eancia : Register32 Descri\u00e7\u00e3o : \u00c9 um registrador de 64 bits criado a partir do Register32 por\u00e9m agora para armazenar um vetor de entrada de 64 bits de tamanho. Program Counter Arquivo : PC.vhd Depend\u00eancia : inc16 , mux16 , reg16 Descri\u00e7\u00e3o : O program counter ser\u00e1 o nosso endere\u00e7ador de mem\u00f3ria da CPU, ele ser\u00e1 respons\u00e1vel por apontar para a pr\u00f3xima instru\u00e7\u00e3o a ser executada. Como normalmente um c\u00f3digo segue um fluxo sequencial (uma linha na sequ\u00eancia da outra) o PC possui a habilidade de se auto incrementar a cada clock (apontando assim para a pr\u00f3xima instru\u00e7\u00e3o), mas ele tem que suportar condi\u00e7\u00f5es (if, while, ...) rompendo com esse fluxo cont\u00ednuo. Sua l\u00f3gica \u00e9 descrita no pseudo c\u00f3digo a seguir: If reset(t-1) then out(t)=0 else if load(t-1) then out(t)=in(t-1) else if inc(t-1) then out(t)=out(t-1)+1 else out(t)=out(t-1) Ram8 Arquivo : Ram8.vhd Depend\u00eancia : Register16 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : \u00c9 uma mem\u00f3ria de 8 endere\u00e7os com 16 bits de largura. O componente possui como entrada o vetor input de 16 bits, o endere\u00e7o a ser armazenado (address) o sinal load que indica quando \u00e9 para ser armazenado e o clock. Como sa\u00edda temos o valor lido no endere\u00e7o especificado quando load for igual a 0. Note que sinal LOAD tem como fun\u00e7\u00e3o similar o do READ/WRITE, quando zero, indica que queremos ler o valor armazenado, quando 1 indica que queremos escrever (write) nessa posi\u00e7\u00e3o. Ram64 Arquivo : Ram64.vhd Depend\u00eancia : Ram8 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 64 endere\u00e7os. Ram512 Arquivo : Ram512.vhd Depend\u00eancia : Ram64 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 512 endere\u00e7os. Ram4k Arquivo : Ram4k.vhd Depend\u00eancia : Ram512 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 4512 endere\u00e7os. Tip Todos esses m\u00f3dulos est\u00e3o bem documentados no livro The Elements of Computer System. Cap 3. Forma de onda \u00b6 Para cada teste realizado, deve-se carregar a interface gr\u00e1fica do simulador e tirar um print da forma de onda do m\u00f3dulo com os testes aplicados a ele. Essa imagem deve ser salva na mesma pasta dos arquivos vhdl ( src/doc/*_wave.png ) e com o mesmo nome dos m\u00f3dulos (similar ao projeto passado). Warning N\u00e3o basta s\u00f3 gerar a imagem, voc\u00ea precisa analisar e entender. Isso ser\u00e1 cobrado nas avalia\u00e7\u00f5es. RTL \u00b6 Para cada m\u00f3dulo deve-se gerar o RTL e salvar uma imagem da implementa\u00e7\u00e3o na pasta src/doc/_rtl.png . !! warning N\u00e3o basta s\u00f3 gerar a imagem, voc\u00ea precisa analisar e entender. Isso ser\u00e1 cobrado nas avalia\u00e7\u00f5es. Testando em Hardware \u00b6 No hardware voc\u00ea dever\u00e1 desenvolver um cen\u00e1rio de teste para o Program Counter e para para a RAM8 . Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito A - M\u00f3dulos extras (rtl + testes) - Gravar v\u00eddeo explicando os rtl e as formas de onda dos m\u00f3dulos extras B - Usou sempre que poss\u00edvel outros m\u00f3dulos para criar um novo (hierarquia) - Exemplo: usou o inc16 , mux16 e reg16 para criar PC - Teste do PC e da RAM8 na FPGA C - Todos os m\u00f3dulos b\u00e1sicos sendo testados no Actions - Todos os m\u00f3dulos b\u00e1sicos passam nos testes - Possui a forma de onda (.png) e rtl de todos os m\u00f3dulos (.png) D - Ao menos um m\u00f3dulo n\u00e3o foi implementando ou n\u00e3o passa no testes. I - Menos da metade dos m\u00f3dulos funcionando A - M\u00f3dulos extras \u00b6 Para a rubrica A o grupo deve implementar os seguintes m\u00f3dulos extras Flip Flop JK Arquivo : conceitoA/FlipFlopJK.vhd Depend\u00eancia : \u00c9 \u00e9 flipflop do tipo JK Flip Flop T Arquivo : ConceitoA/FlipFlopT.vhd Depend\u00eancia : \u00c9 \u00e9 flipflop do tipo T Counter Down Arquivo : ConceitoA/CounterDown.vhd Depend\u00eancia : FlipFlopT O CouterDown \u00e9 componente capaz de contar para 'baixo' em bin\u00e1rio (000 -> 111 -> 110 -> 101 -> 100), esse componente \u00e9 formado por FlipFlops do tipo T, como demonstrado no diagrama a seguir: Fonte: (2008) Fundamentals of Digital Logic with VHDL Design - pg. 406 Desenvolvedor e Scrum Master \u00b6 As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link: Rubricas Scrum e Desenvolvedor Formul\u00e1rios \u00b6 Scrum Master Desenvolvedores","title":"D - L\u00f3gica Sequencial"},{"location":"seq-Projeto/#d-logica-sequencial","text":"Entrega 21/10 - Sexta Neste projeto voc\u00ea ter\u00e1 que desenvolver os componentes de mem\u00f3ria que ser\u00e3o utilizados no computador Z01.","title":"D - L\u00f3gica Sequencial"},{"location":"seq-Projeto/#instrucoes","text":"A pasta do projeto D-LogicaSequencial no reposit\u00f3rio Z01, possui a seguinte estrutura: /D-LogicaSequencial testeLogicaSequencial.py config_testes.txt /Quartus /src *.vhd /teste_cocotb tests.py Quartus: Projeto Quartus que faz uso dos arquivos VHDL localizados em src/*.vhd ; scripts: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/*.vhd : Arquivos VHDL que ser\u00e3o implementados pelo grupo; teste_cocotb/tests.py : Arquivo que possui os testes l\u00f3gicos dos arquivos do rtl.","title":"Instru\u00e7\u00f5es"},{"location":"seq-Projeto/#executando-o-script-de-teste","text":"Abra o terminal na pasta D-LogicaSequencial e execute o script python localizado nessa pasta: $ python testeLogicaSequencial.py O mesmo ir\u00e1 compilar os arquivos .vhd e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Note Lembre que o arquivo config_testes.txt define quais testes ser\u00e3o executados.","title":"Executando o Script de Teste"},{"location":"seq-Projeto/#projeto","text":"Deve-se gerar uma imagem com a forma de onda desses m\u00f3dulos. Deve-se gerar um RTL para cada m\u00f3dulo do projeto (Lab 4) Note que \u00e9 poss\u00edvel reaproveitar, via port map , os m\u00f3dulos dos projetos anteriores. Para isso basta usar port map.","title":"Projeto"},{"location":"seq-Projeto/#modulos","text":"Os modulos a serem desenvolvidos na entrega est\u00e3o detalhados no livro base do curso: Cap\u00edtulo 3 - The Elements of Computing Systems Flip Flop Arquivo : FlipFlopD.vhd Depend\u00eancia : \u00c9 \u00e9 um bloco elementar e sua implementa\u00e7\u00e3o \u00e9 criada no laborat\u00f3rio do projeto . Binary Digit Arquivo : BinaryDigit.vhd Depend\u00eancia : FlipFlopD e Mux2Way Descri\u00e7\u00e3o : \u00c9 um registrador feito para armazenar um \u00fanico bit de informa\u00e7\u00e3o (0 ou 1). A interface do m\u00f3dulo consiste em uma entrada (d) para o bit a ser armazenado, um sinal de load para indicar quando o bit de entrada deve ser armazenado um sinal de clock e a sa\u00edda output* que \u00e9 o bit armazenado: Register 8 Arquivo : Register8.vhd Depend\u00eancia : BinaryDigit Descri\u00e7\u00e3o : \u00c9 um registrador de 8 bits criado a partir do binaryDigit por\u00e9m agora para armazenar um vetor de entrada de 8 bits de tamanho. Register 16 Arquivo : Register16.vhd Depend\u00eancia : Register8 Descri\u00e7\u00e3o : \u00c9 um registrador de 16 bits criado a partir do Register8 por\u00e9m agora para armazenar um vetor de entrada de 16 bits de tamanho. Register 32 Arquivo : Register32.vhd Depend\u00eancia : Register16 Descri\u00e7\u00e3o : \u00c9 um registrador de 32 bits criado a partir do Register16 por\u00e9m agora para armazenar um vetor de entrada de 32 bits de tamanho. Register 64 Arquivo : Register64.vhd Depend\u00eancia : Register32 Descri\u00e7\u00e3o : \u00c9 um registrador de 64 bits criado a partir do Register32 por\u00e9m agora para armazenar um vetor de entrada de 64 bits de tamanho. Program Counter Arquivo : PC.vhd Depend\u00eancia : inc16 , mux16 , reg16 Descri\u00e7\u00e3o : O program counter ser\u00e1 o nosso endere\u00e7ador de mem\u00f3ria da CPU, ele ser\u00e1 respons\u00e1vel por apontar para a pr\u00f3xima instru\u00e7\u00e3o a ser executada. Como normalmente um c\u00f3digo segue um fluxo sequencial (uma linha na sequ\u00eancia da outra) o PC possui a habilidade de se auto incrementar a cada clock (apontando assim para a pr\u00f3xima instru\u00e7\u00e3o), mas ele tem que suportar condi\u00e7\u00f5es (if, while, ...) rompendo com esse fluxo cont\u00ednuo. Sua l\u00f3gica \u00e9 descrita no pseudo c\u00f3digo a seguir: If reset(t-1) then out(t)=0 else if load(t-1) then out(t)=in(t-1) else if inc(t-1) then out(t)=out(t-1)+1 else out(t)=out(t-1) Ram8 Arquivo : Ram8.vhd Depend\u00eancia : Register16 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : \u00c9 uma mem\u00f3ria de 8 endere\u00e7os com 16 bits de largura. O componente possui como entrada o vetor input de 16 bits, o endere\u00e7o a ser armazenado (address) o sinal load que indica quando \u00e9 para ser armazenado e o clock. Como sa\u00edda temos o valor lido no endere\u00e7o especificado quando load for igual a 0. Note que sinal LOAD tem como fun\u00e7\u00e3o similar o do READ/WRITE, quando zero, indica que queremos ler o valor armazenado, quando 1 indica que queremos escrever (write) nessa posi\u00e7\u00e3o. Ram64 Arquivo : Ram64.vhd Depend\u00eancia : Ram8 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 64 endere\u00e7os. Ram512 Arquivo : Ram512.vhd Depend\u00eancia : Ram64 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 512 endere\u00e7os. Ram4k Arquivo : Ram4k.vhd Depend\u00eancia : Ram512 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 4512 endere\u00e7os. Tip Todos esses m\u00f3dulos est\u00e3o bem documentados no livro The Elements of Computer System. Cap 3.","title":"M\u00f3dulos"},{"location":"seq-Projeto/#forma-de-onda","text":"Para cada teste realizado, deve-se carregar a interface gr\u00e1fica do simulador e tirar um print da forma de onda do m\u00f3dulo com os testes aplicados a ele. Essa imagem deve ser salva na mesma pasta dos arquivos vhdl ( src/doc/*_wave.png ) e com o mesmo nome dos m\u00f3dulos (similar ao projeto passado). Warning N\u00e3o basta s\u00f3 gerar a imagem, voc\u00ea precisa analisar e entender. Isso ser\u00e1 cobrado nas avalia\u00e7\u00f5es.","title":"Forma de onda"},{"location":"seq-Projeto/#rtl","text":"Para cada m\u00f3dulo deve-se gerar o RTL e salvar uma imagem da implementa\u00e7\u00e3o na pasta src/doc/_rtl.png . !! warning N\u00e3o basta s\u00f3 gerar a imagem, voc\u00ea precisa analisar e entender. Isso ser\u00e1 cobrado nas avalia\u00e7\u00f5es.","title":"RTL"},{"location":"seq-Projeto/#testando-em-hardware","text":"No hardware voc\u00ea dever\u00e1 desenvolver um cen\u00e1rio de teste para o Program Counter e para para a RAM8 .","title":"Testando em Hardware"},{"location":"seq-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"seq-Projeto/#projeto_1","text":"Conceito A - M\u00f3dulos extras (rtl + testes) - Gravar v\u00eddeo explicando os rtl e as formas de onda dos m\u00f3dulos extras B - Usou sempre que poss\u00edvel outros m\u00f3dulos para criar um novo (hierarquia) - Exemplo: usou o inc16 , mux16 e reg16 para criar PC - Teste do PC e da RAM8 na FPGA C - Todos os m\u00f3dulos b\u00e1sicos sendo testados no Actions - Todos os m\u00f3dulos b\u00e1sicos passam nos testes - Possui a forma de onda (.png) e rtl de todos os m\u00f3dulos (.png) D - Ao menos um m\u00f3dulo n\u00e3o foi implementando ou n\u00e3o passa no testes. I - Menos da metade dos m\u00f3dulos funcionando","title":"Projeto"},{"location":"seq-Projeto/#a-modulos-extras","text":"Para a rubrica A o grupo deve implementar os seguintes m\u00f3dulos extras Flip Flop JK Arquivo : conceitoA/FlipFlopJK.vhd Depend\u00eancia : \u00c9 \u00e9 flipflop do tipo JK Flip Flop T Arquivo : ConceitoA/FlipFlopT.vhd Depend\u00eancia : \u00c9 \u00e9 flipflop do tipo T Counter Down Arquivo : ConceitoA/CounterDown.vhd Depend\u00eancia : FlipFlopT O CouterDown \u00e9 componente capaz de contar para 'baixo' em bin\u00e1rio (000 -> 111 -> 110 -> 101 -> 100), esse componente \u00e9 formado por FlipFlops do tipo T, como demonstrado no diagrama a seguir: Fonte: (2008) Fundamentals of Digital Logic with VHDL Design - pg. 406","title":"A - M\u00f3dulos extras"},{"location":"seq-Projeto/#desenvolvedor-e-scrum-master","text":"As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link: Rubricas Scrum e Desenvolvedor","title":"Desenvolvedor e Scrum Master"},{"location":"seq-Projeto/#formularios","text":"Scrum Master Desenvolvedores","title":"Formul\u00e1rios"},{"location":"seq-lab-1-fpga/","text":"Testando na FPGA \u00b6 No Quartus atribua ao toplevel o arquivo TopLevel.vhd (mesmo passos anteriores), esse m\u00f3dulo ir\u00e1 mapear o FF rec\u00e9m criado para os pinos da FPGA: Clock <= not KEY(0); -- os bot\u00f5es quando nao apertado vale 1 -- e apertado 0, essa l\u00f3gica inverte isso clear <= not KEY(1); set <= not KEY(2); u0 : FlipFlopD port map ( clock => Clock, d => SW(0), clear => clear, preset => set, q => LEDR(0) ); Note que nesse c\u00f3digo estamos usando os bot\u00f5es ( KEY ) da FPGA, al\u00e9m dos LEDs e das Chaves (SW). COMPILE, PROGRAME E TESTE + Chame um professor para validar Esse exemplo n\u00e3o segue as boas pr\u00e1ticas de projetos em FPGA pois n\u00e3o se deve gerar um clock a partir de um pino qualquer da FPGA, a FPGA possui pinos espec\u00edficos para a gera\u00e7\u00e3o do clock. Por\u00e9m \u00e9 a melhor maneira did\u00e1tica de mostrar um FF operando. O correto seria colocarmos um pino de \"enable\" que ativaria ou n\u00e3o o FF quando o bot\u00e3o fosse pressionado. e","title":"Seq lab 1 fpga"},{"location":"seq-lab-1-fpga/#testando-na-fpga","text":"No Quartus atribua ao toplevel o arquivo TopLevel.vhd (mesmo passos anteriores), esse m\u00f3dulo ir\u00e1 mapear o FF rec\u00e9m criado para os pinos da FPGA: Clock <= not KEY(0); -- os bot\u00f5es quando nao apertado vale 1 -- e apertado 0, essa l\u00f3gica inverte isso clear <= not KEY(1); set <= not KEY(2); u0 : FlipFlopD port map ( clock => Clock, d => SW(0), clear => clear, preset => set, q => LEDR(0) ); Note que nesse c\u00f3digo estamos usando os bot\u00f5es ( KEY ) da FPGA, al\u00e9m dos LEDs e das Chaves (SW). COMPILE, PROGRAME E TESTE + Chame um professor para validar Esse exemplo n\u00e3o segue as boas pr\u00e1ticas de projetos em FPGA pois n\u00e3o se deve gerar um clock a partir de um pino qualquer da FPGA, a FPGA possui pinos espec\u00edficos para a gera\u00e7\u00e3o do clock. Por\u00e9m \u00e9 a melhor maneira did\u00e1tica de mostrar um FF operando. O correto seria colocarmos um pino de \"enable\" que ativaria ou n\u00e3o o FF quando o bot\u00e3o fosse pressionado. e","title":"Testando na FPGA"},{"location":"sobra/","text":"Configurando Travis \u00b6 Criando um project no github Adicionando issues Os issues devem ser todos os m\u00f3dulos a serem implementados do projeto. Referenciando a raiz \u00b6 Para come\u00e7ar ser\u00e1 necess\u00e1rio atualizar o fork do reposit\u00f3rio que voc\u00eas criaram, com novos dados que ser\u00e3o colocados no reposit\u00f3rio da disciplina. Uma vez clonado o reposit\u00f3rio, voc\u00ea deve entrar na pasta via o terminal: $ cd Z01.1-NomeDoGrupo Estando na pasta do reposit\u00f3rio precisamos agora indicar para o reposit\u00f3rio original na qual o reposit\u00f3rio que deu origem a esse fork, para isso devemos executar a seguinte linha de c\u00f3digo: $ git remote add upstream https://github.com/insper/Z01.1 Para verificar se deu certo, execute: $ git remote -v E deve aparecer al\u00e9m do link para o reposit\u00f3rio de voc\u00eas a refer\u00eancia ao reposit\u00f3rio original: upstream https://github.com/insper/Z01.1 ( fetch ) upstream https://github.com/insper/Z01.1 ( push ) Tip D\u00favidas? https://gist.github.com/CristinaSolana/1885435 https://help.github.com/articles/syncing-a-fork/ Sincronizando com upstream \u00b6 Apenas mediador Essa etapa deve ser realizada apenas pelo mediador do projeto! Para atualizar o reposit\u00f3rio do grupo de voc\u00eas com as novas atualiza\u00e7\u00f5es inseridas no reposit\u00f3rio da disciplina basta executar: $ git fetch upstream Agora precisamos realizar um merge desse branch (que cont\u00e9m as atualiza\u00e7\u00f5es do reposit\u00f3rio da disciplina) com o master: $ git checkout master $ git merge upstream/master Precisamos submeter essa atualiza\u00e7\u00e3o para o reposit\u00f3rio remoto a fim de todos do grupo terem acesso a vers\u00e3o mais nova. $ git push origin master Dicas VHDL Existem diversos locais onde podem tirar d\u00favida de VHDL , por exemplo : http://esd.cs.ucr.edu/labs/tutorial/ https://courseware.ee.calpoly.edu/cpe-169/Misc_stuff/cheat_sheet.pdf https://www.ics.uci.edu/~jmoorkan/vhdlref/vhdl_golden_reference_guide.pdf","title":"Sobra"},{"location":"sobra/#configurando-travis","text":"Criando um project no github Adicionando issues Os issues devem ser todos os m\u00f3dulos a serem implementados do projeto.","title":"Configurando Travis"},{"location":"sobra/#referenciando-a-raiz","text":"Para come\u00e7ar ser\u00e1 necess\u00e1rio atualizar o fork do reposit\u00f3rio que voc\u00eas criaram, com novos dados que ser\u00e3o colocados no reposit\u00f3rio da disciplina. Uma vez clonado o reposit\u00f3rio, voc\u00ea deve entrar na pasta via o terminal: $ cd Z01.1-NomeDoGrupo Estando na pasta do reposit\u00f3rio precisamos agora indicar para o reposit\u00f3rio original na qual o reposit\u00f3rio que deu origem a esse fork, para isso devemos executar a seguinte linha de c\u00f3digo: $ git remote add upstream https://github.com/insper/Z01.1 Para verificar se deu certo, execute: $ git remote -v E deve aparecer al\u00e9m do link para o reposit\u00f3rio de voc\u00eas a refer\u00eancia ao reposit\u00f3rio original: upstream https://github.com/insper/Z01.1 ( fetch ) upstream https://github.com/insper/Z01.1 ( push ) Tip D\u00favidas? https://gist.github.com/CristinaSolana/1885435 https://help.github.com/articles/syncing-a-fork/","title":"Referenciando a raiz"},{"location":"sobra/#sincronizando-com-upstream","text":"Apenas mediador Essa etapa deve ser realizada apenas pelo mediador do projeto! Para atualizar o reposit\u00f3rio do grupo de voc\u00eas com as novas atualiza\u00e7\u00f5es inseridas no reposit\u00f3rio da disciplina basta executar: $ git fetch upstream Agora precisamos realizar um merge desse branch (que cont\u00e9m as atualiza\u00e7\u00f5es do reposit\u00f3rio da disciplina) com o master: $ git checkout master $ git merge upstream/master Precisamos submeter essa atualiza\u00e7\u00e3o para o reposit\u00f3rio remoto a fim de todos do grupo terem acesso a vers\u00e3o mais nova. $ git push origin master Dicas VHDL Existem diversos locais onde podem tirar d\u00favida de VHDL , por exemplo : http://esd.cs.ucr.edu/labs/tutorial/ https://courseware.ee.calpoly.edu/cpe-169/Misc_stuff/cheat_sheet.pdf https://www.ics.uci.edu/~jmoorkan/vhdlref/vhdl_golden_reference_guide.pdf","title":"Sincronizando com upstream"},{"location":"teste/","text":"Voc\u00ea acertou % - / Quiz 1 1. What is the answer to life, the universe and everything? 2. Your enemy's father... is a hamster smells of elderberries 3. Which factors will contribute to the end of humanity as we know it? Global warming The release of Linux 4.1.15 Cats Advancements in artificial intelligence Verificar resposta Quiz 2 1. Some question some answer or is it this one? 2. Guess the word! Check Answers Quiz 3 1. What is 2 + 2? 2. Guess my number! 3 7 9 Check Answers","title":"Teste"},{"location":"ula-Lab-1/","text":"Lab 6: Adders \u00b6 2022-1 Material atualizado. Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. Half-adder \u00b6 O half-adder \u00e9 um dispositivo somador bin\u00e1rio que possui duas entradas bin\u00e1rias (a,b) e duas sa\u00eddas bin\u00e1ria (soma dos bits (Soma) e o carry (vaium)). A tabela verdade desse componente \u00e9 detalhada a seguir: a b Soma Vaium 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 Com a tabela verdade podemos extrair as duas equa\u00e7\u00f5es que descreve esse componente: Soma e Vaium. soma = a xor b vaium = a and b Note Leia a teoria: Aritm\u00e9tica Binaria para mais informa\u00e7\u00f5es. Tip \\(\\bar{a} b + a \\bar{b} = a \\oplus b\\) Agora com a equa\u00e7\u00e3o definida \u00e9 poss\u00edvel realizarmos uma descri\u00e7\u00e3o em VHDL do componente halfadder . Abra o arquivo C-UnidadeLogicaAritmetica/src/HalfAdder.vhd e modifique sua arquitetura para implementar a equa\u00e7\u00e3o do halfadder. Edite o arquivo de configura\u00e7\u00e3o do teste config_testes.txt e descomente a linha referente ao halfadder . Valide a implementa\u00e7\u00e3o executando o script de testes: testeULA.py Implementando \u00b6 Abra o projeto do Quartus e note que o toplevel faz uso do HalfAdder : begin u1 : HalfAdder port map ( a => SW ( 0 ), b => SW ( 1 ), soma => LEDR ( 0 ), vaium => LEDR ( 1 )); ------ SW(0) --> a -->| |--> Soma --> LEDR(0) | HA | SW(1) --> b -->| |--> Carry --> LEDR(1) ------ toplevel Tarefa Implemente o VHDL Compile o projeto Gere e analise o RTL Programe a FPGA Mexa nas chaves, o resultado \u00e9 o esperado? Full-Adder \u00b6 Voc\u00ea deve fazer a mesma coisa com o fulladder: Extrair a equa\u00e7\u00e3o do FullAdder Transcrever para o arquivo: FullAdder.vhd Testar ( ./testeULA.py ) Com o m\u00f3dulo passando nos testes, editar o toplevel para utilizar no lugar do HalfAdder o FullAdder rec\u00e9m implementando! begin u1 : FullAdder port map ( a => SW ( 0 ), b => SW ( 1 ), c => SW ( 2 ), soma => LEDR ( 0 ), vaium => LEDR ( 1 )); end rtl ; Tarefa Implemente o VHDL Compile o projeto Gere e analise o RTL Programe a FPGA Mexa nas chaves, o resultado \u00e9 o esperado? Somador \u00b6 Agora com o FullAdder (FAD) feito podemos construir um somador mais completo, que soma dois vetores de bits. Para isso iremos precisar de dois FullAdders conectados da seguinte maneira: x1 y1 ---------- x0 y0 '0' | | | | | | | v v v | v v v ---------- | ---------- | a b c | | | a b c | | | | | | Carry <--|vaium | <--|vaium | | soma | | soma | ---------- ---------- | | v v s1 s0 Nessa liga\u00e7\u00e3o, estamos somando dois vetores de dois bits cada: x(1 downto 0) + y(1 downto 0) que resulta em uma soma de dois bits: s(1 downto 0) e um carry . Question Explique o que est\u00e1 acontecendo para o seu colega, voc\u00ea entendeu o porque dessa liga\u00e7\u00e3o? Utilizando port map construa o circuito anterior, utilize como entrada X as chaves [SW(1) SW(0)] e como entrada Y as chaves [SW(3) SW(2)] , para visualizar coloque a sa\u00edda S nos leds [LEDR(1) LEDR(0)] e o carry no LEDR(3) Tarefa Implemente o VHDL Compile o projeto Gere e analise o RTL Programe a FPGA Mexa nas chaves, o resultado \u00e9 o esperado? Tip Voc\u00ea deve utilizar port map para isso, inicializando dois componentes FullAdder","title":"Lab 6: Adders"},{"location":"ula-Lab-1/#lab-6-adders","text":"2022-1 Material atualizado. Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior.","title":"Lab 6: Adders"},{"location":"ula-Lab-1/#half-adder","text":"O half-adder \u00e9 um dispositivo somador bin\u00e1rio que possui duas entradas bin\u00e1rias (a,b) e duas sa\u00eddas bin\u00e1ria (soma dos bits (Soma) e o carry (vaium)). A tabela verdade desse componente \u00e9 detalhada a seguir: a b Soma Vaium 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 Com a tabela verdade podemos extrair as duas equa\u00e7\u00f5es que descreve esse componente: Soma e Vaium. soma = a xor b vaium = a and b Note Leia a teoria: Aritm\u00e9tica Binaria para mais informa\u00e7\u00f5es. Tip \\(\\bar{a} b + a \\bar{b} = a \\oplus b\\) Agora com a equa\u00e7\u00e3o definida \u00e9 poss\u00edvel realizarmos uma descri\u00e7\u00e3o em VHDL do componente halfadder . Abra o arquivo C-UnidadeLogicaAritmetica/src/HalfAdder.vhd e modifique sua arquitetura para implementar a equa\u00e7\u00e3o do halfadder. Edite o arquivo de configura\u00e7\u00e3o do teste config_testes.txt e descomente a linha referente ao halfadder . Valide a implementa\u00e7\u00e3o executando o script de testes: testeULA.py","title":"Half-adder"},{"location":"ula-Lab-1/#implementando","text":"Abra o projeto do Quartus e note que o toplevel faz uso do HalfAdder : begin u1 : HalfAdder port map ( a => SW ( 0 ), b => SW ( 1 ), soma => LEDR ( 0 ), vaium => LEDR ( 1 )); ------ SW(0) --> a -->| |--> Soma --> LEDR(0) | HA | SW(1) --> b -->| |--> Carry --> LEDR(1) ------ toplevel Tarefa Implemente o VHDL Compile o projeto Gere e analise o RTL Programe a FPGA Mexa nas chaves, o resultado \u00e9 o esperado?","title":"Implementando"},{"location":"ula-Lab-1/#full-adder","text":"Voc\u00ea deve fazer a mesma coisa com o fulladder: Extrair a equa\u00e7\u00e3o do FullAdder Transcrever para o arquivo: FullAdder.vhd Testar ( ./testeULA.py ) Com o m\u00f3dulo passando nos testes, editar o toplevel para utilizar no lugar do HalfAdder o FullAdder rec\u00e9m implementando! begin u1 : FullAdder port map ( a => SW ( 0 ), b => SW ( 1 ), c => SW ( 2 ), soma => LEDR ( 0 ), vaium => LEDR ( 1 )); end rtl ; Tarefa Implemente o VHDL Compile o projeto Gere e analise o RTL Programe a FPGA Mexa nas chaves, o resultado \u00e9 o esperado?","title":"Full-Adder"},{"location":"ula-Lab-1/#somador","text":"Agora com o FullAdder (FAD) feito podemos construir um somador mais completo, que soma dois vetores de bits. Para isso iremos precisar de dois FullAdders conectados da seguinte maneira: x1 y1 ---------- x0 y0 '0' | | | | | | | v v v | v v v ---------- | ---------- | a b c | | | a b c | | | | | | Carry <--|vaium | <--|vaium | | soma | | soma | ---------- ---------- | | v v s1 s0 Nessa liga\u00e7\u00e3o, estamos somando dois vetores de dois bits cada: x(1 downto 0) + y(1 downto 0) que resulta em uma soma de dois bits: s(1 downto 0) e um carry . Question Explique o que est\u00e1 acontecendo para o seu colega, voc\u00ea entendeu o porque dessa liga\u00e7\u00e3o? Utilizando port map construa o circuito anterior, utilize como entrada X as chaves [SW(1) SW(0)] e como entrada Y as chaves [SW(3) SW(2)] , para visualizar coloque a sa\u00edda S nos leds [LEDR(1) LEDR(0)] e o carry no LEDR(3) Tarefa Implemente o VHDL Compile o projeto Gere e analise o RTL Programe a FPGA Mexa nas chaves, o resultado \u00e9 o esperado? Tip Voc\u00ea deve utilizar port map para isso, inicializando dois componentes FullAdder","title":"Somador"},{"location":"ula-Lab-2/","text":"Lab 7: Visualizando simula\u00e7\u00e3o \u00b6 2022-1 Material atualizado. \u00c9 muito dif\u00edcil sabermos porque uma implementa\u00e7\u00e3o em VHDL n\u00e3o funciona, atualmente o fluxo \u00e9: transcreve para VHDL o componente; testa; n\u00e3o funcionou volta para o VHDL; testa.... Ser\u00e1 que n\u00e3o existe uma forma de conseguirmos visualizar o resultado do teste e com isso mudarmos a implementa\u00e7\u00e3o em VDHL? Sim existe! Para isso ser\u00e1 necess\u00e1rio invocarmos a parte gr\u00e1fica do modelsim. Na hora de invocarmos o script de teste ( B-UnidadeLogicaAritmetica/testeULA.py ) passe o par\u00e2metro --gui (ou -g ), como a seguir: $ python testeULA.py --gui Esse comando ir\u00e1 executar a simula\u00e7\u00e3o e abrir no software modelsim (toda a simula\u00e7\u00e3o \u00e9 realizada por esse software, mas estava sendo 'mascarada' pelos scripts de teste em py). Note Antes de continuar, o m\u00f3dulo do HalfAdder.vhd j\u00e1 deve est\u00e1 implementando e testado (na forma tradicional). modelsim \u00b6 O modelsim n\u00e3o possui uma interface moderna, por\u00e9m \u00e9 o software de simula\u00e7\u00e3o de hardware mais completo e mais utilizado pela industria. Siga os passos a seguir para conseguirmos visualizarmos a forma de onda: Primeiramente devemos adicionar os sinais que desejamos visualizar, no caso do HalfAdder queremos ver suas entradas (a,b) e suas sa\u00eddas (soma, vaium). Para isso clique em wave : Tip Caso n\u00e3o possua a janela wave aberta, clique em File -> Wave e a janela ir\u00e1 aparecer. E depois selecione no menu das inst\u00e2ncias o m\u00f3dulo u1HalfAdder, com isso poderemos selecionar quais pinos/ sinais gostar\u00edamos de visualizar desse bloco. Arraste todos os sinais para o wave form : Resultando em: Agora podemos executar a simula\u00e7\u00e3o, na regi\u00e3o do script TCL execute o seguinte comando: vunit_run VSIM > vunit_run Podemos agora visualizar a forma de onda: Aprimorando teste \u00b6 Testbench (bancada de teste) \u00e9 a forma utilizada para verificarmos se um projeto de HDL (VHDL, Verilog, ...) est\u00e1 certo, o testbench pode ser escrito em v\u00e1rias linguagens inclusive em VHDL. Os TestBenchs est\u00e3o localizados nas pastas dos projetos em: /tests/tst/ . No projeto C temos os seguintes testbenchs definidos (um para cada m\u00f3dulo a ser implementando): /tests/tst/ tb_Add16.vhd tb_ALU.vhd tb_comparador16.vhd tb_FullAdder.vhd tb_HalfAdder.vhd tb_Inc16.vhd tb_inversor16.vhd tb_zerador16.vhd tb_HalfAdder.vhd \u00b6 Note que na simula\u00e7\u00e3o do HalfAdder n\u00e3o testamos um dos casos de entrada: 1 + 1 , esse teste est\u00e1 incompleto. Vamos corrigir isso! O arquivo tb_HalfAdder faz a inclus\u00e3o do m\u00f3dulo HalfAdder (component e port map) instanciando esse m\u00f3dulo para uso. No arquivo \u00e9 criado est\u00edmulos na entrada do componente e verifica-se se a sa\u00edda est\u00e1 de acordo com o que deveria ser feito. modificando o arquivo \u00b6 Agora vamos modificar o arquivo para inserir o teste que est\u00e1 faltando: 1+1 , para isso inclua as linhas a seguir logo ap\u00f3s o teste 3: -- Teste: 4 -- 1 + 1 +inA <= '1'; inB<= '1'; +wait for 200 ps; +assert(soma = '0' and vaium = '1') report \"Falha em teste: 4\" severity error; Como isso funciona? Primeiro colocamos os valores desejados na entrada do componente: inA <= '1'; inB <= '1'; \u00e9 necess\u00e1rio aguardar um instante de tempo para que as portas l\u00f3gicas fiquem com a sa\u00edda est\u00e1vel (e para possibilitar a visualiza\u00e7\u00e3o na simula\u00e7\u00e3o): wait for 200 ps; Testando novamente \u00b6 Execute novamente a simula\u00e7\u00e3o com o modo --gui e verifique se o m\u00f3dulo est\u00e1 se comportando corretamente: soma = 0 e vaium = 1 . Warning Salve e submeta as altera\u00e7\u00f5es para o remote , apenas uma pessoa do grupo deve realizar isso.","title":"Lab 7: Visualizando simula\u00e7\u00e3o"},{"location":"ula-Lab-2/#lab-7-visualizando-simulacao","text":"2022-1 Material atualizado. \u00c9 muito dif\u00edcil sabermos porque uma implementa\u00e7\u00e3o em VHDL n\u00e3o funciona, atualmente o fluxo \u00e9: transcreve para VHDL o componente; testa; n\u00e3o funcionou volta para o VHDL; testa.... Ser\u00e1 que n\u00e3o existe uma forma de conseguirmos visualizar o resultado do teste e com isso mudarmos a implementa\u00e7\u00e3o em VDHL? Sim existe! Para isso ser\u00e1 necess\u00e1rio invocarmos a parte gr\u00e1fica do modelsim. Na hora de invocarmos o script de teste ( B-UnidadeLogicaAritmetica/testeULA.py ) passe o par\u00e2metro --gui (ou -g ), como a seguir: $ python testeULA.py --gui Esse comando ir\u00e1 executar a simula\u00e7\u00e3o e abrir no software modelsim (toda a simula\u00e7\u00e3o \u00e9 realizada por esse software, mas estava sendo 'mascarada' pelos scripts de teste em py). Note Antes de continuar, o m\u00f3dulo do HalfAdder.vhd j\u00e1 deve est\u00e1 implementando e testado (na forma tradicional).","title":"Lab 7: Visualizando simula\u00e7\u00e3o"},{"location":"ula-Lab-2/#modelsim","text":"O modelsim n\u00e3o possui uma interface moderna, por\u00e9m \u00e9 o software de simula\u00e7\u00e3o de hardware mais completo e mais utilizado pela industria. Siga os passos a seguir para conseguirmos visualizarmos a forma de onda: Primeiramente devemos adicionar os sinais que desejamos visualizar, no caso do HalfAdder queremos ver suas entradas (a,b) e suas sa\u00eddas (soma, vaium). Para isso clique em wave : Tip Caso n\u00e3o possua a janela wave aberta, clique em File -> Wave e a janela ir\u00e1 aparecer. E depois selecione no menu das inst\u00e2ncias o m\u00f3dulo u1HalfAdder, com isso poderemos selecionar quais pinos/ sinais gostar\u00edamos de visualizar desse bloco. Arraste todos os sinais para o wave form : Resultando em: Agora podemos executar a simula\u00e7\u00e3o, na regi\u00e3o do script TCL execute o seguinte comando: vunit_run VSIM > vunit_run Podemos agora visualizar a forma de onda:","title":"modelsim"},{"location":"ula-Lab-2/#aprimorando-teste","text":"Testbench (bancada de teste) \u00e9 a forma utilizada para verificarmos se um projeto de HDL (VHDL, Verilog, ...) est\u00e1 certo, o testbench pode ser escrito em v\u00e1rias linguagens inclusive em VHDL. Os TestBenchs est\u00e3o localizados nas pastas dos projetos em: /tests/tst/ . No projeto C temos os seguintes testbenchs definidos (um para cada m\u00f3dulo a ser implementando): /tests/tst/ tb_Add16.vhd tb_ALU.vhd tb_comparador16.vhd tb_FullAdder.vhd tb_HalfAdder.vhd tb_Inc16.vhd tb_inversor16.vhd tb_zerador16.vhd","title":"Aprimorando teste"},{"location":"ula-Lab-2/#tb_halfaddervhd","text":"Note que na simula\u00e7\u00e3o do HalfAdder n\u00e3o testamos um dos casos de entrada: 1 + 1 , esse teste est\u00e1 incompleto. Vamos corrigir isso! O arquivo tb_HalfAdder faz a inclus\u00e3o do m\u00f3dulo HalfAdder (component e port map) instanciando esse m\u00f3dulo para uso. No arquivo \u00e9 criado est\u00edmulos na entrada do componente e verifica-se se a sa\u00edda est\u00e1 de acordo com o que deveria ser feito.","title":"tb_HalfAdder.vhd"},{"location":"ula-Lab-2/#modificando-o-arquivo","text":"Agora vamos modificar o arquivo para inserir o teste que est\u00e1 faltando: 1+1 , para isso inclua as linhas a seguir logo ap\u00f3s o teste 3: -- Teste: 4 -- 1 + 1 +inA <= '1'; inB<= '1'; +wait for 200 ps; +assert(soma = '0' and vaium = '1') report \"Falha em teste: 4\" severity error; Como isso funciona? Primeiro colocamos os valores desejados na entrada do componente: inA <= '1'; inB <= '1'; \u00e9 necess\u00e1rio aguardar um instante de tempo para que as portas l\u00f3gicas fiquem com a sa\u00edda est\u00e1vel (e para possibilitar a visualiza\u00e7\u00e3o na simula\u00e7\u00e3o): wait for 200 ps;","title":"modificando o arquivo"},{"location":"ula-Lab-2/#testando-novamente","text":"Execute novamente a simula\u00e7\u00e3o com o modo --gui e verifique se o m\u00f3dulo est\u00e1 se comportando corretamente: soma = 0 e vaium = 1 . Warning Salve e submeta as altera\u00e7\u00f5es para o remote , apenas uma pessoa do grupo deve realizar isso.","title":"Testando novamente"},{"location":"ula-Lab-2v2/","text":"Lab 7: Visualizando simula\u00e7\u00e3o \u00b6 2022-2 Material atualizado. \u00c9 muito dif\u00edcil sabermos porque uma implementa\u00e7\u00e3o em VHDL n\u00e3o funciona, atualmente o fluxo \u00e9: transcreve para VHDL o componente; testa; n\u00e3o funcionou volta para o VHDL; testa.... Ser\u00e1 que n\u00e3o existe uma forma de conseguirmos visualizar o resultado do teste e com isso mudarmos a implementa\u00e7\u00e3o em VDHL? Sim existe! Cada simula\u00e7\u00e3o realizada usando o software GHDL salva um arquivo .vcd que cont\u00e9m as formas de onda que resultam dos testes. Assim, ap\u00f3s executar o script de teste ( C-UnidadeLogicaAritmetica/testeULA.py ), pode-se utilizar o software gtkwave para visualizar o resultado. Por exemplo: $ gtkwave teste_cocotb/waves/fulladder.vcd Esse comando ir\u00e1 abrir no software gtkwave o resultado do teste do fulladder . Para visualizar as formas de onda, selecione o m\u00f3dulo na caixa \u00e0 esquerda e, em seguida, arraste os sinais desejado para a caixa Signals .","title":"Lab 7: Visualizando simula\u00e7\u00e3o"},{"location":"ula-Lab-2v2/#lab-7-visualizando-simulacao","text":"2022-2 Material atualizado. \u00c9 muito dif\u00edcil sabermos porque uma implementa\u00e7\u00e3o em VHDL n\u00e3o funciona, atualmente o fluxo \u00e9: transcreve para VHDL o componente; testa; n\u00e3o funcionou volta para o VHDL; testa.... Ser\u00e1 que n\u00e3o existe uma forma de conseguirmos visualizar o resultado do teste e com isso mudarmos a implementa\u00e7\u00e3o em VDHL? Sim existe! Cada simula\u00e7\u00e3o realizada usando o software GHDL salva um arquivo .vcd que cont\u00e9m as formas de onda que resultam dos testes. Assim, ap\u00f3s executar o script de teste ( C-UnidadeLogicaAritmetica/testeULA.py ), pode-se utilizar o software gtkwave para visualizar o resultado. Por exemplo: $ gtkwave teste_cocotb/waves/fulladder.vcd Esse comando ir\u00e1 abrir no software gtkwave o resultado do teste do fulladder . Para visualizar as formas de onda, selecione o m\u00f3dulo na caixa \u00e0 esquerda e, em seguida, arraste os sinais desejado para a caixa Signals .","title":"Lab 7: Visualizando simula\u00e7\u00e3o"},{"location":"ula-Lab-3-online/","text":"Lab 8: ULA \u00b6 Trabalhando em grupo Realizar o lab em trio Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. O objetivo desse laborat\u00f3rio \u00e9 o de trabalharmos com o controle dos sinais da ULA para entendermos as opera\u00e7\u00f5es da unidade de processamento do nosso computador. Programando FPGA com ULA Entendendo fun\u00e7\u00f5es das chaves e LEDs Controlando ULA para realizar opera\u00e7\u00f5es espec\u00edficas (exerc\u00edcios) Programando FPGA \u00b6 Com a FPGA plugada no PC e ligada, execute o script programFPGA.py da pasta do projeto C . Esse script ir\u00e1 realizar a programa\u00e7\u00e3o da FPGA com o hardware da Unidade L\u00f3gica Aritm\u00e9tica - ULA que voc\u00eas ter\u00e3o que implementar. Nesse exemplo os controles da ULA est\u00e3o mapeados para as chaves da FPGA, a sa\u00edda da ULA foi mapeada para LEDs: como ilustrado as figuras a seguir: Como isso \u00e9 feito em VHDL? De uma olhada no toplevel do projeto ( C-UnidadeLogicaAritmetica/src/TopLevel.vhd ) ula0: ALU port map ( x => x, Y => y, Zx => SW(0), Nx => SW(1), Zy => SW(2), Ny => SW(3), F => SW(4), No => SW(5), Zr => LEDR(8), Ng => LEDR(9), Saida(7 downto 0) => LEDR(7 downto 0), Saida(15 downto 8) => Open ); Note que a ULA que iremos desenvolver no projeto C tem 16 bits de largura, por\u00e9m como temos um limite de LEDs e bot\u00f5es na FPGA, estamos ignorando os valores mais significativos, sem afetar o projeto. Controlando ULA \u00b6 Com a FPGA programada podemos testar a ULA modificando seus sinais de controle. A seguir uma proposta de opera\u00e7\u00f5es l\u00f3gicas devem ser realizadas na FPGA, seus sinais de controle e resultado devem ser anotados nas tabelas. Tip O projeto FIXA as entradas da ULA com os valores: X = 0x73 Y = 0x5F Tarefa: out = X Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada X Para isso voc\u00ea deve mexer nas chaves da FPGA e verificar a sa\u00edda nos leds. Tarefa: out = Y Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada Y Tarefa: out = !Y Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada a entrada Y negada Tarefa: out = 0 Fa\u00e7a com que a sa\u00edda da ULA seja 0 Tarefa: out = 1 Fa\u00e7a com que a sa\u00edda da ULA seja 1 Tarefa: out = -1 Fa\u00e7a com que a sa\u00edda da ULA seja -1 (em complemento de 2) Tarefa: out = X+Y Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X + a entrada Y Tarefa (dif\u00edcil): out = X or Y Fa\u00e7a com que a sa\u00edda da ULA seja X ou Y Tarefa (dif\u00edcil): out = X - Y Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X menos a entrada Y","title":"Lab 8: ULA"},{"location":"ula-Lab-3-online/#lab-8-ula","text":"Trabalhando em grupo Realizar o lab em trio Antes de come\u00e7ar Toda vez que um novo projeto come\u00e7ar ser\u00e1 necess\u00e1rio realizar algumas configura\u00e7\u00f5es no reposit\u00f3rio do grupo, voc\u00eas devem seguir para o documento: Util/Come\u00e7ando novo Projeto e depois voltar para esse lab. N\u00e3o seguir sem realizar a etapa anterior. O objetivo desse laborat\u00f3rio \u00e9 o de trabalharmos com o controle dos sinais da ULA para entendermos as opera\u00e7\u00f5es da unidade de processamento do nosso computador. Programando FPGA com ULA Entendendo fun\u00e7\u00f5es das chaves e LEDs Controlando ULA para realizar opera\u00e7\u00f5es espec\u00edficas (exerc\u00edcios)","title":"Lab 8: ULA"},{"location":"ula-Lab-3-online/#programando-fpga","text":"Com a FPGA plugada no PC e ligada, execute o script programFPGA.py da pasta do projeto C . Esse script ir\u00e1 realizar a programa\u00e7\u00e3o da FPGA com o hardware da Unidade L\u00f3gica Aritm\u00e9tica - ULA que voc\u00eas ter\u00e3o que implementar. Nesse exemplo os controles da ULA est\u00e3o mapeados para as chaves da FPGA, a sa\u00edda da ULA foi mapeada para LEDs: como ilustrado as figuras a seguir: Como isso \u00e9 feito em VHDL? De uma olhada no toplevel do projeto ( C-UnidadeLogicaAritmetica/src/TopLevel.vhd ) ula0: ALU port map ( x => x, Y => y, Zx => SW(0), Nx => SW(1), Zy => SW(2), Ny => SW(3), F => SW(4), No => SW(5), Zr => LEDR(8), Ng => LEDR(9), Saida(7 downto 0) => LEDR(7 downto 0), Saida(15 downto 8) => Open ); Note que a ULA que iremos desenvolver no projeto C tem 16 bits de largura, por\u00e9m como temos um limite de LEDs e bot\u00f5es na FPGA, estamos ignorando os valores mais significativos, sem afetar o projeto.","title":"Programando FPGA"},{"location":"ula-Lab-3-online/#controlando-ula","text":"Com a FPGA programada podemos testar a ULA modificando seus sinais de controle. A seguir uma proposta de opera\u00e7\u00f5es l\u00f3gicas devem ser realizadas na FPGA, seus sinais de controle e resultado devem ser anotados nas tabelas. Tip O projeto FIXA as entradas da ULA com os valores: X = 0x73 Y = 0x5F Tarefa: out = X Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada X Para isso voc\u00ea deve mexer nas chaves da FPGA e verificar a sa\u00edda nos leds. Tarefa: out = Y Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada Y Tarefa: out = !Y Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada a entrada Y negada Tarefa: out = 0 Fa\u00e7a com que a sa\u00edda da ULA seja 0 Tarefa: out = 1 Fa\u00e7a com que a sa\u00edda da ULA seja 1 Tarefa: out = -1 Fa\u00e7a com que a sa\u00edda da ULA seja -1 (em complemento de 2) Tarefa: out = X+Y Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X + a entrada Y Tarefa (dif\u00edcil): out = X or Y Fa\u00e7a com que a sa\u00edda da ULA seja X ou Y Tarefa (dif\u00edcil): out = X - Y Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X menos a entrada Y","title":"Controlando ULA"},{"location":"ula-Lab-3/","text":"Lab 8: ULA \u00b6 Tip Antes de seguir voc\u00ea deve ter lido a Teoria/ULA . O objetivo desse laborat\u00f3rio \u00e9 o de trabalharmos com o controle dos sinais da ULA para entendermos as opera\u00e7\u00f5es da unidade de processamento do nosso computador. Para isso iremos: Executando o simulador Controlando ULA para realizar opera\u00e7\u00f5es espec\u00edficas (exerc\u00edcios) Simulador \u00b6 Iremos utilizar um simulador da ULA feito em python + Qt. Siga os passos a seguir: cd ~ git clone https://github.com/eduardomarossi/z01.1-ula cd z01.1-ula pip3 install -r requirements.txt --user python3 main.py Voc\u00ea deve obter a seguinte interface: Controlando ULA \u00b6 Com o simulador podemos testar a ULA modificando seus sinais de controle. A seguir uma proposta de opera\u00e7\u00f5es l\u00f3gicas que devem ser realizadas na ULA, seus sinais de controle e resultados devem ser anotados nas tabelas. Tip O projeto FIXA as entradas da ULA com os valores: X = 0x73 Y = 0x5F Tarefa: out = X Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada X Para isso voc\u00ea deve mexer nas chaves da FPGA e verificar a sa\u00edda nos leds. Tarefa: out = Y Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada Y Tarefa: out = !Y Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada a entrada Y negada Tarefa: out = 0 Fa\u00e7a com que a sa\u00edda da ULA seja 0 Tarefa: out = 1 Fa\u00e7a com que a sa\u00edda da ULA seja 1 Tarefa: out = -1 Fa\u00e7a com que a sa\u00edda da ULA seja -1 (em complemento de 2) Tarefa: out = X+Y Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X + a entrada Y Tarefa (dif\u00edcil): out = X or Y Fa\u00e7a com que a sa\u00edda da ULA seja X ou Y Tarefa (dif\u00edcil): out = X - Y Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X menos a entrada Y","title":"Lab 8: ULA"},{"location":"ula-Lab-3/#lab-8-ula","text":"Tip Antes de seguir voc\u00ea deve ter lido a Teoria/ULA . O objetivo desse laborat\u00f3rio \u00e9 o de trabalharmos com o controle dos sinais da ULA para entendermos as opera\u00e7\u00f5es da unidade de processamento do nosso computador. Para isso iremos: Executando o simulador Controlando ULA para realizar opera\u00e7\u00f5es espec\u00edficas (exerc\u00edcios)","title":"Lab 8: ULA"},{"location":"ula-Lab-3/#simulador","text":"Iremos utilizar um simulador da ULA feito em python + Qt. Siga os passos a seguir: cd ~ git clone https://github.com/eduardomarossi/z01.1-ula cd z01.1-ula pip3 install -r requirements.txt --user python3 main.py Voc\u00ea deve obter a seguinte interface:","title":"Simulador"},{"location":"ula-Lab-3/#controlando-ula","text":"Com o simulador podemos testar a ULA modificando seus sinais de controle. A seguir uma proposta de opera\u00e7\u00f5es l\u00f3gicas que devem ser realizadas na ULA, seus sinais de controle e resultados devem ser anotados nas tabelas. Tip O projeto FIXA as entradas da ULA com os valores: X = 0x73 Y = 0x5F Tarefa: out = X Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada X Para isso voc\u00ea deve mexer nas chaves da FPGA e verificar a sa\u00edda nos leds. Tarefa: out = Y Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada Y Tarefa: out = !Y Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada a entrada Y negada Tarefa: out = 0 Fa\u00e7a com que a sa\u00edda da ULA seja 0 Tarefa: out = 1 Fa\u00e7a com que a sa\u00edda da ULA seja 1 Tarefa: out = -1 Fa\u00e7a com que a sa\u00edda da ULA seja -1 (em complemento de 2) Tarefa: out = X+Y Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X + a entrada Y Tarefa (dif\u00edcil): out = X or Y Fa\u00e7a com que a sa\u00edda da ULA seja X ou Y Tarefa (dif\u00edcil): out = X - Y Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X menos a entrada Y","title":"Controlando ULA"},{"location":"ula-Projeto-dicas/","text":"C - Dicas (A,B) \u00b6 Como n\u00e3o temos mais o hardware dispon\u00edvel, teremos que modificar os testes para podermos testar a novas funcionalidades da ULA. Modificar a ULA Modificar o arquivo: tests/tst/tb_ULA.vhd Alterar o component da ULA (para bater com a entity da ula) Alterar os testes existentes Testar Como fazer? Exemplo \u00b6 Imagine uma ALU em que foi implementado a seguinte funcionalidade: multiplicar um n\u00famero X por 2. As altera\u00e7\u00f5es necess\u00e1rias para esta opera\u00e7\u00e3o foram feitas no arquivo da ULA (VHDL) do grupo. No entanto, o teste implementado da ULA n\u00e3o verifica esta nova funcionalidade. Neste exemplo iremos ver como alterar o teste para validar esta nova fun\u00e7\u00e3o. O teste de interesse \u00e9 o arquivo presente em C-UnidadeLogicaAritimetica/tests/tst/tb_ALU.vhd . A sigla tb significa Testbench (bancada de testes). Note que o arquivo \u00e9 um arquivo em VHDL como qualquer outro, tendo como diferencial, o fato de utilizar a biblioteca vunit_lib que permite carregar alguns recursos para teste, olhe que na arquitetura, deve-se incluir a declara\u00e7\u00e3o do componente a ser testado e em seguida o mesmo \u00e9 instanciado (igual quando feito um port-map). Observe tamb\u00e9m que temos tamb\u00e9m alguns sinais ( signals ), estes s\u00e3o utilizados para alterar os valores que estamos colocando no componente a ser testado. A seguir, uma grande diferen\u00e7a do VHDL convencional que estamos acostumados se d\u00e1 no seguinte trecho: main : process begin ... end Esta diretiva process indica que o que est\u00e1 contido no begin-end ser\u00e1 executado sequencialmente diferente do que viemos usando que \u00e9 execu\u00e7\u00e3o combinacional. Voc\u00eas ter\u00e3o uma aula dedicada ao uso de l\u00f3gica sequencial, por enquanto, apenas pense que cada linha a seguir \u00e9 executada ap\u00f3s a outra. A seguir, teremos v\u00e1rios trechos de c\u00f3digos separados, cada trecho \u00e9 um teste sendo feito. -- Teste: 1 inX <= \"0000000000000000\" ; inY <= \"1111111111111111\" ; inZX <= '1' ; inNX <= '0' ; inZY <= '1' ; inNY <= '0' ; inF <= '1' ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '1' and outNG = '0' and outSaida = \"0000000000000000\" ) report \"Falha em teste: 1\" severity error ; Por exemplo, neste teste acima, \u00e9 colocado 0 na entrada X e -1 na entrada Y. \u00c9 zerado o X, n\u00e3o negado o X, zerado Y e n\u00e3o negado Y. Escolhido opera\u00e7\u00e3o de soma, e n\u00e3o inverte a sa\u00edda. Ele verifica se obtem na sa\u00edda o resultado 0, assim como flag do zerador ativo e flag de negativo desligado. Enfim, como pode-se ver colocamos as entradas desejadas e verificamos se a sa\u00edda \u00e9 a esperada por n\u00f3s. Caso n\u00e3o seja, o comando assert (condi\u00e7\u00e3o de teste) ir\u00e1 falhar e executar\u00e1 o comando report que reportar\u00e1 ao usu\u00e1rio uma falha com severidade de erro. No entanto, temos um problema a resolver, para poder incorporar a funcionalidade de multiplicar por 2, o projetista, decidiu alterar o MUX que existe no projeto da ALU para ser um seletor de 2 bits e portanto o sinal f agora possui 2 bits. Neste caso, teremos que alterar a declara\u00e7\u00e3o do componente referente ao sinal f f : in STD_LOGIC_VECTOR ( 1 downto 0 ); -- se 00 calcula x & y, 01 x + y, 10 x*2 E corrigir o sinal inF para 2 bits e todos os testes pre-existentes tamb\u00e9m ter\u00e3o que ser corrigidos! signal inF : STD_LOGIC_VECTOR ( 1 downto 0 ); `` Exemplo pro teste 1 ``` vhdl -- Teste: 1 inX <= \"0000000000000000\" ; inY <= \"1111111111111111\" ; inZX <= '1' ; inNX <= '0' ; inZY <= '1' ; inNY <= '0' ; inF <= \"01\" ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '1' and outNG = '0' and outSaida = \"0000000000000000\" ) report \"Falha em teste: 1\" severity error ; Feito isso agora vamos criar nossos testes para a funcionalidade outSaida = 2 * X. Colocando os testes no final do arquivo. Primeiro, testar 5 * 2 = 10. -- Teste: 20 - Testa 5 * 2= 10 inX <= \"0000000000000101\" ; inY <= \"1111111111111111\" ; inZX <= '0' ; inNX <= '0' ; inZY <= '0' ; inNY <= '0' ; inF <= \"10\" ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '0' and outNG = '0' and outSaida = \"0000000000001010\" ) report \"Falha em teste: 1\" severity error ; Colocamos X = 5 (em bin\u00e1rio). N\u00e3o zeramos X e escolhemos a op\u00e7\u00e3o correta no seletor f . Verificando o resultado outSaida = 10 (em bin\u00e1rio) e os flags. Depois vamos testar multiplica\u00e7\u00e3o por zero. -- Teste: 21 - Testa 0 * 2 = 0 inX <= \"0000000000000000\" ; inY <= \"1111111111111111\" ; inZX <= '0' ; inNX <= '0' ; inZY <= '0' ; inNY <= '0' ; inF <= \"10\" ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '1' and outNG = '0' and outSaida = \"0000000000000000\" ) report \"Falha em teste: 1\" severity error ; Enfim poderiamos fazer mais testes, envolvendo outros casos diferentes. O ideal \u00e9 criar testes que peguem todas as possibilidades razoavelmente diferentes, note que se for fazer para todas possibilidades, s\u00f3 levando em conta o X teriamos 2^16 possibilidades... \u00e9 invi\u00e1vel. Por isso teste apenas casos de borda , ou seja, quando o comportamento da sa\u00edda pode mudar razoavelmente do normal (por isso testamos o zero aqui!) Com isso feito, ao rodar o teste novamente na pasta, se a funcionalidade tiver sido implementada com sucesso, devemos obter um teste com exito! Parab\u00e9ns!","title":"C - Dicas (A,B)"},{"location":"ula-Projeto-dicas/#c-dicas-ab","text":"Como n\u00e3o temos mais o hardware dispon\u00edvel, teremos que modificar os testes para podermos testar a novas funcionalidades da ULA. Modificar a ULA Modificar o arquivo: tests/tst/tb_ULA.vhd Alterar o component da ULA (para bater com a entity da ula) Alterar os testes existentes Testar","title":"C - Dicas (A,B)"},{"location":"ula-Projeto-dicas/#como-fazer-exemplo","text":"Imagine uma ALU em que foi implementado a seguinte funcionalidade: multiplicar um n\u00famero X por 2. As altera\u00e7\u00f5es necess\u00e1rias para esta opera\u00e7\u00e3o foram feitas no arquivo da ULA (VHDL) do grupo. No entanto, o teste implementado da ULA n\u00e3o verifica esta nova funcionalidade. Neste exemplo iremos ver como alterar o teste para validar esta nova fun\u00e7\u00e3o. O teste de interesse \u00e9 o arquivo presente em C-UnidadeLogicaAritimetica/tests/tst/tb_ALU.vhd . A sigla tb significa Testbench (bancada de testes). Note que o arquivo \u00e9 um arquivo em VHDL como qualquer outro, tendo como diferencial, o fato de utilizar a biblioteca vunit_lib que permite carregar alguns recursos para teste, olhe que na arquitetura, deve-se incluir a declara\u00e7\u00e3o do componente a ser testado e em seguida o mesmo \u00e9 instanciado (igual quando feito um port-map). Observe tamb\u00e9m que temos tamb\u00e9m alguns sinais ( signals ), estes s\u00e3o utilizados para alterar os valores que estamos colocando no componente a ser testado. A seguir, uma grande diferen\u00e7a do VHDL convencional que estamos acostumados se d\u00e1 no seguinte trecho: main : process begin ... end Esta diretiva process indica que o que est\u00e1 contido no begin-end ser\u00e1 executado sequencialmente diferente do que viemos usando que \u00e9 execu\u00e7\u00e3o combinacional. Voc\u00eas ter\u00e3o uma aula dedicada ao uso de l\u00f3gica sequencial, por enquanto, apenas pense que cada linha a seguir \u00e9 executada ap\u00f3s a outra. A seguir, teremos v\u00e1rios trechos de c\u00f3digos separados, cada trecho \u00e9 um teste sendo feito. -- Teste: 1 inX <= \"0000000000000000\" ; inY <= \"1111111111111111\" ; inZX <= '1' ; inNX <= '0' ; inZY <= '1' ; inNY <= '0' ; inF <= '1' ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '1' and outNG = '0' and outSaida = \"0000000000000000\" ) report \"Falha em teste: 1\" severity error ; Por exemplo, neste teste acima, \u00e9 colocado 0 na entrada X e -1 na entrada Y. \u00c9 zerado o X, n\u00e3o negado o X, zerado Y e n\u00e3o negado Y. Escolhido opera\u00e7\u00e3o de soma, e n\u00e3o inverte a sa\u00edda. Ele verifica se obtem na sa\u00edda o resultado 0, assim como flag do zerador ativo e flag de negativo desligado. Enfim, como pode-se ver colocamos as entradas desejadas e verificamos se a sa\u00edda \u00e9 a esperada por n\u00f3s. Caso n\u00e3o seja, o comando assert (condi\u00e7\u00e3o de teste) ir\u00e1 falhar e executar\u00e1 o comando report que reportar\u00e1 ao usu\u00e1rio uma falha com severidade de erro. No entanto, temos um problema a resolver, para poder incorporar a funcionalidade de multiplicar por 2, o projetista, decidiu alterar o MUX que existe no projeto da ALU para ser um seletor de 2 bits e portanto o sinal f agora possui 2 bits. Neste caso, teremos que alterar a declara\u00e7\u00e3o do componente referente ao sinal f f : in STD_LOGIC_VECTOR ( 1 downto 0 ); -- se 00 calcula x & y, 01 x + y, 10 x*2 E corrigir o sinal inF para 2 bits e todos os testes pre-existentes tamb\u00e9m ter\u00e3o que ser corrigidos! signal inF : STD_LOGIC_VECTOR ( 1 downto 0 ); `` Exemplo pro teste 1 ``` vhdl -- Teste: 1 inX <= \"0000000000000000\" ; inY <= \"1111111111111111\" ; inZX <= '1' ; inNX <= '0' ; inZY <= '1' ; inNY <= '0' ; inF <= \"01\" ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '1' and outNG = '0' and outSaida = \"0000000000000000\" ) report \"Falha em teste: 1\" severity error ; Feito isso agora vamos criar nossos testes para a funcionalidade outSaida = 2 * X. Colocando os testes no final do arquivo. Primeiro, testar 5 * 2 = 10. -- Teste: 20 - Testa 5 * 2= 10 inX <= \"0000000000000101\" ; inY <= \"1111111111111111\" ; inZX <= '0' ; inNX <= '0' ; inZY <= '0' ; inNY <= '0' ; inF <= \"10\" ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '0' and outNG = '0' and outSaida = \"0000000000001010\" ) report \"Falha em teste: 1\" severity error ; Colocamos X = 5 (em bin\u00e1rio). N\u00e3o zeramos X e escolhemos a op\u00e7\u00e3o correta no seletor f . Verificando o resultado outSaida = 10 (em bin\u00e1rio) e os flags. Depois vamos testar multiplica\u00e7\u00e3o por zero. -- Teste: 21 - Testa 0 * 2 = 0 inX <= \"0000000000000000\" ; inY <= \"1111111111111111\" ; inZX <= '0' ; inNX <= '0' ; inZY <= '0' ; inNY <= '0' ; inF <= \"10\" ; inNO <= '0' ; wait for 100 ps ; assert ( outZR = '1' and outNG = '0' and outSaida = \"0000000000000000\" ) report \"Falha em teste: 1\" severity error ; Enfim poderiamos fazer mais testes, envolvendo outros casos diferentes. O ideal \u00e9 criar testes que peguem todas as possibilidades razoavelmente diferentes, note que se for fazer para todas possibilidades, s\u00f3 levando em conta o X teriamos 2^16 possibilidades... \u00e9 invi\u00e1vel. Por isso teste apenas casos de borda , ou seja, quando o comportamento da sa\u00edda pode mudar razoavelmente do normal (por isso testamos o zero aqui!) Com isso feito, ao rodar o teste novamente na pasta, se a funcionalidade tiver sido implementada com sucesso, devemos obter um teste com exito! Parab\u00e9ns!","title":"Como fazer? Exemplo"},{"location":"ula-Projeto/","text":"C - ULA \u00b6 Entrega 23/09 - Sexta Neste projeto seu grupo ter\u00e1 que desenvolver os componentes para a implementa\u00e7\u00e3o de uma unidade l\u00f3gica e aritm\u00e9tica (ULA) de 16 bit (proposta pelo livro texto) que ser\u00e1 capaz de realizar opera\u00e7\u00f5es bin\u00e1rias muito simples por\u00e9m que possibilitar\u00e1 realizarmos muitas coisas! Warning O grupo deve eleger um novo scrum master para essa entrega (diferente do projeto B). Note Nas discuss\u00f5es com o grupo, o scrum master dever\u00e1 definir os m\u00f3dulos que cada integrante ir\u00e1 desenvolver. Crie uma rotina para commits e pull-requests. Tip Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Tip Sempre teste os m\u00f3dulos e verifique se est\u00e1 funcionando como o esperado. Instru\u00e7\u00f5es \u00b6 A pasta do projeto C, no reposit\u00f3rio Z01, possui a seguinte estrutura: /C-ULA testeULA.py programFPGA.py /Quartus /src *.vhd /teste_cocotb tests.py Quartus: Projeto Quartus que faz uso dos arquivos VHDL localizados em src/*.vhd; testeULA.py: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/*.vhd: Arquivos VHDL que ser\u00e3o implementados pelo grupo; teste_cocotb/tests.py: Arquivo python que realizam o teste l\u00f3gico nos arquivos do rtl. Executando o Script de Teste \u00b6 Abra o terminal na pasta C-UnidadeLogicaAritmetica/ e execute o script python localizado nessa pasta: $ ./testeULA.py O mesmo ir\u00e1 compilar os arquivos src/*.vhd e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Esse comando executa um teste unit\u00e1rio em cada um dos m\u00f3dulos, verificando se sua implementa\u00e7\u00e3o est\u00e1 correta. O resultado \u00e9 exibido na tela como : Passed ou Failed . O que deve ser feito: \u00b6 Al\u00e9m de implementar os m\u00f3dulos, deve-se gerar uma imagem com a forma de onda de cada um desses m\u00f3dulos. Para cada nova implementa\u00e7\u00e3o deve-se criar um novo branch e remover o coment\u00e1rio do arquivo: tests/config.txt somente o m\u00f3dulo que est\u00e1 sendo implementado. Note que \u00e9 poss\u00edvel reaproveitar, via port map , os m\u00f3dulos do projeto anterior (C). Esses m\u00f3dulos anteriores j\u00e1 est\u00e3o inclu\u00eddos automaticamente (pelo script) na compila\u00e7\u00e3o dos m\u00f3dulos do projeto C. M\u00f3dulos \u00b6 Note Esses arquivos est\u00e3o localizados em C-UnidadeLogicaAritmetica/src/ Deve-se implementar os seguintes circuitos combinacionais: HalfAdder Arquivo : HalfAdder.vhd Descri\u00e7\u00e3o : Adiciona dois bits que resulta em um bit de soma e outro de carry out. Depend\u00eancia : N\u00e3o tem. FullAdder Arquivo : FullAdder.vhd Descri\u00e7\u00e3o : Adiciona tr\u00eas bits, dois referentes \u00e0s entradas e o outro referente ao carry in. O resultado \u00e9 um bit com a soma e outro com o carry out. Depend\u00eancia : N\u00e3o tem. Add16 Arquivo : Add16.vhd Descri\u00e7\u00e3o : Adiciona dois vetores de 16 bits resultando em um vetor de 16 bits (sem carry out do bit mais significativo - MSB). Depend\u00eancia : FullAdder Note Deve utilizar o FullAdder via port map. Inc16 Arquivo : Inc16.vhd Descri\u00e7\u00e3o : Adiciona '1' a um vetor de 16 bits resultando em um vetor de 16 bits (sem carry out). Depend\u00eancia : Add16 Note Deve utilizar o add16 via port map . Inversor16 Arquivo : Inversor16.vhd Descri\u00e7\u00e3o : Inverte um vetor de entrada quando o bit de controle n (nx ou ny) for igual a '1', e n\u00e3o modifica o vetor de entrada caso contr\u00e1rio. O resultado \u00e9 um novo vetor de 16 bits. Depend\u00eancia : N\u00e3o tem. Zerador16 Arquivo : Zerador16.vhd Descri\u00e7\u00e3o : Zera um vetor de entrada quando o bit de controle z (zx ou zy) for igual a '1'. N\u00e3o modifica o vetor de entrada se o bit for '0'. O resultado \u00e9 um novo vetor de 16 bits. Depend\u00eancia : N\u00e3o tem. Comparador16 Arquivo : Comparador16.vhd Descri\u00e7\u00e3o : Verifica se o vetor de sa\u00edda (16 bits) \u00e9 igual a zero ( zr ) e se menor que Zero ( ng ). Caso igual a zero, faz com que o sinal zr seja igual a '1' e caso contr\u00e1rio '0'. Se o sinal de entrada for negativo faz com que ng receba '1' e '0' caso contr\u00e1rio. Depend\u00eancia : N\u00e3o tem. Pseudo c\u00f3digo : if ( a == 0 ): zr = 1 else : zr = 0 if ( a < 0 ): ng = 1 else : ng = 0 ALU Arquivo : ALU.vhd Descri\u00e7\u00e3o : A entidade que faz o mapeamento de todas as demais, interligando os blocos (zerador, comparador, inversor, Add ....) em um \u00fanico bloco. Depend\u00eancia : Comparador16 , Zerador16 , Inversor16 , Add16 , Note Deve utilizar os m\u00f3dulos via via port map . Para implementar a ALU ser\u00e1 necess\u00e1rio usar os blocos desenvolvidos neste projeto e os blocos desenvolvidos no projeto anterior: And16 , Mux16 . O script de compila\u00e7\u00e3o e teste j\u00e1 faz a inclus\u00e3o deles. A arquitetura da ULA pode ser vista abaixo: Forma de onda \u00b6 Para cada teste realizado, deve-se carregar a interface gr\u00e1fica e tirar um print da forma de onda do m\u00f3dulo com os testes aplicados a ele (LAB-7). Essa imagem deve ser salva na mesma pasta dos arquivos VHDL (src/) e com o mesmo nome dos m\u00f3dulos. A pasta no final do projeto deve possuir os seguintes arquivos: /src/ Add16.vhd Add16.png ALU.vhd ALU.png Comparador16.vhd Comparador16.png FullAdder.vhd FullAdder.png HalfAdder.vhd HalfAdder.png Inc16.vhd Inc16.png Inversor16.vhd Inversor16.png Zerador16.vhd Zerador16.png Testando em HW \u00b6 Para testar os m\u00f3dulos em hardware, deve-se abrir o projeto ( C-UnidadeLogicaAritmetica/Quartus ). Ele j\u00e1 inclui todos os m\u00f3dulos desta entrega e tamb\u00e9m os m\u00f3dulos da entrega passada. O arquivo localizado em src/toplevel.vhd j\u00e1 faz o mapeamento dos pinos da FPGA para os pinos da ULA. Para testar no hardware basta compilar e programar a FPGA. Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Warning N\u00e3o fazer rubrica A e B na master, criar um novo branch para isso! Conceito A+ - Modifique a ULA adicionando a opera\u00e7\u00e3o de shift left/right - Modifique o toplevel para mostrar o resultado da ULA nos displays de 7s (em hexa) B+ - Modifique a ULA adicionando o sinal de estouro da soma (carry) a sa\u00edda da ULA - Modifique a ULA adicionando a opera\u00e7\u00e3o: X xor Y - Compila no Quartus a ULA do grupo e faz um v\u00eddeo demonstrando o seu funcionamento (FPGA). C+ - Configurou o Actions para testar o projeto - Todos os modulos implementando e passam nos testes - Faz reaproveitamentos dos m\u00f3dulos via port map sempre que poss\u00edvel - Possui a forma de onda de todos os m\u00f3dulos (.png). D - Implementou todos os m\u00f3dulos menos a ULA. I - N\u00e3o implementou os m\u00f3dulos Add16, ULA, Comparador, FullAdder, HalfAdder, Inc16, Inversosr, Zerador. Note Para os conceitos B e A, o grupo deve gravar um v\u00eddeo da FPGA demonstrando que as modifica\u00e7\u00f5es funcionam. Para os conceitos B e A, o grupo deve modificar o teste da ULA para que comprove o funcionamento dos recursos adicionados (sinais, opera\u00e7\u00f5es), ou seja, test\u00e1-los tentando abordar todos os casos comuns de uso. Os conceitos s\u00e3o incrementais: primeiro deve atingir o C B A. Desenvolvedor e Scrum Master \u00b6 As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link: Rubricas Scrum e Desenvolvedor Formul\u00e1rios \u00b6 Scrum Master Desenvolvedores","title":"C - ULA"},{"location":"ula-Projeto/#c-ula","text":"Entrega 23/09 - Sexta Neste projeto seu grupo ter\u00e1 que desenvolver os componentes para a implementa\u00e7\u00e3o de uma unidade l\u00f3gica e aritm\u00e9tica (ULA) de 16 bit (proposta pelo livro texto) que ser\u00e1 capaz de realizar opera\u00e7\u00f5es bin\u00e1rias muito simples por\u00e9m que possibilitar\u00e1 realizarmos muitas coisas! Warning O grupo deve eleger um novo scrum master para essa entrega (diferente do projeto B). Note Nas discuss\u00f5es com o grupo, o scrum master dever\u00e1 definir os m\u00f3dulos que cada integrante ir\u00e1 desenvolver. Crie uma rotina para commits e pull-requests. Tip Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Tip Sempre teste os m\u00f3dulos e verifique se est\u00e1 funcionando como o esperado.","title":"C - ULA"},{"location":"ula-Projeto/#instrucoes","text":"A pasta do projeto C, no reposit\u00f3rio Z01, possui a seguinte estrutura: /C-ULA testeULA.py programFPGA.py /Quartus /src *.vhd /teste_cocotb tests.py Quartus: Projeto Quartus que faz uso dos arquivos VHDL localizados em src/*.vhd; testeULA.py: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/*.vhd: Arquivos VHDL que ser\u00e3o implementados pelo grupo; teste_cocotb/tests.py: Arquivo python que realizam o teste l\u00f3gico nos arquivos do rtl.","title":"Instru\u00e7\u00f5es"},{"location":"ula-Projeto/#executando-o-script-de-teste","text":"Abra o terminal na pasta C-UnidadeLogicaAritmetica/ e execute o script python localizado nessa pasta: $ ./testeULA.py O mesmo ir\u00e1 compilar os arquivos src/*.vhd e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Esse comando executa um teste unit\u00e1rio em cada um dos m\u00f3dulos, verificando se sua implementa\u00e7\u00e3o est\u00e1 correta. O resultado \u00e9 exibido na tela como : Passed ou Failed .","title":"Executando o Script de Teste"},{"location":"ula-Projeto/#o-que-deve-ser-feito","text":"Al\u00e9m de implementar os m\u00f3dulos, deve-se gerar uma imagem com a forma de onda de cada um desses m\u00f3dulos. Para cada nova implementa\u00e7\u00e3o deve-se criar um novo branch e remover o coment\u00e1rio do arquivo: tests/config.txt somente o m\u00f3dulo que est\u00e1 sendo implementado. Note que \u00e9 poss\u00edvel reaproveitar, via port map , os m\u00f3dulos do projeto anterior (C). Esses m\u00f3dulos anteriores j\u00e1 est\u00e3o inclu\u00eddos automaticamente (pelo script) na compila\u00e7\u00e3o dos m\u00f3dulos do projeto C.","title":"O que deve ser feito:"},{"location":"ula-Projeto/#modulos","text":"Note Esses arquivos est\u00e3o localizados em C-UnidadeLogicaAritmetica/src/ Deve-se implementar os seguintes circuitos combinacionais: HalfAdder Arquivo : HalfAdder.vhd Descri\u00e7\u00e3o : Adiciona dois bits que resulta em um bit de soma e outro de carry out. Depend\u00eancia : N\u00e3o tem. FullAdder Arquivo : FullAdder.vhd Descri\u00e7\u00e3o : Adiciona tr\u00eas bits, dois referentes \u00e0s entradas e o outro referente ao carry in. O resultado \u00e9 um bit com a soma e outro com o carry out. Depend\u00eancia : N\u00e3o tem. Add16 Arquivo : Add16.vhd Descri\u00e7\u00e3o : Adiciona dois vetores de 16 bits resultando em um vetor de 16 bits (sem carry out do bit mais significativo - MSB). Depend\u00eancia : FullAdder Note Deve utilizar o FullAdder via port map. Inc16 Arquivo : Inc16.vhd Descri\u00e7\u00e3o : Adiciona '1' a um vetor de 16 bits resultando em um vetor de 16 bits (sem carry out). Depend\u00eancia : Add16 Note Deve utilizar o add16 via port map . Inversor16 Arquivo : Inversor16.vhd Descri\u00e7\u00e3o : Inverte um vetor de entrada quando o bit de controle n (nx ou ny) for igual a '1', e n\u00e3o modifica o vetor de entrada caso contr\u00e1rio. O resultado \u00e9 um novo vetor de 16 bits. Depend\u00eancia : N\u00e3o tem. Zerador16 Arquivo : Zerador16.vhd Descri\u00e7\u00e3o : Zera um vetor de entrada quando o bit de controle z (zx ou zy) for igual a '1'. N\u00e3o modifica o vetor de entrada se o bit for '0'. O resultado \u00e9 um novo vetor de 16 bits. Depend\u00eancia : N\u00e3o tem. Comparador16 Arquivo : Comparador16.vhd Descri\u00e7\u00e3o : Verifica se o vetor de sa\u00edda (16 bits) \u00e9 igual a zero ( zr ) e se menor que Zero ( ng ). Caso igual a zero, faz com que o sinal zr seja igual a '1' e caso contr\u00e1rio '0'. Se o sinal de entrada for negativo faz com que ng receba '1' e '0' caso contr\u00e1rio. Depend\u00eancia : N\u00e3o tem. Pseudo c\u00f3digo : if ( a == 0 ): zr = 1 else : zr = 0 if ( a < 0 ): ng = 1 else : ng = 0 ALU Arquivo : ALU.vhd Descri\u00e7\u00e3o : A entidade que faz o mapeamento de todas as demais, interligando os blocos (zerador, comparador, inversor, Add ....) em um \u00fanico bloco. Depend\u00eancia : Comparador16 , Zerador16 , Inversor16 , Add16 , Note Deve utilizar os m\u00f3dulos via via port map . Para implementar a ALU ser\u00e1 necess\u00e1rio usar os blocos desenvolvidos neste projeto e os blocos desenvolvidos no projeto anterior: And16 , Mux16 . O script de compila\u00e7\u00e3o e teste j\u00e1 faz a inclus\u00e3o deles. A arquitetura da ULA pode ser vista abaixo:","title":"M\u00f3dulos"},{"location":"ula-Projeto/#forma-de-onda","text":"Para cada teste realizado, deve-se carregar a interface gr\u00e1fica e tirar um print da forma de onda do m\u00f3dulo com os testes aplicados a ele (LAB-7). Essa imagem deve ser salva na mesma pasta dos arquivos VHDL (src/) e com o mesmo nome dos m\u00f3dulos. A pasta no final do projeto deve possuir os seguintes arquivos: /src/ Add16.vhd Add16.png ALU.vhd ALU.png Comparador16.vhd Comparador16.png FullAdder.vhd FullAdder.png HalfAdder.vhd HalfAdder.png Inc16.vhd Inc16.png Inversor16.vhd Inversor16.png Zerador16.vhd Zerador16.png","title":"Forma de onda"},{"location":"ula-Projeto/#testando-em-hw","text":"Para testar os m\u00f3dulos em hardware, deve-se abrir o projeto ( C-UnidadeLogicaAritmetica/Quartus ). Ele j\u00e1 inclui todos os m\u00f3dulos desta entrega e tamb\u00e9m os m\u00f3dulos da entrega passada. O arquivo localizado em src/toplevel.vhd j\u00e1 faz o mapeamento dos pinos da FPGA para os pinos da ULA. Para testar no hardware basta compilar e programar a FPGA.","title":"Testando em HW"},{"location":"ula-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"ula-Projeto/#projeto","text":"Warning N\u00e3o fazer rubrica A e B na master, criar um novo branch para isso! Conceito A+ - Modifique a ULA adicionando a opera\u00e7\u00e3o de shift left/right - Modifique o toplevel para mostrar o resultado da ULA nos displays de 7s (em hexa) B+ - Modifique a ULA adicionando o sinal de estouro da soma (carry) a sa\u00edda da ULA - Modifique a ULA adicionando a opera\u00e7\u00e3o: X xor Y - Compila no Quartus a ULA do grupo e faz um v\u00eddeo demonstrando o seu funcionamento (FPGA). C+ - Configurou o Actions para testar o projeto - Todos os modulos implementando e passam nos testes - Faz reaproveitamentos dos m\u00f3dulos via port map sempre que poss\u00edvel - Possui a forma de onda de todos os m\u00f3dulos (.png). D - Implementou todos os m\u00f3dulos menos a ULA. I - N\u00e3o implementou os m\u00f3dulos Add16, ULA, Comparador, FullAdder, HalfAdder, Inc16, Inversosr, Zerador. Note Para os conceitos B e A, o grupo deve gravar um v\u00eddeo da FPGA demonstrando que as modifica\u00e7\u00f5es funcionam. Para os conceitos B e A, o grupo deve modificar o teste da ULA para que comprove o funcionamento dos recursos adicionados (sinais, opera\u00e7\u00f5es), ou seja, test\u00e1-los tentando abordar todos os casos comuns de uso. Os conceitos s\u00e3o incrementais: primeiro deve atingir o C B A.","title":"Projeto"},{"location":"ula-Projeto/#desenvolvedor-e-scrum-master","text":"As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link: Rubricas Scrum e Desenvolvedor","title":"Desenvolvedor e Scrum Master"},{"location":"ula-Projeto/#formularios","text":"Scrum Master Desenvolvedores","title":"Formul\u00e1rios"},{"location":"ula-lab-4/","text":"Lab 14: Pequena CPU \u00b6 Sugest\u00e3o de trabalho Cada um faz na sua m\u00e1quina simultaneamente com os demais integrantes do grupo, discutindo no v\u00eddeo. Um integrante faz na sua m\u00e1quina e compartilha a tela com os demais (todos comentam o mesmo c\u00f3digo) Tempo Tempo estimando no lab: 60 min Come\u00e7ando \u00b6 Este lab est\u00e1 dispon\u00edvel em um novo reposit\u00f3rio, para come\u00e7arem trabalhar clonem o reposit\u00f3rio para sua m\u00e1quina, iremos trabalhar coma ele neste lab. cd ~ https://github.com/Insper/Z01.1-Lab-Pequena-CPU CPU \u00b6 O objetivo desse lab \u00e9 o de come\u00e7armos entender como a ULA pode ser utilizada por um programa para realizar a\u00e7\u00f5es de um programa. Nas CPUs a ULA \u00e9 controlada por um bloco chamado de Unidade de Controle ( control unit ), que \u00e9 respons\u00e1vel por interpretar as instru\u00e7\u00f5es e comandar a ULA! Para entender como isso funciona vamos usar a ULA desenvolvida por voc\u00eas em uma arquitetura de CPU muito simples, mas que servir\u00e1 de exemplo (o nosso computador n\u00e3o ser\u00e1 assim). Essa arquitetura de CPU possui uma entrada do usu\u00e1rio (que pode ser por exemplo as chaves da placa) que s\u00e3o conectados a entrada Y da ULA e uma sa\u00edda (que pode ser os LEDs) conectada a sa\u00edda (out), a entrada X \u00e9 conectada a um registrador que recebe o valor da sa\u00edda da ULA. Na CPU deste lab iremos trabalhar com o conceito de registrador acumulador, onde o resultado da ULA ser\u00e1 sempre salvo em REG_C , consforme diagrama a seguir: Note Registrador \u00e9 o termo utilizado para uma unidade simples de mem\u00f3ria capaz de armazenar apenas uma unidade de dados (nesse caso 16 bits). Nesse caso, a cada opera\u00e7\u00e3o do sistema (clock) o registrador salvo o resultado da ULA. Tip O REG_C guarda um resultado da opera\u00e7\u00e3o da ULA at\u00e9 a pr\u00f3xima instru\u00e7\u00e3o (clock) Control Unit \u00b6 A unidade de controle (UC) \u00e9 o hardware respons\u00e1vel por ler as instru\u00e7\u00f5es a serem executadas (que est\u00e3o em bin\u00e1rio) e comandar toda a CPU para executar o que deve ser feito. Nesse exemplo a UC comanda apenas a ULA, mas ela poderia controlar outras coisas tamb\u00e9m (mux, pipeline, ...). A UC apenas transcreve instru\u00e7\u00f5es (programa) em controle da CPU, para isso temos que definir uma linguagem de m\u00e1quina. Programa \u00b6 Linguagem de m\u00e1quina \u00e9 uma palavra de 4 bits de largura que descreve qual opera\u00e7\u00e3o deve ser realizada na CPU, no exemplo fornecido temos as seguintes opera\u00e7\u00f5es definidas: Linguagem de maquina Instru\u00e7\u00e3o OP CODE 0000 REG_C = REG_C nop 0001 REG_C = 0 mov 0,C 1000 REG_C = ! REG_C not C 1001 REG_C = REG_C + 1 add 1,C 1010 REG_C = REG_C + Y add Y,C 1011 REG_C = REG_C - 1 sub 1,C Tip OP CODE \u00e9 o termo usado para descrever uma instru\u00e7\u00e3o, programas escritos em assembly fazem uso de opcodes para facilitar a programa\u00e7\u00e3o. Note nop = No Operation (n\u00e3o faz nada/ n\u00e3o modifica nada!) Exemplo \u00b6 Vamos pensar em um programa muito simples que faz o seguinte: Carrega 0 em REG_C REG_C + 1 O c\u00f3digo disso em assembly (usando os opcodes) seria: mov 0 , C add 1 , C nop Note Esse nop \u00e9 implementando pelo comando que faz com que a entrada X passe pela ULA (sem modifica\u00e7\u00e3o), assim REG_C = REG_C , ou seja, n\u00e3o faz nada. Info Uma instru\u00e7\u00e3o (linha do programa assembly) \u00e9 executada a cada clock. Para executarmos esse programa, devemos traduzir o programa assembly em linguagem de m\u00e1quina que \u00e9 de fato o que a CPU \u00e9 capaz de ler (lembre que no final \u00e9 tudo uns e zeros), para isso temos que ter a mem\u00f3ria (ROM) inicializada com os seguintes valores: 0: 0001 <--- O Programa come\u00e7a na linha 0 1: 1001 | e a cada 'clock' executa para pr\u00f3xima linha 2: 0000 v Info O programa respons\u00e1vel por traduzir linguagem assembly em \"bin\u00e1rio\" \u00e9 chamado de montador ou assembler. Legal n\u00e9? Mas para isso funcionar a Unidade de Controle deve ser capaz de ler a instru\u00e7\u00e3o (4 bits) e controlar a ULA para executar tal comando. A unidade foi fornecida apenas com duas instru\u00e7\u00f5es implementadas: mov 0,C , add 1,c . Para testar o projeto com o c\u00f3digo exemplo anterior basta executar o comando a seguir no terminar: ./testeLab.py . Tip Execute o comando com -g e verifique a forma de onda (e todos os sinais internos da CPU) Terminando o Control Unit \u00b6 Nossa primeira atividade do lab ser\u00e1 a de termina de implementar a Unidade de Controle, para poder executar todas as instru\u00e7\u00f5es anteriores. A vers\u00e3o dispon\u00edvel para voc\u00eas s\u00f3 possui as instru\u00e7\u00f5es: mov 0,C , add 1,C e nop , vamos implementar as demais? Para isso ser\u00e1 necess\u00e1rio modificar o arquivo /src/ControlUnit.vhd , nele st\u00e1 implementando a l\u00f3gica que traduz instru\u00e7\u00f5es em comando do hardware. O control unit l\u00ea o a instru\u00e7\u00e3o que est\u00e1 salva na mem\u00f3ria ( op ) e aciona a ULA ( ula ) para realizar tal opera\u00e7\u00e3o. A sa\u00edda do controlUnit ( ula out std_logic_vector ) \u00e9 um vetor composto pelos sinais de controle da ula: [ zx , nx , zy , ny , f , no ] e pelo 'en' que controla se iremos salvar a informa\u00e7\u00e3o no registrador C ( en <= '1' ) ou n\u00e3o iremos armazenar a informa\u00e7\u00e3o que sai da ULA ( en<='0' ). entity controlunit is port ( op : in std_logic_vector ( 3 downto 0 ); en : out std_logic ; ng : in std_logic ; zr : in std_logic ; ula : out std_logic_vector ( 5 downto 0 ) ); end entity ; architecture rtl of controlunit is signal control : std_logic_vector ( 6 downto 0 ); begin ula <= control ( 6 downto 1 ); en <= control ( 0 ); control <= \"101010\" & '1' when op = \"0001\" else -- mov 0, C \"011111\" & '1' when op = \"1001\" else -- add 1, C \"000000\" & '1' when op = \"0000\" else -- nop \"101000\" & '0' ; -- qualquer coisa! end architecture ; Example Quando a instru\u00e7\u00e3o for 0001 ( mov 0,C ) o controlUnit ir\u00e1 acionar a ula: zx=1 , nx=0 , zy=1 , ny=1 , f=1 , no=0 para que a sua sa\u00edda seja 0 e ent\u00e3o salvar o valor no registrador C ('en=1') Tarefa Voc\u00ea deve implementar as instru\u00e7\u00f5es que est\u00e3o faltando no ControlUnit: not C add Y,C sub 1,C Tip Voc\u00ea precisa adicionar os casos a serem implementando no when do ControlUnit. Agora para testar os novos comandos voc\u00ea deve aplicar o patch a seguir que modifica o teste do laborat\u00f3rio inserindo os novos comandos, execute no terminar: git apply teste1.patch E ent\u00e3o teste: ./testeLab.py Analisando CPU \u00b6 Discuta em grupo as limita\u00e7\u00f5es dessa nossa CPU, e o que poderia ser feito para melhorar: Essa CPU \u00e9 capaz de realizar qualquer tipo de c\u00e1lculo? Quais limita\u00e7\u00f5es voc\u00ea percebe nela? Temos condicionais? Como implementar? .... Adicionando condicional \u00b6 Vamos agora adicionar uma instru\u00e7\u00e3o de condicional a nossa CPU, ser\u00e1 algo bem simples e pouco funcional na pr\u00e1tica, mas vai dar a ideia de como as coisas funcionam. Para isso iremos criar uma nova instru\u00e7\u00e3o que copia a entrada Y para REG_C apenas se Y for menor ou igual a zero. Como a seguir: if Y<=0: REG_C = Y else REG_C = REG_C Vamos atribuir a est\u00e1 opera\u00e7\u00e3o o valor 1111 . Para realizarmos essa opera\u00e7\u00e3o teremos que fazer a leitura dos valores ng e zr que a ULA fornece para n\u00f3s e ent\u00e3o tomarmos a decis\u00e3o se iremos salvar Y em REG_C ( en=1 ) ou n\u00e3o ( en=0 ). Tarefa Implemente a nova funcionalidade no ControlUnit, lembre que agora \u00e9 necess\u00e1rio verificar o valor de ng e zr para saber se o valor de Y \u00e9 menor ou igual a zero.","title":"Lab 14: Pequena CPU"},{"location":"ula-lab-4/#lab-14-pequena-cpu","text":"Sugest\u00e3o de trabalho Cada um faz na sua m\u00e1quina simultaneamente com os demais integrantes do grupo, discutindo no v\u00eddeo. Um integrante faz na sua m\u00e1quina e compartilha a tela com os demais (todos comentam o mesmo c\u00f3digo) Tempo Tempo estimando no lab: 60 min","title":"Lab 14: Pequena CPU"},{"location":"ula-lab-4/#comecando","text":"Este lab est\u00e1 dispon\u00edvel em um novo reposit\u00f3rio, para come\u00e7arem trabalhar clonem o reposit\u00f3rio para sua m\u00e1quina, iremos trabalhar coma ele neste lab. cd ~ https://github.com/Insper/Z01.1-Lab-Pequena-CPU","title":"Come\u00e7ando"},{"location":"ula-lab-4/#cpu","text":"O objetivo desse lab \u00e9 o de come\u00e7armos entender como a ULA pode ser utilizada por um programa para realizar a\u00e7\u00f5es de um programa. Nas CPUs a ULA \u00e9 controlada por um bloco chamado de Unidade de Controle ( control unit ), que \u00e9 respons\u00e1vel por interpretar as instru\u00e7\u00f5es e comandar a ULA! Para entender como isso funciona vamos usar a ULA desenvolvida por voc\u00eas em uma arquitetura de CPU muito simples, mas que servir\u00e1 de exemplo (o nosso computador n\u00e3o ser\u00e1 assim). Essa arquitetura de CPU possui uma entrada do usu\u00e1rio (que pode ser por exemplo as chaves da placa) que s\u00e3o conectados a entrada Y da ULA e uma sa\u00edda (que pode ser os LEDs) conectada a sa\u00edda (out), a entrada X \u00e9 conectada a um registrador que recebe o valor da sa\u00edda da ULA. Na CPU deste lab iremos trabalhar com o conceito de registrador acumulador, onde o resultado da ULA ser\u00e1 sempre salvo em REG_C , consforme diagrama a seguir: Note Registrador \u00e9 o termo utilizado para uma unidade simples de mem\u00f3ria capaz de armazenar apenas uma unidade de dados (nesse caso 16 bits). Nesse caso, a cada opera\u00e7\u00e3o do sistema (clock) o registrador salvo o resultado da ULA. Tip O REG_C guarda um resultado da opera\u00e7\u00e3o da ULA at\u00e9 a pr\u00f3xima instru\u00e7\u00e3o (clock)","title":"CPU"},{"location":"ula-lab-4/#control-unit","text":"A unidade de controle (UC) \u00e9 o hardware respons\u00e1vel por ler as instru\u00e7\u00f5es a serem executadas (que est\u00e3o em bin\u00e1rio) e comandar toda a CPU para executar o que deve ser feito. Nesse exemplo a UC comanda apenas a ULA, mas ela poderia controlar outras coisas tamb\u00e9m (mux, pipeline, ...). A UC apenas transcreve instru\u00e7\u00f5es (programa) em controle da CPU, para isso temos que definir uma linguagem de m\u00e1quina.","title":"Control Unit"},{"location":"ula-lab-4/#programa","text":"Linguagem de m\u00e1quina \u00e9 uma palavra de 4 bits de largura que descreve qual opera\u00e7\u00e3o deve ser realizada na CPU, no exemplo fornecido temos as seguintes opera\u00e7\u00f5es definidas: Linguagem de maquina Instru\u00e7\u00e3o OP CODE 0000 REG_C = REG_C nop 0001 REG_C = 0 mov 0,C 1000 REG_C = ! REG_C not C 1001 REG_C = REG_C + 1 add 1,C 1010 REG_C = REG_C + Y add Y,C 1011 REG_C = REG_C - 1 sub 1,C Tip OP CODE \u00e9 o termo usado para descrever uma instru\u00e7\u00e3o, programas escritos em assembly fazem uso de opcodes para facilitar a programa\u00e7\u00e3o. Note nop = No Operation (n\u00e3o faz nada/ n\u00e3o modifica nada!)","title":"Programa"},{"location":"ula-lab-4/#exemplo","text":"Vamos pensar em um programa muito simples que faz o seguinte: Carrega 0 em REG_C REG_C + 1 O c\u00f3digo disso em assembly (usando os opcodes) seria: mov 0 , C add 1 , C nop Note Esse nop \u00e9 implementando pelo comando que faz com que a entrada X passe pela ULA (sem modifica\u00e7\u00e3o), assim REG_C = REG_C , ou seja, n\u00e3o faz nada. Info Uma instru\u00e7\u00e3o (linha do programa assembly) \u00e9 executada a cada clock. Para executarmos esse programa, devemos traduzir o programa assembly em linguagem de m\u00e1quina que \u00e9 de fato o que a CPU \u00e9 capaz de ler (lembre que no final \u00e9 tudo uns e zeros), para isso temos que ter a mem\u00f3ria (ROM) inicializada com os seguintes valores: 0: 0001 <--- O Programa come\u00e7a na linha 0 1: 1001 | e a cada 'clock' executa para pr\u00f3xima linha 2: 0000 v Info O programa respons\u00e1vel por traduzir linguagem assembly em \"bin\u00e1rio\" \u00e9 chamado de montador ou assembler. Legal n\u00e9? Mas para isso funcionar a Unidade de Controle deve ser capaz de ler a instru\u00e7\u00e3o (4 bits) e controlar a ULA para executar tal comando. A unidade foi fornecida apenas com duas instru\u00e7\u00f5es implementadas: mov 0,C , add 1,c . Para testar o projeto com o c\u00f3digo exemplo anterior basta executar o comando a seguir no terminar: ./testeLab.py . Tip Execute o comando com -g e verifique a forma de onda (e todos os sinais internos da CPU)","title":"Exemplo"},{"location":"ula-lab-4/#terminando-o-control-unit","text":"Nossa primeira atividade do lab ser\u00e1 a de termina de implementar a Unidade de Controle, para poder executar todas as instru\u00e7\u00f5es anteriores. A vers\u00e3o dispon\u00edvel para voc\u00eas s\u00f3 possui as instru\u00e7\u00f5es: mov 0,C , add 1,C e nop , vamos implementar as demais? Para isso ser\u00e1 necess\u00e1rio modificar o arquivo /src/ControlUnit.vhd , nele st\u00e1 implementando a l\u00f3gica que traduz instru\u00e7\u00f5es em comando do hardware. O control unit l\u00ea o a instru\u00e7\u00e3o que est\u00e1 salva na mem\u00f3ria ( op ) e aciona a ULA ( ula ) para realizar tal opera\u00e7\u00e3o. A sa\u00edda do controlUnit ( ula out std_logic_vector ) \u00e9 um vetor composto pelos sinais de controle da ula: [ zx , nx , zy , ny , f , no ] e pelo 'en' que controla se iremos salvar a informa\u00e7\u00e3o no registrador C ( en <= '1' ) ou n\u00e3o iremos armazenar a informa\u00e7\u00e3o que sai da ULA ( en<='0' ). entity controlunit is port ( op : in std_logic_vector ( 3 downto 0 ); en : out std_logic ; ng : in std_logic ; zr : in std_logic ; ula : out std_logic_vector ( 5 downto 0 ) ); end entity ; architecture rtl of controlunit is signal control : std_logic_vector ( 6 downto 0 ); begin ula <= control ( 6 downto 1 ); en <= control ( 0 ); control <= \"101010\" & '1' when op = \"0001\" else -- mov 0, C \"011111\" & '1' when op = \"1001\" else -- add 1, C \"000000\" & '1' when op = \"0000\" else -- nop \"101000\" & '0' ; -- qualquer coisa! end architecture ; Example Quando a instru\u00e7\u00e3o for 0001 ( mov 0,C ) o controlUnit ir\u00e1 acionar a ula: zx=1 , nx=0 , zy=1 , ny=1 , f=1 , no=0 para que a sua sa\u00edda seja 0 e ent\u00e3o salvar o valor no registrador C ('en=1') Tarefa Voc\u00ea deve implementar as instru\u00e7\u00f5es que est\u00e3o faltando no ControlUnit: not C add Y,C sub 1,C Tip Voc\u00ea precisa adicionar os casos a serem implementando no when do ControlUnit. Agora para testar os novos comandos voc\u00ea deve aplicar o patch a seguir que modifica o teste do laborat\u00f3rio inserindo os novos comandos, execute no terminar: git apply teste1.patch E ent\u00e3o teste: ./testeLab.py","title":"Terminando o Control Unit"},{"location":"ula-lab-4/#analisando-cpu","text":"Discuta em grupo as limita\u00e7\u00f5es dessa nossa CPU, e o que poderia ser feito para melhorar: Essa CPU \u00e9 capaz de realizar qualquer tipo de c\u00e1lculo? Quais limita\u00e7\u00f5es voc\u00ea percebe nela? Temos condicionais? Como implementar? ....","title":"Analisando CPU"},{"location":"ula-lab-4/#adicionando-condicional","text":"Vamos agora adicionar uma instru\u00e7\u00e3o de condicional a nossa CPU, ser\u00e1 algo bem simples e pouco funcional na pr\u00e1tica, mas vai dar a ideia de como as coisas funcionam. Para isso iremos criar uma nova instru\u00e7\u00e3o que copia a entrada Y para REG_C apenas se Y for menor ou igual a zero. Como a seguir: if Y<=0: REG_C = Y else REG_C = REG_C Vamos atribuir a est\u00e1 opera\u00e7\u00e3o o valor 1111 . Para realizarmos essa opera\u00e7\u00e3o teremos que fazer a leitura dos valores ng e zr que a ULA fornece para n\u00f3s e ent\u00e3o tomarmos a decis\u00e3o se iremos salvar Y em REG_C ( en=1 ) ou n\u00e3o ( en=0 ). Tarefa Implemente a nova funcionalidade no ControlUnit, lembre que agora \u00e9 necess\u00e1rio verificar o valor de ng e zr para saber se o valor de Y \u00e9 menor ou igual a zero.","title":"Adicionando condicional"},{"location":"vm-Lab-1/","text":"Lab 17: vm \u00b6 Tip Realizar o laborat\u00f3rio individualmente. Mas trabalhar no grupo e trocar ideias. Nesse lab iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado na \u00faltima avalia\u00e7\u00e3o. Esse laborat\u00f3rio mistura exerc\u00edcios com leitura de teoria, \u00e9 essencial que voc\u00ea realize as leituras recomendadas para cada sec\u00e7\u00e3o e ent\u00e3o voltar para fazer os exerc\u00edcios. Antes de come\u00e7ar Esse laborat\u00f3rio n\u00e3o faz parte de um projeto, mas ser\u00e1 necess\u00e1rio atualizar o reposit\u00f3rio de voc\u00eas com o Z01. Escolham um do grupo para fazer isso, ele n\u00e3o ser\u00e1 um scrum master! N\u00e3o seguir sem realizar a etapa anterior. Z01-Tools Atualizar Z01-Tools! antes de seguir... Treinando RPN \u00b6 Abra o simulador online da calculadora hp48 e realize os seguintes c\u00e1lculos: 12 + 34 + 56 \u2013 78 + 90 \u2013 12 (12 \u00d7 34) + (56 \u00d7 78) \u2013 (90 \u00d7 12) 3 \u00d7 (4 + (5 \u00d7 (6 + 7))) (Dica: comece pelo par\u00eantese mais interno) \\(1/\\sqrt{121}\\) Exerc\u00edcios extra\u00eddos de: https://hansklav.home.xs4all.nl/rpn/ VM Z01 - b\u00e1sico \u00b6 TEORIA Leia a Teoria/VM antes de seguir. Vamos agora trabalhar com a nossa vm, voc\u00eas ter\u00e3o que implementar os programas a seguir e testar com o script ( testeVM.py ). Info A descri\u00e7\u00e3o do que deve ser feito est\u00e1 no pr\u00f3prio c\u00f3digo Projetos/H-VM/src/vm/1a-Add Projetos/H-VM/src/vm/1b-Calculadora Voc\u00ea notou que nesses c\u00f3digos pedimos para salvar o resultado em temp 0 , fazemos isso pela opera\u00e7\u00e3o de pop temp 0 . Vamos estudar um pouco a respeito disso: TEORIA Leia a Teoria/VM - Segmentos antes de seguir. goto (jump) \u00b6 Nossa linguagem vm suporta realizar condi\u00e7\u00f5es e loops, vamos ver como isso \u00e9 feito e praticar um pouco! TEORIA Leia a Teoria/VM - jump antes de seguir. Implementem os c\u00f3digos a seguir H-VM/src/vm/1c-loop H-VM/src/vm/1c-div Tip De uma olhada nos c\u00f3digos de exemplo, tem coisa de condi\u00e7\u00e3o l\u00e1! fun\u00e7\u00f5es \u00b6 Vamos agora fazer o uso de fun\u00e7\u00f5es em VM, o que ir\u00e1 nos permitir fazer as seguintes opera\u00e7\u00f5es: \\(10/2 + 15*3*\\sqrt{121}/2^5\\) , lembre que no nosso hardware n\u00e3o possu\u00edmos os operadores de multiplica\u00e7\u00e3o, divis\u00e3o, raiz quadrada e muito menos exponencial. Mas com o uso de fun\u00e7\u00f5es podemos implementar isso em c\u00f3digo e usar para implementar a equa\u00e7\u00e3o anterior. div(10,2) + div(mult(mult(15,3), sqrt(121.2))), exp(2,5)) note que os operadores viraram chamadas de fun\u00e7\u00f5es. TEORIA Leia a Teoria/VM - Fun\u00e7\u00f5es antes de seguir. Vamos agora trabalhar com fun\u00e7\u00f5es na nossa VM, implementem os c\u00f3digos a seguir: H-VM/src/vm/2b-Calculadora H-VM/src/vm/2c-Calculadora H-VM/src/vm/2d-Calculadora","title":"Lab 17: vm"},{"location":"vm-Lab-1/#lab-17-vm","text":"Tip Realizar o laborat\u00f3rio individualmente. Mas trabalhar no grupo e trocar ideias. Nesse lab iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado na \u00faltima avalia\u00e7\u00e3o. Esse laborat\u00f3rio mistura exerc\u00edcios com leitura de teoria, \u00e9 essencial que voc\u00ea realize as leituras recomendadas para cada sec\u00e7\u00e3o e ent\u00e3o voltar para fazer os exerc\u00edcios. Antes de come\u00e7ar Esse laborat\u00f3rio n\u00e3o faz parte de um projeto, mas ser\u00e1 necess\u00e1rio atualizar o reposit\u00f3rio de voc\u00eas com o Z01. Escolham um do grupo para fazer isso, ele n\u00e3o ser\u00e1 um scrum master! N\u00e3o seguir sem realizar a etapa anterior. Z01-Tools Atualizar Z01-Tools! antes de seguir...","title":"Lab 17: vm"},{"location":"vm-Lab-1/#treinando-rpn","text":"Abra o simulador online da calculadora hp48 e realize os seguintes c\u00e1lculos: 12 + 34 + 56 \u2013 78 + 90 \u2013 12 (12 \u00d7 34) + (56 \u00d7 78) \u2013 (90 \u00d7 12) 3 \u00d7 (4 + (5 \u00d7 (6 + 7))) (Dica: comece pelo par\u00eantese mais interno) \\(1/\\sqrt{121}\\) Exerc\u00edcios extra\u00eddos de: https://hansklav.home.xs4all.nl/rpn/","title":"Treinando RPN"},{"location":"vm-Lab-1/#vm-z01-basico","text":"TEORIA Leia a Teoria/VM antes de seguir. Vamos agora trabalhar com a nossa vm, voc\u00eas ter\u00e3o que implementar os programas a seguir e testar com o script ( testeVM.py ). Info A descri\u00e7\u00e3o do que deve ser feito est\u00e1 no pr\u00f3prio c\u00f3digo Projetos/H-VM/src/vm/1a-Add Projetos/H-VM/src/vm/1b-Calculadora Voc\u00ea notou que nesses c\u00f3digos pedimos para salvar o resultado em temp 0 , fazemos isso pela opera\u00e7\u00e3o de pop temp 0 . Vamos estudar um pouco a respeito disso: TEORIA Leia a Teoria/VM - Segmentos antes de seguir.","title":"VM Z01 - b\u00e1sico"},{"location":"vm-Lab-1/#goto-jump","text":"Nossa linguagem vm suporta realizar condi\u00e7\u00f5es e loops, vamos ver como isso \u00e9 feito e praticar um pouco! TEORIA Leia a Teoria/VM - jump antes de seguir. Implementem os c\u00f3digos a seguir H-VM/src/vm/1c-loop H-VM/src/vm/1c-div Tip De uma olhada nos c\u00f3digos de exemplo, tem coisa de condi\u00e7\u00e3o l\u00e1!","title":"goto (jump)"},{"location":"vm-Lab-1/#funcoes","text":"Vamos agora fazer o uso de fun\u00e7\u00f5es em VM, o que ir\u00e1 nos permitir fazer as seguintes opera\u00e7\u00f5es: \\(10/2 + 15*3*\\sqrt{121}/2^5\\) , lembre que no nosso hardware n\u00e3o possu\u00edmos os operadores de multiplica\u00e7\u00e3o, divis\u00e3o, raiz quadrada e muito menos exponencial. Mas com o uso de fun\u00e7\u00f5es podemos implementar isso em c\u00f3digo e usar para implementar a equa\u00e7\u00e3o anterior. div(10,2) + div(mult(mult(15,3), sqrt(121.2))), exp(2,5)) note que os operadores viraram chamadas de fun\u00e7\u00f5es. TEORIA Leia a Teoria/VM - Fun\u00e7\u00f5es antes de seguir. Vamos agora trabalhar com fun\u00e7\u00f5es na nossa VM, implementem os c\u00f3digos a seguir: H-VM/src/vm/2b-Calculadora H-VM/src/vm/2c-Calculadora H-VM/src/vm/2d-Calculadora","title":"fun\u00e7\u00f5es"},{"location":"vm-Projeto/","text":"H - VM \u00b6 Nesse projeto iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado em prova e servir\u00e1 para voc\u00eas entenderem o pr\u00f3ximo projeto: I-VMTranslator . Instru\u00e7\u00f5es \u00b6 As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no laborat\u00f3rio H-VM-Lab-1 . M\u00f3dulos a serem implementados \u00b6 Os m\u00f3dulos est\u00e3o na pasta Projetos/H-VM/src/vm/ e est\u00e3o organizados por ordem de dificuldade: 1a-Add 1b-Add 1c-Dic 2a-Calculadora 2b-Calculadora 2c-Calculadora 2d-Calculadora Para testar, basta editar o arquivo tests/config.txt com os m\u00f3dulos que deseja executar e ent\u00e3o executar o script: testeVM.py localizado na pasta do projeto. Exemplos \u00b6 Existem diversos exemplos de programas escritos em linguagem VM, eles est\u00e3o na pasta src/examples/","title":"H - VM"},{"location":"vm-Projeto/#h-vm","text":"Nesse projeto iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado em prova e servir\u00e1 para voc\u00eas entenderem o pr\u00f3ximo projeto: I-VMTranslator .","title":"H - VM"},{"location":"vm-Projeto/#instrucoes","text":"As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no laborat\u00f3rio H-VM-Lab-1 .","title":"Instru\u00e7\u00f5es"},{"location":"vm-Projeto/#modulos-a-serem-implementados","text":"Os m\u00f3dulos est\u00e3o na pasta Projetos/H-VM/src/vm/ e est\u00e3o organizados por ordem de dificuldade: 1a-Add 1b-Add 1c-Dic 2a-Calculadora 2b-Calculadora 2c-Calculadora 2d-Calculadora Para testar, basta editar o arquivo tests/config.txt com os m\u00f3dulos que deseja executar e ent\u00e3o executar o script: testeVM.py localizado na pasta do projeto.","title":"M\u00f3dulos a serem implementados"},{"location":"vm-Projeto/#exemplos","text":"Existem diversos exemplos de programas escritos em linguagem VM, eles est\u00e3o na pasta src/examples/","title":"Exemplos"},{"location":"vm-lab/","text":"Lab 17 - vm \u00b6 Nesse lab iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado em prova e servir\u00e1 para voc\u00eas entenderem o pr\u00f3ximo projeto: I-VMTranslator e ser\u00e1 cobrado na ultima avalia\u00e7\u00e3o. M\u00f3dulos a serem implementados \u00b6 Os m\u00f3dulos est\u00e3o na pasta Projetos/H-VM/src/lab/ e est\u00e3o organizados por ordem de dificuldade: 1a-Add.nasm 1b-Add.nasm 2a-Calculadora.nasm 1c-Div.nasm 2b-Calculadora.nasm 2c-Calculadora.nasm 2d-Calculadora.nasm Para testar, basta editar o arquivo tests/config.txt com os m\u00f3dulos que deseja executar e ent\u00e3o executar o script: testeVM.py localizado na pasta do projeto. Exemplos Existem diversos exemplos de programas escritos em linguagem VM, eles est\u00e3o na pasta src/vmExamples/ Linguagem VM \u00b6 A linguagem VM proposta para o curso \u00e9 baseada em pilha (assim como tantas outras), as opera\u00e7\u00f5es nesse n\u00edvel n\u00e3o mais lidam com registradores do computador mas sim com dados que s\u00e3o colocados e tirados de uma pilha ( stack ). Uma grande vantagem disso \u00e9 a abstra\u00e7\u00e3o do hardware, agora n\u00e3o precisamos mais nos preocuparmos com a manipula\u00e7\u00e3o dos dados em baixo n\u00edvel e saber por exemplo quantos registradores possu\u00edmos (o VMTranslator ser\u00e1 encarregado disso). Um c\u00f3digo escrito em VM passa pelas seguintes etapas antes de ser executado em m\u00e1quina : VMTranslator Assembler .vm -------------> .nasm -------------> .hack Com o c\u00f3digo vm conseguimos implementar fun\u00e7\u00f5es, o que facilita muito o desenvolvimento de qualquer software e prepara o terreno para conseguirmos implementar uma linguagem de alto n\u00edvel. O c\u00f3digo vm \u00e9 traduzido para linguagem nasm pelo VMTranslator (voc\u00eas v\u00e3o ter que fazer parte desse programa no \u00faltimo projeto), e ent\u00e3o \u00e9 montado pelo Assembler para linguagem de m\u00e1quina. Temos diversas vantagens quando programamos em linguagem virtual : a. Abstra\u00e7\u00e3o de Hardware - (j\u00e1 n\u00e3o mais lidamos com o hardware diretamente) c. Portabilidade b. C\u00f3digo mais alto n\u00edvel - (chamada de fun\u00e7\u00f5es, linguagem mais pr\u00f3xima do que estamos acostumados, ...) Pilha \u00b6 A linguagem VM \u00e9 baseada em pilha, ou seja, todas as opera\u00e7\u00f5es que ser\u00e3o realizadas ser\u00e3o feitas na pilha. A pilha \u00e9 uma regi\u00e3o da mem\u00f3ria RAM (no nosso caso come\u00e7a no endere\u00e7o 256 da mem\u00f3ria RAM) reservada para armazenar os dados que est\u00e3o sendo manipulados. A pilha cresce conforme opera\u00e7\u00f5es de push (envio de dados para a pilha) v\u00e3o sendo executados, e decresce conforme opera\u00e7\u00f5es c\u00e1lculo ou de pull (retirar dados da pilha) s\u00e3o executadas. A figura a seguir demonstra a evolu\u00e7\u00e3o da pilha quando um programa em vm \u00e9 executado: A pilha come\u00e7a vazia e o Stack Pointer (SP) aponta para 256 Uma opera\u00e7\u00e3o de push constant 3 \u00e9 executada, SP \u00e9 incrementando e o valor 3 \u00e9 colocado no topo da pilha Uma opera\u00e7\u00e3o de push constant 7 \u00e9 executada, SP \u00e9 incrementando e o valor 7 \u00e9 colocado no topo da pilha Adicionasse os dois valores no topo da pilha add Retira o valor do topo da pilha para o endere\u00e7o de mem\u00f3ria tempor\u00e1rio 0 . Stack Pointer (SP) \u00b6 O Stack Pointer \u00e9 o endere\u00e7o de mem\u00f3ria ( RAM[0] ) reservado por apontar o topo da pilha, ou seja, a pr\u00f3xima posi\u00e7\u00e3o vazia da pilha. O SP \u00e9 salvo na RAM 0 (R0) e deve ser incrementado/decrementado conforme a pilha vai sendo manipulada. Opera\u00e7\u00f5es \u00b6 Considerando a seguinte disposi\u00e7\u00e3o na pilha : ... ... X Y SP -> S\u00e3o suportadas as seguintes opera\u00e7\u00f5es aritm\u00e9ticas na pilha: add executa: X + Y sub executa: X - Y neg executa: - Y (complemento de dois) eq compara X == Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 gt compara X > Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 lt compara X < Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 and executa: X and Y (bit a bit) or executa: X or Y (bit a bit) not executa: not Y (bit a bit) Note que as opera\u00e7\u00f5es de compara\u00e7\u00e3o ( eq , gt , lt ) resulta em um True ou False e esse resultado \u00e9 salvo na pilha. Considere o exemplo a seguir (em hexa) que possui inicialmente na pilha os valores 0x2 , 0x3 e 0x5 , ap\u00f3s a opera\u00e7\u00e3o de eq os valores 3 e 5 s\u00e3o comparados e resulta em um valor True ou False ( 0xFFFF ou 0x0000 ). -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x5 SP-> SP-> Warning A pilha n\u00e3o \u00e9 'limpada' a cada opera\u00e7\u00e3o, os endere\u00e7os que n\u00e3o sofreram modifica\u00e7\u00e3o dado uma opera\u00e7\u00e3o continuam l\u00e1, mas voc\u00ea n\u00e3o pode considerar que eles s\u00e3o v\u00e1lidos! Se olharmos a mem\u00f3ria real do exemplo anterior seria a seguinte: -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x0 0x5 SP-> 0x5 0x5 SP-> 0x0 0x0 0x0 O mesmo acontece com arquivos que s\u00e3o deletados do seu computador, o sistema operacional n\u00e3o \"limpa a mem\u00f3ria\" sempre que um arquivo \u00e9 exclu\u00eddo, apenas apaga o ponteiro para aquele arquivo. stackoverflow Agora voc\u00ea consegue entender o significado do nome do site stack overflow? \u00e9 um estouro na pilha (quando o tamanho da pilha ultrapassa a mem\u00f3ria que est\u00e1 reservado para ela!) Acesso a mem\u00f3ria \u00b6 Os comandos push e pop s\u00e3o a \u00fanica maneira que temos de acessar/manipular a mem\u00f3ria. O comando push traz para a pilha um valor da mem\u00f3ria (RAM ou ROM) e o comando pop salva na mem\u00f3ria um valor da pila (RAM). Os comandos possuem a seguinte sintaxe : push segment index pop segment index Onde index \u00e9 um n\u00famero inteiro positivo e segment pode ser um dos casos a seguir: segment Uso Index Coment\u00e1rio argument Local onde o argumento da fun\u00e7\u00e3o est\u00e1 salvo 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada local Local das vari\u00e1veis locais da fun\u00e7\u00e3o 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada static Local onde as vari\u00e1veis do objeto est\u00e3o salvos 0 .. Essas vari\u00e1veis s\u00e3o compartilhadas por todas as fun\u00e7\u00f5es do mesmo .vm, assim como em um objeto constant Carrega uma constante na pilha 0 .. 32767 Mesmo uso do leaw (carrega da ROM um valor na RAM) this/that Segmentos de uso geral, pode apontar para qualquer lugar 0 .. Usado para ler e escrever de endere\u00e7os da mem\u00f3ria, por exemplo, acessar o LCD pointer Altera os valores do this e do that 0, 1 Usado para modificar a onde o this e o that apontam temp Local para uso de vari\u00e1veis tempor\u00e1rias 0 .. 7 Acessado por qualquer fun\u00e7\u00e3o, \u00e9 armazenado nos endere\u00e7os R5 .. R12 da RAM Exemplo, acessando o temp \u00b6 Por exemplo, para trazermos para a pilha uma constante realizamos a seguinte opera\u00e7\u00e3o: push constant 15 nesse caso o segmento acessado \u00e9 o constant e o par\u00e2metro \u00e9 o 15. Para salvarmos o valor 15 no temp 3 (endere\u00e7o da RAM 7), basta: push constant 15 pop temp 3 Podemos tamb\u00e9m trazer o temp 3 para a pilha: push temp 3 Programando Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/1a-Add Projetos/I-VM/src/vm/1b-Add Projetos/I-VM/src/vm/2a-Calculadora Antes de Continuar S\u00f3 Continue ap\u00f3s implementar e testar todos os programas! Escrevendo um pixel no LCD \u00b6 Para atualizarmos o LCD via VM ser\u00e1 necess\u00e1rio primeiro atualizarmos para onde o that aponta, that \u00e9 a maneira que possu\u00edmos de escrever em qualquer endere\u00e7o da mem\u00f3ria. O exemplo a seguir ilustra como usamos o segmento that para escrever nos pixels centrais do LCD, supondo que gostar\u00edamos de realizar a seguinte opera\u00e7\u00e3o em C. int * pLCD = 16384 * ( pLCD + 1200 ) = 0xFFFF Nesse pequeno c\u00f3digo em C o que est\u00e1 acontecendo \u00e9 que primeiramente definimos um ponteiro pLCD que aponta para 16384, depois fazemos com que o endere\u00e7o desse ponteiro + 1200 receba 0xFFFF, o mesmo c\u00f3digo em VM \u00e9 realizado da seguinte maneira : push constant 16384 -- carrega 16384 para a pilha pop pointer 1 -- atualiza para onde that aponta (int *pLCD = 16384) push constant 1 -- carrega 1 para a pilha neg -- nega o 1 para obter o valor 0xFFFF -- poderia ter realizado o push constant 4095 no lugar -- dessas duas opera\u00e7\u00f5es pop that 1200 -- faz com que o endere\u00e7o da mem\u00f3ria 16384 + 1200 = 0xFFFF GOTO \u00b6 Goto \u00e9 a maneira de desviarmos uma execu\u00e7\u00e3o em .vm, e possui a seguinte sintaxe: goto LABEL if-goto LABEL podemos utilizar dois tipos : goto : incondicional , salta sem condi\u00e7\u00e3o if-goto : condicional, salta se o \u00faltimo valor da pilha for True Exemplo: Salto para igual se 3 = 2 push constant 3 push constant 2 eq if-goto IGUAL .. .. label IGUAL .. .. Exemplo: Contador utilizando for utilizando goto // for(i=0; i<10; i++) // x = x+1; push constant 0 pop temp 0 push constant 1 pop temp 1 label LOOP_START push temp 0 push constant 10 eq if-goto END // se temp0 = 10 salta para o fim push temp 0 push constant 1 add pop temp 0 push temp 1 push temp 1 add pop temp 1 goto LOOP_START // If counter > 0, goto LOOP_START label END labels \u00b6 Os labels s\u00e3o definidos pela keyword label + nome : label nome PROGRAMANDO \u00b6 Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/1c-div Antes de Continuar S\u00f3 Continue ap\u00f3s implementar e testar todos o programa! Fun\u00e7\u00f5es \u00b6 A linguagem VM possibilita o uso de fun\u00e7\u00f5es, as fun\u00e7\u00f5es s\u00e3o definidas em novos arquivos .vm na mesma pasta do arquivo Main.vm. Por exemplo : Nesse projeto SimpleFunction possu\u00edmos duas fun\u00e7\u00f5es : O Main.vm e a SimpleFunction.vm . A fun\u00e7\u00e3o main deve sempre existir no projeto, e ser\u00e1 a primeira chamada na inicializa\u00e7\u00e3o do sistema (assim como no python e C). Para definirmos uma fun\u00e7\u00e3o em VM basta criarmos um arquivo com a extens\u00e3o .vm (que precisa ter o mesmo nome da fun\u00e7\u00e3o) que ser\u00e1 como uma classe do nosso projeto, podendo conter mais que um m\u00e9todo/fun\u00e7\u00e3o. Note Olhe o exemplo src/vmExamples/StatiTest/ para ver como isso funciona. Uma fun\u00e7\u00e3o \u00e9 definida pela seguinte estrutura : function functionName numberOfVars Onde : function: \u00e9 uma palavra reservado (keyword) para definir fun\u00e7\u00f5es functionName: \u00e9 o nome da fun\u00e7\u00e3o numberOfVars: a quantidade de vari\u00e1veis locais que essa fun\u00e7\u00e3o possui. Como exemplo, vamos transformar a seguinte fun\u00e7\u00e3o em python para vm : def SimpleFunction ( a , b ): aux0 = a + b aux1 = a - b return ( aux1 + aux0 ) Em vm: function SimpleFunction 2 push argument 0 push argument 1 add pop local 0 // aux0 = a + b push argument 0 push argument 1 sub pop local 1 // aux1 = a - b push local 0 push local 1 add // aux0 + aux1 return Essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais, que pode ser acessada pelo segmento local , os par\u00e2metros passados para a fun\u00e7\u00e3o (a e b) s\u00e3o acess\u00edveis pelo segmento argument : push argument 0 acessa o primeiro argumento da fun\u00e7\u00e3o ( a ), trazendo o dado para a pilha. push argument 1 acessa o primeiro argumento da fun\u00e7\u00e3o ( b ), trazendo o dado para a pilha. push/pop temp 0 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux0 ). push/pop temp 1 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux1 ). Note que os par\u00e2metros devem ser apenas leitura, n\u00e3o devendo escrever nesses segmentos. return \u00b6 A fun\u00e7\u00e3o considera como retorno o \u00faltimo valor da pilha, e sempre retorna um \u00fanico Chamada de fun\u00e7\u00e3o \u00b6 A chamada de fun\u00e7\u00e3o ocorre na pr\u00f3pria pilha, para isso \u00e9 necess\u00e1rio colocar na pilha os par\u00e2metros da fun\u00e7\u00e3o, no exemplo anterior : a b SP-> e em seguida fazer a chamada de fun\u00e7\u00e3o que possui a seguinte estrutura: call functionName numberOfParameters Onde : call : palavra reservada para chamada de fun\u00e7\u00f5es functionName : nome da fun\u00e7\u00e3o a ser chamada numberOfPar : quantidade de par\u00e2metros que essa fun\u00e7\u00e3o recebe. O exemplo a seguir chama a fun\u00e7\u00e3o SimpleFunction com os valores 5 e 8 function Main.main 0 push constant 5 push constant 8 call SimpleFunction 2 Graficamente \u00b6 PROGRAMANDO \u00b6 Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/2b-Calculadora Projetos/I-VM/src/vm/2c-Calculadora Projetos/I-VM/src/vm/2d-Calculadora Antes de continuar Escreva os programas e teste.","title":"Lab 17 - vm"},{"location":"vm-lab/#lab-17-vm","text":"Nesse lab iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado em prova e servir\u00e1 para voc\u00eas entenderem o pr\u00f3ximo projeto: I-VMTranslator e ser\u00e1 cobrado na ultima avalia\u00e7\u00e3o.","title":"Lab 17 - vm"},{"location":"vm-lab/#modulos-a-serem-implementados","text":"Os m\u00f3dulos est\u00e3o na pasta Projetos/H-VM/src/lab/ e est\u00e3o organizados por ordem de dificuldade: 1a-Add.nasm 1b-Add.nasm 2a-Calculadora.nasm 1c-Div.nasm 2b-Calculadora.nasm 2c-Calculadora.nasm 2d-Calculadora.nasm Para testar, basta editar o arquivo tests/config.txt com os m\u00f3dulos que deseja executar e ent\u00e3o executar o script: testeVM.py localizado na pasta do projeto. Exemplos Existem diversos exemplos de programas escritos em linguagem VM, eles est\u00e3o na pasta src/vmExamples/","title":"M\u00f3dulos a serem implementados"},{"location":"vm-lab/#linguagem-vm","text":"A linguagem VM proposta para o curso \u00e9 baseada em pilha (assim como tantas outras), as opera\u00e7\u00f5es nesse n\u00edvel n\u00e3o mais lidam com registradores do computador mas sim com dados que s\u00e3o colocados e tirados de uma pilha ( stack ). Uma grande vantagem disso \u00e9 a abstra\u00e7\u00e3o do hardware, agora n\u00e3o precisamos mais nos preocuparmos com a manipula\u00e7\u00e3o dos dados em baixo n\u00edvel e saber por exemplo quantos registradores possu\u00edmos (o VMTranslator ser\u00e1 encarregado disso). Um c\u00f3digo escrito em VM passa pelas seguintes etapas antes de ser executado em m\u00e1quina : VMTranslator Assembler .vm -------------> .nasm -------------> .hack Com o c\u00f3digo vm conseguimos implementar fun\u00e7\u00f5es, o que facilita muito o desenvolvimento de qualquer software e prepara o terreno para conseguirmos implementar uma linguagem de alto n\u00edvel. O c\u00f3digo vm \u00e9 traduzido para linguagem nasm pelo VMTranslator (voc\u00eas v\u00e3o ter que fazer parte desse programa no \u00faltimo projeto), e ent\u00e3o \u00e9 montado pelo Assembler para linguagem de m\u00e1quina. Temos diversas vantagens quando programamos em linguagem virtual : a. Abstra\u00e7\u00e3o de Hardware - (j\u00e1 n\u00e3o mais lidamos com o hardware diretamente) c. Portabilidade b. C\u00f3digo mais alto n\u00edvel - (chamada de fun\u00e7\u00f5es, linguagem mais pr\u00f3xima do que estamos acostumados, ...)","title":"Linguagem VM"},{"location":"vm-lab/#pilha","text":"A linguagem VM \u00e9 baseada em pilha, ou seja, todas as opera\u00e7\u00f5es que ser\u00e3o realizadas ser\u00e3o feitas na pilha. A pilha \u00e9 uma regi\u00e3o da mem\u00f3ria RAM (no nosso caso come\u00e7a no endere\u00e7o 256 da mem\u00f3ria RAM) reservada para armazenar os dados que est\u00e3o sendo manipulados. A pilha cresce conforme opera\u00e7\u00f5es de push (envio de dados para a pilha) v\u00e3o sendo executados, e decresce conforme opera\u00e7\u00f5es c\u00e1lculo ou de pull (retirar dados da pilha) s\u00e3o executadas. A figura a seguir demonstra a evolu\u00e7\u00e3o da pilha quando um programa em vm \u00e9 executado: A pilha come\u00e7a vazia e o Stack Pointer (SP) aponta para 256 Uma opera\u00e7\u00e3o de push constant 3 \u00e9 executada, SP \u00e9 incrementando e o valor 3 \u00e9 colocado no topo da pilha Uma opera\u00e7\u00e3o de push constant 7 \u00e9 executada, SP \u00e9 incrementando e o valor 7 \u00e9 colocado no topo da pilha Adicionasse os dois valores no topo da pilha add Retira o valor do topo da pilha para o endere\u00e7o de mem\u00f3ria tempor\u00e1rio 0 .","title":"Pilha"},{"location":"vm-lab/#stack-pointer-sp","text":"O Stack Pointer \u00e9 o endere\u00e7o de mem\u00f3ria ( RAM[0] ) reservado por apontar o topo da pilha, ou seja, a pr\u00f3xima posi\u00e7\u00e3o vazia da pilha. O SP \u00e9 salvo na RAM 0 (R0) e deve ser incrementado/decrementado conforme a pilha vai sendo manipulada.","title":"Stack Pointer (SP)"},{"location":"vm-lab/#operacoes","text":"Considerando a seguinte disposi\u00e7\u00e3o na pilha : ... ... X Y SP -> S\u00e3o suportadas as seguintes opera\u00e7\u00f5es aritm\u00e9ticas na pilha: add executa: X + Y sub executa: X - Y neg executa: - Y (complemento de dois) eq compara X == Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 gt compara X > Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 lt compara X < Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 and executa: X and Y (bit a bit) or executa: X or Y (bit a bit) not executa: not Y (bit a bit) Note que as opera\u00e7\u00f5es de compara\u00e7\u00e3o ( eq , gt , lt ) resulta em um True ou False e esse resultado \u00e9 salvo na pilha. Considere o exemplo a seguir (em hexa) que possui inicialmente na pilha os valores 0x2 , 0x3 e 0x5 , ap\u00f3s a opera\u00e7\u00e3o de eq os valores 3 e 5 s\u00e3o comparados e resulta em um valor True ou False ( 0xFFFF ou 0x0000 ). -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x5 SP-> SP-> Warning A pilha n\u00e3o \u00e9 'limpada' a cada opera\u00e7\u00e3o, os endere\u00e7os que n\u00e3o sofreram modifica\u00e7\u00e3o dado uma opera\u00e7\u00e3o continuam l\u00e1, mas voc\u00ea n\u00e3o pode considerar que eles s\u00e3o v\u00e1lidos! Se olharmos a mem\u00f3ria real do exemplo anterior seria a seguinte: -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x0 0x5 SP-> 0x5 0x5 SP-> 0x0 0x0 0x0 O mesmo acontece com arquivos que s\u00e3o deletados do seu computador, o sistema operacional n\u00e3o \"limpa a mem\u00f3ria\" sempre que um arquivo \u00e9 exclu\u00eddo, apenas apaga o ponteiro para aquele arquivo. stackoverflow Agora voc\u00ea consegue entender o significado do nome do site stack overflow? \u00e9 um estouro na pilha (quando o tamanho da pilha ultrapassa a mem\u00f3ria que est\u00e1 reservado para ela!)","title":"Opera\u00e7\u00f5es"},{"location":"vm-lab/#acesso-a-memoria","text":"Os comandos push e pop s\u00e3o a \u00fanica maneira que temos de acessar/manipular a mem\u00f3ria. O comando push traz para a pilha um valor da mem\u00f3ria (RAM ou ROM) e o comando pop salva na mem\u00f3ria um valor da pila (RAM). Os comandos possuem a seguinte sintaxe : push segment index pop segment index Onde index \u00e9 um n\u00famero inteiro positivo e segment pode ser um dos casos a seguir: segment Uso Index Coment\u00e1rio argument Local onde o argumento da fun\u00e7\u00e3o est\u00e1 salvo 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada local Local das vari\u00e1veis locais da fun\u00e7\u00e3o 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada static Local onde as vari\u00e1veis do objeto est\u00e3o salvos 0 .. Essas vari\u00e1veis s\u00e3o compartilhadas por todas as fun\u00e7\u00f5es do mesmo .vm, assim como em um objeto constant Carrega uma constante na pilha 0 .. 32767 Mesmo uso do leaw (carrega da ROM um valor na RAM) this/that Segmentos de uso geral, pode apontar para qualquer lugar 0 .. Usado para ler e escrever de endere\u00e7os da mem\u00f3ria, por exemplo, acessar o LCD pointer Altera os valores do this e do that 0, 1 Usado para modificar a onde o this e o that apontam temp Local para uso de vari\u00e1veis tempor\u00e1rias 0 .. 7 Acessado por qualquer fun\u00e7\u00e3o, \u00e9 armazenado nos endere\u00e7os R5 .. R12 da RAM","title":"Acesso a mem\u00f3ria"},{"location":"vm-lab/#exemplo-acessando-o-temp","text":"Por exemplo, para trazermos para a pilha uma constante realizamos a seguinte opera\u00e7\u00e3o: push constant 15 nesse caso o segmento acessado \u00e9 o constant e o par\u00e2metro \u00e9 o 15. Para salvarmos o valor 15 no temp 3 (endere\u00e7o da RAM 7), basta: push constant 15 pop temp 3 Podemos tamb\u00e9m trazer o temp 3 para a pilha: push temp 3 Programando Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/1a-Add Projetos/I-VM/src/vm/1b-Add Projetos/I-VM/src/vm/2a-Calculadora Antes de Continuar S\u00f3 Continue ap\u00f3s implementar e testar todos os programas!","title":"Exemplo, acessando o temp"},{"location":"vm-lab/#escrevendo-um-pixel-no-lcd","text":"Para atualizarmos o LCD via VM ser\u00e1 necess\u00e1rio primeiro atualizarmos para onde o that aponta, that \u00e9 a maneira que possu\u00edmos de escrever em qualquer endere\u00e7o da mem\u00f3ria. O exemplo a seguir ilustra como usamos o segmento that para escrever nos pixels centrais do LCD, supondo que gostar\u00edamos de realizar a seguinte opera\u00e7\u00e3o em C. int * pLCD = 16384 * ( pLCD + 1200 ) = 0xFFFF Nesse pequeno c\u00f3digo em C o que est\u00e1 acontecendo \u00e9 que primeiramente definimos um ponteiro pLCD que aponta para 16384, depois fazemos com que o endere\u00e7o desse ponteiro + 1200 receba 0xFFFF, o mesmo c\u00f3digo em VM \u00e9 realizado da seguinte maneira : push constant 16384 -- carrega 16384 para a pilha pop pointer 1 -- atualiza para onde that aponta (int *pLCD = 16384) push constant 1 -- carrega 1 para a pilha neg -- nega o 1 para obter o valor 0xFFFF -- poderia ter realizado o push constant 4095 no lugar -- dessas duas opera\u00e7\u00f5es pop that 1200 -- faz com que o endere\u00e7o da mem\u00f3ria 16384 + 1200 = 0xFFFF","title":"Escrevendo um pixel no LCD"},{"location":"vm-lab/#goto","text":"Goto \u00e9 a maneira de desviarmos uma execu\u00e7\u00e3o em .vm, e possui a seguinte sintaxe: goto LABEL if-goto LABEL podemos utilizar dois tipos : goto : incondicional , salta sem condi\u00e7\u00e3o if-goto : condicional, salta se o \u00faltimo valor da pilha for True Exemplo: Salto para igual se 3 = 2 push constant 3 push constant 2 eq if-goto IGUAL .. .. label IGUAL .. .. Exemplo: Contador utilizando for utilizando goto // for(i=0; i<10; i++) // x = x+1; push constant 0 pop temp 0 push constant 1 pop temp 1 label LOOP_START push temp 0 push constant 10 eq if-goto END // se temp0 = 10 salta para o fim push temp 0 push constant 1 add pop temp 0 push temp 1 push temp 1 add pop temp 1 goto LOOP_START // If counter > 0, goto LOOP_START label END","title":"GOTO"},{"location":"vm-lab/#labels","text":"Os labels s\u00e3o definidos pela keyword label + nome : label nome","title":"labels"},{"location":"vm-lab/#programando","text":"Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/1c-div Antes de Continuar S\u00f3 Continue ap\u00f3s implementar e testar todos o programa!","title":"PROGRAMANDO"},{"location":"vm-lab/#funcoes","text":"A linguagem VM possibilita o uso de fun\u00e7\u00f5es, as fun\u00e7\u00f5es s\u00e3o definidas em novos arquivos .vm na mesma pasta do arquivo Main.vm. Por exemplo : Nesse projeto SimpleFunction possu\u00edmos duas fun\u00e7\u00f5es : O Main.vm e a SimpleFunction.vm . A fun\u00e7\u00e3o main deve sempre existir no projeto, e ser\u00e1 a primeira chamada na inicializa\u00e7\u00e3o do sistema (assim como no python e C). Para definirmos uma fun\u00e7\u00e3o em VM basta criarmos um arquivo com a extens\u00e3o .vm (que precisa ter o mesmo nome da fun\u00e7\u00e3o) que ser\u00e1 como uma classe do nosso projeto, podendo conter mais que um m\u00e9todo/fun\u00e7\u00e3o. Note Olhe o exemplo src/vmExamples/StatiTest/ para ver como isso funciona. Uma fun\u00e7\u00e3o \u00e9 definida pela seguinte estrutura : function functionName numberOfVars Onde : function: \u00e9 uma palavra reservado (keyword) para definir fun\u00e7\u00f5es functionName: \u00e9 o nome da fun\u00e7\u00e3o numberOfVars: a quantidade de vari\u00e1veis locais que essa fun\u00e7\u00e3o possui. Como exemplo, vamos transformar a seguinte fun\u00e7\u00e3o em python para vm : def SimpleFunction ( a , b ): aux0 = a + b aux1 = a - b return ( aux1 + aux0 ) Em vm: function SimpleFunction 2 push argument 0 push argument 1 add pop local 0 // aux0 = a + b push argument 0 push argument 1 sub pop local 1 // aux1 = a - b push local 0 push local 1 add // aux0 + aux1 return Essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais, que pode ser acessada pelo segmento local , os par\u00e2metros passados para a fun\u00e7\u00e3o (a e b) s\u00e3o acess\u00edveis pelo segmento argument : push argument 0 acessa o primeiro argumento da fun\u00e7\u00e3o ( a ), trazendo o dado para a pilha. push argument 1 acessa o primeiro argumento da fun\u00e7\u00e3o ( b ), trazendo o dado para a pilha. push/pop temp 0 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux0 ). push/pop temp 1 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux1 ). Note que os par\u00e2metros devem ser apenas leitura, n\u00e3o devendo escrever nesses segmentos.","title":"Fun\u00e7\u00f5es"},{"location":"vm-lab/#return","text":"A fun\u00e7\u00e3o considera como retorno o \u00faltimo valor da pilha, e sempre retorna um \u00fanico","title":"return"},{"location":"vm-lab/#chamada-de-funcao","text":"A chamada de fun\u00e7\u00e3o ocorre na pr\u00f3pria pilha, para isso \u00e9 necess\u00e1rio colocar na pilha os par\u00e2metros da fun\u00e7\u00e3o, no exemplo anterior : a b SP-> e em seguida fazer a chamada de fun\u00e7\u00e3o que possui a seguinte estrutura: call functionName numberOfParameters Onde : call : palavra reservada para chamada de fun\u00e7\u00f5es functionName : nome da fun\u00e7\u00e3o a ser chamada numberOfPar : quantidade de par\u00e2metros que essa fun\u00e7\u00e3o recebe. O exemplo a seguir chama a fun\u00e7\u00e3o SimpleFunction com os valores 5 e 8 function Main.main 0 push constant 5 push constant 8 call SimpleFunction 2","title":"Chamada de fun\u00e7\u00e3o"},{"location":"vm-lab/#graficamente","text":"","title":"Graficamente"},{"location":"vm-lab/#programando_1","text":"Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/2b-Calculadora Projetos/I-VM/src/vm/2c-Calculadora Projetos/I-VM/src/vm/2d-Calculadora Antes de continuar Escreva os programas e teste.","title":"PROGRAMANDO"},{"location":"20b/simulados/","text":"Avalia\u00e7\u00f5es / Simulados \u00b6 AV1 \u00b6 HW SW Te\u00f3rica 30 Pr\u00e1tica 20 0 Parte te\u00f3rica no blackboard Parte pr\u00e1tica no github 20b-ele-simulado-av1 AV2 \u00b6 HW SW Te\u00f3rica 25 10 Pr\u00e1tica 10 37 Parte te\u00f3rica no google forms Parte pr\u00e1tica no github 20b-ele-av2-simulado Estudo Projetos: C - ULA, D - Sequencial, F - Assembly Labs: 6, 7, 8, 9, 10, 11, 12, 13, 14 Teoria: ULA, L\u00f3gica Sequencial, Componentes s\u00edncronos, Z01, Assembly, Mapa de mem\u00f3ria, jump Estudo: L\u00f3gica Sequencial 1 Solu\u00e7\u00f5es AV2 Te\u00f3rica: v\u00eddeos no link: http://54.162.111.146/shared/ele/20b/av2-simulado/ Pr\u00e1tica: no branch \"solu\u00e7\u00e3o\" no reposit\u00f3rio do simulado. AV3 \u00b6 HW SW Te\u00f3rica 10 25 Pr\u00e1tica 15 Parte te\u00f3rica estudar pelos labs: https://insper.github.io/Z01.1/Exercicio-CPU-1/ https://insper.github.io/Z01.1/Exercicio-CPU-2/ Parte pr\u00e1tica no github 20b-ele-av3-simulado Estudo Projetos: F-CPU e G-Assembler Labs: 15 e 16 Teoria: Linguagem de m\u00e1quina, Assembler, Tabela de S\u00edmbolos Estudo: Linguagem de m\u00e1quina 1, CPU 1, CPU 2 AV4 \u00b6 HW SW Te\u00f3rica 10 15 Pr\u00e1tica 33","title":"Avalia\u00e7\u00f5es / Simulados"},{"location":"20b/simulados/#avaliacoes-simulados","text":"","title":"Avalia\u00e7\u00f5es / Simulados"},{"location":"20b/simulados/#av1","text":"HW SW Te\u00f3rica 30 Pr\u00e1tica 20 0 Parte te\u00f3rica no blackboard Parte pr\u00e1tica no github 20b-ele-simulado-av1","title":"AV1"},{"location":"20b/simulados/#av2","text":"HW SW Te\u00f3rica 25 10 Pr\u00e1tica 10 37 Parte te\u00f3rica no google forms Parte pr\u00e1tica no github 20b-ele-av2-simulado Estudo Projetos: C - ULA, D - Sequencial, F - Assembly Labs: 6, 7, 8, 9, 10, 11, 12, 13, 14 Teoria: ULA, L\u00f3gica Sequencial, Componentes s\u00edncronos, Z01, Assembly, Mapa de mem\u00f3ria, jump Estudo: L\u00f3gica Sequencial 1 Solu\u00e7\u00f5es AV2 Te\u00f3rica: v\u00eddeos no link: http://54.162.111.146/shared/ele/20b/av2-simulado/ Pr\u00e1tica: no branch \"solu\u00e7\u00e3o\" no reposit\u00f3rio do simulado.","title":"AV2"},{"location":"20b/simulados/#av3","text":"HW SW Te\u00f3rica 10 25 Pr\u00e1tica 15 Parte te\u00f3rica estudar pelos labs: https://insper.github.io/Z01.1/Exercicio-CPU-1/ https://insper.github.io/Z01.1/Exercicio-CPU-2/ Parte pr\u00e1tica no github 20b-ele-av3-simulado Estudo Projetos: F-CPU e G-Assembler Labs: 15 e 16 Teoria: Linguagem de m\u00e1quina, Assembler, Tabela de S\u00edmbolos Estudo: Linguagem de m\u00e1quina 1, CPU 1, CPU 2","title":"AV3"},{"location":"20b/simulados/#av4","text":"HW SW Te\u00f3rica 10 15 Pr\u00e1tica 33","title":"AV4"},{"location":"21a/Avaliacoes/","text":"Avalia\u00e7\u00f5es \u00b6 Informa\u00e7\u00f5es sobre as avalia\u00e7\u00f5es (e simulados) da disciplina: AV4 - AF - sexta 02/12 \u00b6 Avalia\u00e7\u00e3o pr\u00e1tica individual a ser realizada no SSD Linux. A avalia\u00e7\u00e3o ser\u00e1 distribu\u00edda via github classroom (link estar\u00e1 no blakcboard) e o envio deve ser feito via ele. Liberado consulta ao material da disciplina. Projetos: F: CPU (HW) G: Assembler (SW) H: VM (SW) Prova - Av4 - 21b - Reposit\u00f3rio - Resolu\u00e7\u00e3o AV3 - sexta 11/11 \u00b6 Avalia\u00e7\u00e3o pr\u00e1tica individual a ser realizada no SSD Linux. A avalia\u00e7\u00e3o ser\u00e1 distribu\u00edda via github classroom (link estar\u00e1 no blakcboard) e o envio deve ser feito via ele. Liberado consulta ao material da disciplina. Projetos: D: L\u00f3gica sequencial E: Assembly Conte\u00fados: L\u00f3gica Sequ\u00eancial VHDL: Sequencial Assembly Assembly - Mapa de mem\u00f3ria Assembly - Saltos Linguagem de m\u00e1quina Conjunto de Instru\u00e7\u00f5es Prova - Av3 - 21b - Resolu\u00e7\u00e3o - Reposit\u00f3rio AV2 - AI - sexta 30/09 - Resolu\u00e7\u00e3o \u00b6 Avalia\u00e7\u00e3o pr\u00e1tica individual a ser realizada no SSD Linux. A avalia\u00e7\u00e3o ser\u00e1 distribu\u00edda via github classroom (link estar\u00e1 no blakcboard) e o envio deve ser feito via ele. Liberado consulta ao material da disciplina. Projetos: B: L\u00f3gica Combinacional C: ULA Conte\u00fados: Componentes Digitais Aritm\u00e9tica Bin\u00e1ria - HW: Half-Adder/ Full-Adder/ Somadores ULA L\u00f3gica Sequ\u00eancial VHDL: Combinacional RTL Formas de onda Arquivos de teste Prova - Av2 - 22a - Reposit\u00f3rio Prova - Av2 - 21b AV1 - quarta 31/08 \u00b6 Conte\u00fados: Organiza\u00e7\u00e3o de Computadores (vis\u00e3o geral) \u00c1lgebra booleana Portas l\u00f3gicas Tabela Verdade Soma dos produtos / Produto das somas Simplifica\u00e7\u00e3o via equa\u00e7\u00e3o alg\u00e9brica Simplifica\u00e7\u00e3o via mapa de Karnaught Equa\u00e7\u00e3o via circuito Circuito via equa\u00e7\u00e3o Transistores Portas l\u00f3gicas: not, and, or Dados digitais Bin\u00e1rio, Hexadecimal ASCII, BCD Convers\u00e3o entre bases Complemento de 2 Avalia\u00e7\u00e3o te\u00f3rica ser\u00e1 realizado no blackboard, com proctorio e sem consulta. Atividade de revis\u00e3o: Prairie Learn Transistores Prova 02/2021 Prova Quest\u00f5es de ENADE: 2008 2014 2017 Video","title":"Avalia\u00e7\u00f5es"},{"location":"21a/Avaliacoes/#avaliacoes","text":"Informa\u00e7\u00f5es sobre as avalia\u00e7\u00f5es (e simulados) da disciplina:","title":"Avalia\u00e7\u00f5es"},{"location":"21a/Avaliacoes/#av4-af-sexta-0212","text":"Avalia\u00e7\u00e3o pr\u00e1tica individual a ser realizada no SSD Linux. A avalia\u00e7\u00e3o ser\u00e1 distribu\u00edda via github classroom (link estar\u00e1 no blakcboard) e o envio deve ser feito via ele. Liberado consulta ao material da disciplina. Projetos: F: CPU (HW) G: Assembler (SW) H: VM (SW) Prova - Av4 - 21b - Reposit\u00f3rio - Resolu\u00e7\u00e3o","title":"AV4 - AF - sexta 02/12"},{"location":"21a/Avaliacoes/#av3-sexta-1111","text":"Avalia\u00e7\u00e3o pr\u00e1tica individual a ser realizada no SSD Linux. A avalia\u00e7\u00e3o ser\u00e1 distribu\u00edda via github classroom (link estar\u00e1 no blakcboard) e o envio deve ser feito via ele. Liberado consulta ao material da disciplina. Projetos: D: L\u00f3gica sequencial E: Assembly Conte\u00fados: L\u00f3gica Sequ\u00eancial VHDL: Sequencial Assembly Assembly - Mapa de mem\u00f3ria Assembly - Saltos Linguagem de m\u00e1quina Conjunto de Instru\u00e7\u00f5es Prova - Av3 - 21b - Resolu\u00e7\u00e3o - Reposit\u00f3rio","title":"AV3 - sexta 11/11"},{"location":"21a/Avaliacoes/#av2-ai-sexta-3009-resolucao","text":"Avalia\u00e7\u00e3o pr\u00e1tica individual a ser realizada no SSD Linux. A avalia\u00e7\u00e3o ser\u00e1 distribu\u00edda via github classroom (link estar\u00e1 no blakcboard) e o envio deve ser feito via ele. Liberado consulta ao material da disciplina. Projetos: B: L\u00f3gica Combinacional C: ULA Conte\u00fados: Componentes Digitais Aritm\u00e9tica Bin\u00e1ria - HW: Half-Adder/ Full-Adder/ Somadores ULA L\u00f3gica Sequ\u00eancial VHDL: Combinacional RTL Formas de onda Arquivos de teste Prova - Av2 - 22a - Reposit\u00f3rio Prova - Av2 - 21b","title":"AV2 - AI - sexta 30/09 - Resolu\u00e7\u00e3o"},{"location":"21a/Avaliacoes/#av1-quarta-3108","text":"Conte\u00fados: Organiza\u00e7\u00e3o de Computadores (vis\u00e3o geral) \u00c1lgebra booleana Portas l\u00f3gicas Tabela Verdade Soma dos produtos / Produto das somas Simplifica\u00e7\u00e3o via equa\u00e7\u00e3o alg\u00e9brica Simplifica\u00e7\u00e3o via mapa de Karnaught Equa\u00e7\u00e3o via circuito Circuito via equa\u00e7\u00e3o Transistores Portas l\u00f3gicas: not, and, or Dados digitais Bin\u00e1rio, Hexadecimal ASCII, BCD Convers\u00e3o entre bases Complemento de 2 Avalia\u00e7\u00e3o te\u00f3rica ser\u00e1 realizado no blackboard, com proctorio e sem consulta. Atividade de revis\u00e3o: Prairie Learn Transistores Prova 02/2021 Prova Quest\u00f5es de ENADE: 2008 2014 2017 Video","title":"AV1 - quarta 31/08"}]}